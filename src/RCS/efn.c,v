head	1.17;
access;
symbols;
locks; strict;
comment	@ * @;


1.17
date	2001.09.11.01.50.32;	author macke;	state Exp;
branches;
next	1.16;

1.16
date	2001.05.04.19.29.07;	author macke;	state Exp;
branches;
next	1.15;

1.15
date	2001.03.29.17.40.24;	author macke;	state Exp;
branches;
next	1.14;

1.14
date	2000.10.09.20.22.55;	author macke;	state Exp;
branches;
next	1.13;

1.13
date	2000.10.09.19.14.02;	author macke;	state Exp;
branches;
next	1.12;

1.12
date	2000.10.07.05.15.56;	author macke;	state Exp;
branches;
next	1.11;

1.11
date	2000.10.07.03.40.39;	author macke;	state Exp;
branches;
next	1.10;

1.10
date	2000.10.05.06.11.19;	author macke;	state Exp;
branches;
next	1.9;

1.9
date	2000.09.13.16.56.12;	author macke;	state Exp;
branches;
next	1.8;

1.8
date	2000.09.06.21.26.49;	author macke;	state Exp;
branches;
next	1.7;

1.7
date	2000.09.06.21.00.08;	author macke;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.30.17.54.27;	author macke;	state Exp;
branches;
next	1.5;

1.5
date	2000.08.30.17.49.49;	author macke;	state Exp;
branches;
next	1.4;

1.4
date	2000.08.30.17.17.18;	author macke;	state Exp;
branches;
next	1.3;

1.3
date	2000.08.30.15.54.07;	author macke;	state Exp;
branches;
next	1.2;

1.2
date	2000.08.30.04.27.44;	author macke;	state Exp;
branches;
next	1.1;

1.1
date	2000.08.30.03.06.11;	author macke;	state Exp;
branches;
next	;


desc
@ver 1.11 of ../efn/tmefn.c.  First version that works well
enough to begin integration into rnamotif.
@


1.17
log
@collected all e-params into a structure EFNDATA_T.  This will make
it easier to add support for DNA and T!=37 calcs
Fixed oversight that allowed uninitialized index to be used in 1x2
energy calcs.
@
text
@/*
 *	This program is a transliteration of the Zuker program efn.f
 *	I have made several obvious modifications in the string handling
 *	of the get data parts. I have also renumbered each array to begin
 *	at C's 0, vs the original FTN's 1.
 *
 *	I have noticed a possible bug in the routine that reads the
 * 	misc loop file, in an if that is always true ...  I have left
 *	it alone.
 *
 *	Since this program is intended for incorporation into rnamotif
 *	which can NOT do circular molecules I have discarded the
 *	bookkeeping that makes circular NA's into linear ones.
 *
 */
#include <stdio.h>
#include <string.h>
#include <math.h>

#include "rnamot.h"

double	atof();

#define	NINT(x)		((int)((x)>=0?(x)+.5:(x)-.5))

#define	WC(i,j)		((i)+(j) == 3)
#define	GU(i,j)		((i)==BCODE_G && (j)==BCODE_T)

extern	char	rm_bc2b[];
#define	N2B(n)	((n)>=BCODE_A&&(n)<=BCODE_T?rm_bc2b[(n)]:'x')

extern	char	rm_efndatadir[];
extern	int	rm_efndataok;
extern	int	rm_l_base;
extern	int	*rm_hstnum;
extern	int	*rm_bcseq;
extern	int	*rm_basepr;

static	char	emsg[ 256 ];

#define	MAX_IBHLOOP	30
#define	EPARAM_SIZE	16
#define	POPPEN_SIZE	4
#define	MAXTLOOPS	100
#define	MAXTRILOOPS	50

typedef	struct	efndata_t	{
	int	e_asint1x2[ 6 ][ 6 ][ 5 ][ 5 ][ 5 ];
	int	e_inter[ ( MAX_IBHLOOP + 1 ) ];
	int	e_bulge[ ( MAX_IBHLOOP + 1 ) ];
	int	e_hairpin[ ( MAX_IBHLOOP + 1 ) ];
	int	e_dangle[ 5 ][ 5 ][ 5 ][ 2 ];
	float	e_prelog;
	int	e_maxpen;
	int	e_eparam[ EPARAM_SIZE ];
	int	e_poppen[ POPPEN_SIZE + 1 ];
	int	e_sint2[ 6 ][ 6 ][ 5 ][ 5 ];
	int	e_sint4[ 6 ][ 6 ][ 5 ][ 5 ][ 5 ][ 5 ];
	int	e_tloops[ MAXTLOOPS ][ 2 ];
	int	e_ntloops;
	int	e_triloops[ MAXTRILOOPS ][ 2 ];
	int	e_ntriloops;
	int	e_stack[ 5 ][ 5 ][ 5 ][ 5 ];
	int	e_tstkh[ 5 ][ 5 ][ 5 ][ 5 ];
	int	e_tstki[ 5 ][ 5 ][ 5 ][ 5 ];
} EFNDATA_T;

static	EFNDATA_T	efndata;
static	EFNDATA_T	*efdp = &efndata;

/*
static	int	asint1x2[ 6 ][ 6 ][ 5 ][ 5 ][ 5 ];

static	int	inter[ ( MAX_IBHLOOP + 1 ) ];
static	int	bulge[ ( MAX_IBHLOOP + 1 ) ];
static	int	hairpin[ ( MAX_IBHLOOP + 1 ) ];

static	int	dangle[ 5 ][ 5 ][ 5 ][ 2 ];

static	float	prelog;
static	int	maxpen;
static	int	eparam[ EPARAM_SIZE ];
static	int	poppen[ POPPEN_SIZE + 1 ];

static	int	sint2[ 6 ][ 6 ][ 5 ][ 5 ];
static	int	sint4[ 6 ][ 6 ][ 5 ][ 5 ][ 5 ][ 5 ];

static	int	tloops[ MAXTLOOPS ][ 2 ];
static	int	n_tloops;
static	int	triloops[ MAXTRILOOPS ][ 2 ];
static	int	n_triloops;

static	int	stack[ 5 ][ 5 ][ 5 ][ 5 ];
static	int	tstkh[ 5 ][ 5 ][ 5 ][ 5 ];
static	int	tstki[ 5 ][ 5 ][ 5 ][ 5 ];
*/

#define	STKSIZE	500
static	int	stk[ STKSIZE ][ 3 ];
static	int	stkp;

char	*getenv( char * );

int	RM_getefndata( void );
static	int	gettloops( char [] );
static	int	gettriloops( char [] );
static	int	getmiscloop( char [] );
static	int	getdangle( char [] );
static	int	getibhloop( char [] );
static	int	getstack( char [], int [5][5][5][5], int );
static	int	stacktest( char [], int [5][5][5][5] );
static	int	getsymint( char [], char [] );
static	int	symtest( void );
static	int	getasymint( char [] );
static	int	packloop( char [] );

static	int	skipto( FILE *, char [], long, char [] );

void	RM_dumpefndata( FILE * );
static	void	dumpdangle( FILE * );
static	void	dumpibhloop( FILE * );
static	void	dumpstack( FILE *, char [], int [5][5][5][5] );
static	void	dumpsint( FILE *fp );

static	int	e_stack( int, int );
static	int	e_ibloop( int, int, int, int );
static	int	e_hploop( int, int );
static	int	e_dangle( int, int, int, int );
static	int	e_aupen( int, int );

void	RM_initst( void );
static	void	push( int, int, int );
static	int	pull( int *, int *, int * );

int	RM_allocefnds( int size )
{

	rm_hstnum = ( int * )malloc( size * sizeof( int ) );
	if( rm_hstnum == NULL ){
		RM_errormsg( 0, "RM_allocefnds: can't allocate rm_hstnum\n" );
		return( 1 );
	}
	rm_bcseq = ( int * )malloc( size * sizeof( int ) );
	if( rm_bcseq == NULL ){
		RM_errormsg( 0, "RM_allocefnds: can't allocate rm_bcseq\n" );
		return( 1 );
	}
	rm_basepr = ( int * )malloc( size * sizeof( int ) );
	if( rm_basepr == NULL ){
		RM_errormsg( 0, "RM_allocefnds: can't allocate rm_basepr\n" );
		return( 1 );
	}

	return( 0 );
}

int	RM_getefndata( void )
{
	int	rval = 1;

	if( *rm_efndatadir == '\0' ){
		RM_errormsg( 0, "RM_getefndata: No efn data directory." );
		return( 0 );
	}

	if( !gettloops( "tloop.dat" ) )
		rval = 0;

	if( !gettriloops( "triloop.dat" ) )
		rval = 0;

	if( !getmiscloop( "miscloop.dat" ) )
		rval = 0;

	if( !getdangle( "dangle.dat" ) )
		rval = 0;

	if( !getibhloop( "loop.dat" ) )
		rval = 0;

	if( !getstack( "stack.dat", efdp->e_stack, EFN_INFINITY ) )
		rval = 0;
	if( !stacktest( "stack.dat", efdp->e_stack ) )
		rval = 0;

	if( !getstack( "tstackh.dat", efdp->e_tstkh, 0 ) )
		rval = 0;
/*	This test will fail, as this stack is not symmetric
	if( !stacktest( "tstackh.dat", efdp->e_tstkh ) )
		rval = 0;
*/

	if( !getstack( "tstacki.dat", efdp->e_tstki, 0 ) )
		rval = 0;
/*	This test will fail, as this stack is not symmetric
	if( !stacktest( "tstacki.dat", efdp->e_tstki ) )
		rval = 0;
*/

	if( !getsymint( "sint2.dat", "sint4.dat" ) )
		rval = 0;
	if( !symtest() )
		rval = 0;

	if( !getasymint( "asint1x2.dat" ) )
		rval = 0;

	return( rval );
}

static	int	gettloops( char fname[] )
{
	char	pname[ 256 ];
	FILE	*fp;
	char	line[ 256 ];
	char	loop[ 20 ];
	float	energy;
	int	t, rval;

	sprintf( pname, "%s/%s", rm_efndatadir, fname );
	if( ( fp = fopen( pname, "r" ) ) == NULL ){
		sprintf( emsg, "gettloops: can't read tloops file '%s'.",
			pname );
		RM_errormsg( 0, emsg );
		return( 0 );
	}
	rval = 1;
	if( skipto( fp, "---", sizeof( line ), line ) ){
		for( t = 0; fgets( line, sizeof( line ), fp ); t++ ){
			sscanf( line, "%s %f", loop, &energy );
			if( t < MAXTLOOPS ){
				efdp->e_tloops[ t ][ 0 ] = packloop( loop );
				efdp->e_tloops[ t ][ 1 ] =
					NINT( 100.0 * energy );
			}
		}
	}else
		rval = 0;
	fclose( fp );

	if( t > MAXTLOOPS ){
		sprintf( emsg,
"gettloops: # of tloops (%d) exceeds MAXTLOOPS (%d), last %d tloops ignored.",
			t, MAXTLOOPS, t - MAXTLOOPS );
		RM_errormsg( 0, emsg );
		efdp->e_ntloops = MAXTLOOPS;
	}else
		efdp->e_ntloops = t;

	return( rval );
}

static	int	gettriloops( char fname[] )
{
	char	pname[ 256 ];
	FILE	*fp;
	char	line[ 256 ];
	char	loop[ 20 ];
	float	energy;
	int	t, rval;

	sprintf( pname, "%s/%s", rm_efndatadir, fname );
	if( ( fp = fopen( pname, "r" ) ) == NULL ){
		sprintf( emsg, "gettriloops: can't read triloops file '%s'.",
			pname );
		RM_errormsg( 0, emsg );
		return( 0 );
	}
	rval = 1;
	if( skipto( fp, "---", sizeof( line ), line ) ){
		for( t = 0; fgets( line, sizeof( line ), fp ); t++ ){
			sscanf( line, "%s %f", loop, &energy );
			if( t < MAXTRILOOPS ){
				efdp->e_triloops[ t ][ 0 ] = packloop( loop );
				efdp->e_triloops[ t ][ 1 ] = NINT( 100.0 * energy );
			}
		}
	}else
		rval = 0;
	fclose( fp );

	if( t > MAXTRILOOPS ){
		sprintf( emsg,
"gettloops: # of triloops (%d) exceeds MAXTRILOOPS (%d), last %d triloops ignored.",
			t, MAXTRILOOPS, t - MAXTRILOOPS );
		RM_errormsg( 0, emsg );
		efdp->e_ntriloops = MAXTRILOOPS;
	}else
		efdp->e_ntriloops = t;

	return( rval );
}

static	int	getmiscloop( char fname[] )
{
	char	pname[ 256 ];
	FILE	*fp;
	char	line[ 256 ];
	float	fv1, fv2, fv3, fv4;
	int	i, rval;

	sprintf( pname, "%s/%s", rm_efndatadir, fname );
	if( ( fp = fopen( pname, "r" ) ) == NULL ){
		sprintf( emsg, "getmiscloop: can't read miscloop file '%s'.",
			pname );
		RM_errormsg( 0, emsg );
		return( 0 );
	}

	rval = 1;
	if( skipto( fp, "-->", sizeof( line ), line ) ){
		fgets( line, sizeof( line ), fp );
		sscanf( line, "%f", &efdp->e_prelog );
		efdp->e_prelog *= 10.0;
	}else{
		RM_errormsg( 0, "getmiscloop: no prelog." );
		rval = 0;
		goto CLEAN_UP;
	}

	if( skipto( fp, "-->", sizeof( line ), line ) ){
		fgets( line, sizeof( line ), fp );
		sscanf( line, "%f", &fv1 );
		efdp->e_maxpen = NINT( 100.0*fv1 );
	}else{
		RM_errormsg( 0, "getmiscloop: no maxpen." );
		rval = 0;
		goto CLEAN_UP;
	}

	if( skipto( fp, "-->", sizeof( line ), line ) ){
		fgets( line, sizeof( line ), fp );
		sscanf( line, "%f %f %f %f", &fv1, &fv2, &fv3, &fv4 );
		efdp->e_poppen[ 0 ] = 0;
		efdp->e_poppen[ 1 ] = NINT( 100.0*fv1 );
		efdp->e_poppen[ 2 ] = NINT( 100.0*fv2 );
		efdp->e_poppen[ 3 ] = NINT( 100.0*fv3 );
		efdp->e_poppen[ 4 ] = NINT( 100.0*fv4 );
	}else{
		RM_errormsg( 0, "getmiscloop: no poppen values." );
		rval = 0;
		goto CLEAN_UP;
	}

	efdp->e_eparam[ 0 ] = 0;
	efdp->e_eparam[ 1 ] = 0;
	efdp->e_eparam[ 2 ] = 0;
	efdp->e_eparam[ 3 ] = 0;
	efdp->e_eparam[ 6 ] = 30;
	efdp->e_eparam[ 7 ] = 30;

	if( skipto( fp, "-->", sizeof( line ), line ) ){
		fgets( line, sizeof( line ), fp );
		sscanf( line, "%f %f %f", &fv1, &fv2, &fv3 );
		efdp->e_eparam[ 4 ] = NINT( 100.0*fv1 );
		efdp->e_eparam[ 5 ] = NINT( 100.0*fv2 );
		efdp->e_eparam[ 8 ] = NINT( 100.0*fv3 );
	}else{
		RM_errormsg( 0, "getmiscloop: no multibranched loop values." );
		rval = 0;
		goto CLEAN_UP;
	}

	if( !skipto( fp, "-->", sizeof( line ), line ) ){
		for( i = 9; i < EPARAM_SIZE; i++ )
			efdp->e_eparam[ i ] = 0;
	}else{	
		/* these parms are not currently used */
		fgets( line, sizeof( line ), fp );
		sscanf( line, "%f %f %f", &fv1, &fv2, &fv3 );

		if( skipto( fp, "-->", sizeof( line ), line ) ){
			fgets( line, sizeof( line ), fp );
			sscanf( line, "%f", &fv1 );
			efdp->e_eparam[ 9 ] = NINT( 100.0*fv1 );
		}else{
			RM_errormsg( 0,
				"getmiscloop: no terminal AU penalty." );
			rval = 0;
			goto CLEAN_UP;
		}
	
		if( skipto( fp, "-->", sizeof( line ), line ) ){
			fgets( line, sizeof( line ), fp );
			sscanf( line, "%f", &fv1 );
			efdp->e_eparam[ 10 ] = NINT( 100.0*fv1 );
		}else{
			RM_errormsg( 0, "getmiscloop: no GGG hairpin term." );
			rval = 0;
			goto CLEAN_UP;
		}
	
		if( skipto( fp, "-->", sizeof( line ), line ) ){
			fgets( line, sizeof( line ), fp );
			sscanf( line, "%f", &fv1 );
			efdp->e_eparam[ 11 ] = NINT( 100.0*fv1 );
		}else{
			RM_errormsg( 0, "getmiscloop: no c hairpin slope." );
			rval = 0;
			goto CLEAN_UP;
		}
	
		if( skipto( fp, "-->", sizeof( line ), line ) ){
			fgets( line, sizeof( line ), fp );
			sscanf( line, "%f", &fv1 );
			efdp->e_eparam[ 12 ] = NINT( 100.0*fv1 );
		}else{
			RM_errormsg( 0,
				"getmiscloop: no c hairpin intercept." );
			rval = 0;
			goto CLEAN_UP;
		}
	
		if( skipto( fp, "-->", sizeof( line ), line ) ){
			fgets( line, sizeof( line ), fp );
			sscanf( line, "%f", &fv1 );
			efdp->e_eparam[ 13 ] = NINT( 100.0*fv1 );
		}else{
			RM_errormsg( 0,
				"getmiscloop: no c hairpin of 3 term." );
			rval = 0;
			goto CLEAN_UP;
		}
	
		if( skipto( fp, "-->", sizeof( line ), line ) ){
			fgets( line, sizeof( line ), fp );
			sscanf( line, "%f", &fv1 );
			efdp->e_eparam[ 14 ] = NINT( 100.0*fv1 );
		}else{
			RM_errormsg( 0,
			"getmiscloop: no Intermol init free energy." );
			rval = 0;
			goto CLEAN_UP;
		}
	
		if( skipto( fp, "-->", sizeof( line ), line ) ){
			fgets( line, sizeof( line ), fp );
			sscanf( line, "%d", &efdp->e_eparam[ 15 ] );
		}else{
			RM_errormsg( 0, "getmiscloop: no GAIL Rule term." );
			rval = 0;
			goto CLEAN_UP;
		}
	}

CLEAN_UP : ;
	fclose( fp );

	return( rval );
}

static	int	getdangle( char fname[] )
{
	char	pname[ 256 ];
	FILE	*fp;
	char	line[ 256 ];
	int	v1, v2, v3, v4;
	char	*fields[ 16 ];
	int	f, n_fields;
	int	rval;

	sprintf( pname, "%s/%s", rm_efndatadir, fname );
	if( ( fp = fopen( pname, "r" ) ) == NULL ){
		sprintf( emsg, "getdangle: can't read dangle file '%s'.",
			pname );
		RM_errormsg( 0, emsg );
		return( 0 );
	}
	rval = 1;
	/* v1:	The last paired base:	5->3
	 * v2:	The first paired base;	3<-5
	 * v3:	The dangling base
	 * v4:	The dangling strand:	0 = 5->3, 1 = 3<-5
	 */
	for( v4 = 0; v4 < 2; v4++ ){
		for( v1 = 0; v1 < 4; v1++ ){
			if( !skipto( fp, "<--", sizeof( line ), line ) ){
				sprintf( emsg,
			"getdangle: premature end of dangle file '%s'\n", 
					fname );
				RM_errormsg( 0, emsg );
				rval = 0;
				goto CLEAN_UP;
			}
			fgets( line, sizeof( line ), fp );
			n_fields = split( line, fields, " \t\n" );
	
			for( f = 0; f < n_fields; f++ ){
				v2 = f / 4;
				v3 = f % 4;
				if( *fields[ f ] != '.' )
					efdp->e_dangle[v1][v2][v3][v4] = 
						NINT( 100.0*atof( fields[f] ) );
				free( fields[ f ] );
			}
		}
	}

CLEAN_UP : ;
	fclose( fp );

	return( rval );
}

static	int	getibhloop( char fname[] )
{
	char	pname[ 256 ];
	FILE	*fp;
	char	line[ 256 ];
	char	*fields[ 4 ];
	int	i, f, n_fields;
	int	rval;

	sprintf( pname, "%s/%s", rm_efndatadir, fname );
	if( ( fp = fopen( pname, "r" ) ) == NULL ){
		sprintf( emsg, "getibhloop: can't read ibhloop file '%s'.",
			pname );
		RM_errormsg( 0, emsg );
		return( 0 );
	}
	rval = 1;

	if( !skipto( fp, "---", sizeof( line ), line ) ){
		sprintf( emsg, "getibhloop: error in ibhloop file '%s'.",
			fname );
		RM_errormsg( 0, emsg );
		rval = 0;
		goto CLEAN_UP;
	}
	for( i = 1; i <= MAX_IBHLOOP; i++ ){
		fgets( line, sizeof( line ), fp );
		if( i <= MAX_IBHLOOP ){
			n_fields = split( line, fields, " \t\n" );
			if( *fields[ 1 ] == '.' )
				efdp->e_inter[ i ] = EFN_INFINITY;
			else
				efdp->e_inter[ i ] =
					NINT( 100.0*atof( fields[ 1 ] ) );
			if( *fields[ 2 ] == '.' )
				efdp->e_bulge[ i ] = EFN_INFINITY;
			else
				efdp->e_bulge[ i ] =
					NINT( 100.0*atof( fields[ 2 ] ) );
			if( *fields[ 3 ] == '.' )
				efdp->e_hairpin[ i ] = EFN_INFINITY;
			else
				efdp->e_hairpin[i] =
					NINT( 100.0*atof( fields[ 3 ] ) );
			for( f = 0; f < n_fields; f++ )
				free( fields[ f ] );
		}
	}

CLEAN_UP : ;
	fclose( fp );

	return( rval );
}

static	int	getstack( char sfname[], int stack[5][5][5][5], int defval ) 
{
	char	pname[ 256 ];
	FILE	*fp;
	char	line[ 256 ];
	int	v1, v2, v3, v4;
	char	*fields[ 16 ];
	int	f, n_fields;
	int	rval;
	
	sprintf( pname, "%s/%s", rm_efndatadir, sfname );
	if( ( fp = fopen( pname, "r" ) ) == NULL ){
		sprintf( emsg, "getstack: can't read stack file '%s'.",
			pname );
		RM_errormsg( 0, emsg );
		return( 0 );
	}
	rval = 1;

	for( v1 = 0; v1 < 5; v1++ ){
		for( v2 = 0; v2 < 5; v2++ ){
			for( v3 = 0; v3 < 5; v3++ ){
				for( v4 = 0; v4 < 5; v4++ )
					stack[v1][v2][v3][v4] = defval;
			}
		}
	}

	for( v1 = 0; v1 < 4; v1++ ){
		if( !skipto( fp, "<--", sizeof( line ), line ) ){
			sprintf( emsg,
				"getstack: premature end of stack file '%s'.",
				pname );
			RM_errormsg( 0, emsg );
			rval = 0;
			goto CLEAN_UP;
		}
		for( v3 = 0; v3 < 4; v3++ ){
			fgets( line, sizeof( line ), fp );
			n_fields = split( line, fields, " \t\n" );
			for( f = 0; f < n_fields; f++ ){
				v2 = f / 4;
				v4 = f % 4;
				if( *fields[ f ] == '.' )
					stack[v1][v2][v3][v4] = EFN_INFINITY;
				else
					stack[v1][v2][v3][v4] = 
						NINT(100.0*atof( fields[f] ));
				free( fields[ f ] );
			}
		}
	}

CLEAN_UP : ;
	fclose( fp );

	return( rval );
}

static	int	stacktest( char sname[], int stack[5][5][5][5] )
{
	int	rval;
	int	v1, v2, v3, v4;

	for( rval = 1, v1 = 0; v1 < 4; v1++ ){
		for( v2 = 0; v2 < 4; v2++ ){
			for( v3 = 0; v3 < 4; v3++ ){
				for( v4 = 0; v4 < 4; v4++ ){
					if(stack[v1][v2][v3][v4] !=
						stack[v4][v3][v2][v1] ){
						sprintf( emsg,
			"stacktest: stack '%s' symmetry error at %d,%d,%d,%d",
							sname,
							v1, v2, v3, v4 );
						RM_errormsg( 0, emsg );
						rval = 0;
					}
				}
			}
		}
	}
	return( rval );
}

static	int	getsymint( char s2fname[], char s4fname[] )
{
	char	pname[ 256 ];
	FILE	*fp;
	char	line[ 256 ];
	int	v1, v2, v3, v4, v5, v6;
	char	*fields[ 24 ];
	int	f, n_fields;
	int	lval, worst;
	int	rval;
	
	sprintf( pname, "%s/%s", rm_efndatadir, s2fname );
	if( ( fp = fopen( pname, "r" ) ) == NULL ){
		sprintf( emsg, "getsymint: can't read sym-2 loop file '%s'.",
			pname );
		RM_errormsg( 0, emsg );
		return( 0 );
	}
	rval = 1;

	/* Skip the header */	
	if( !skipto( fp, "<--", sizeof( line ), line ) ){
		sprintf( emsg, "getsymint: error in sym-2 loop file '%s'.",
			pname );
		RM_errormsg( 0, emsg );
		rval = 0;
		goto CLEAN_UP;
	}

	for( v1 = 0; v1 < 6; v1++ ){
		if( !skipto( fp, "<--", sizeof( line ), line ) ){
			sprintf( emsg,
			"getsymint: premature end of sym-2 loop file '%s'.",
				pname );
			RM_errormsg( 0, emsg );
			rval = 0;
			goto CLEAN_UP;
		}
		for( v3 = 0; v3 < 4; v3++ ){
			fgets( line, sizeof( line ), fp );
			n_fields = split( line, fields, " \t\n" );
			for( f = 0; f < n_fields; f++ ){
				v2 = f / 4;
				v4 = f % 4;
				lval = NINT( 100.0*atof( fields[ f ] ) );
				efdp->e_sint2[v1][v2][v3][v4] = lval;
				free( fields[ f ] );
			}
		}
	}
	fclose( fp );

	for( v1 = 0; v1 < 6; v1++ ){
		for( v2 = 0; v2 < 6; v2++ ){
			for( worst = -999, v3 = 0; v3 < 4; v3++ ){
				for( v4 = 0; v4 < 4; v4++ )
					worst=MAX(worst,
						efdp->e_sint2[v1][v2][v3][v4]);
			}
			for( v3 = 0; v3 < 5; v3++ ){
				efdp->e_sint2[v1][v2][v3][ 4] = worst;
				efdp->e_sint2[v1][v2][ 4][v3] = worst;
			}
		}
	}

	sprintf( pname, "%s/%s", rm_efndatadir, s4fname );
	if( ( fp = fopen( pname, "r" ) ) == NULL ){
		sprintf( emsg, "getsymint: can't read sym-4 loop file '%s'.",
			pname );
		RM_errormsg( 0, emsg );
		return( 0 );
	}

	/* Skip the header */	
	if( !skipto( fp, "<--", sizeof( line ), line ) ){
		sprintf( emsg, "getsymint: error in sym-4 loop file '%s'.",
			pname );
		RM_errormsg( 0, emsg );
		rval = 0;
		goto CLEAN_UP;
	}

	for( v1 = 0; v1 < 6; v1++ ){
	    for( v2 = 0; v2 < 6; v2++ ){
		if( !skipto( fp, "<--", sizeof( line ), line ) ){
		    sprintf( emsg,
			"getsymint: premature end of sym-2 loop file '%s'.",
			pname );
		    RM_errormsg( 0, emsg );
		    rval = 0;
		    goto CLEAN_UP;
		}
		for( v3 = 0; v3 < 4; v3++ ){
		    for( v4 = 0; v4 < 4; v4++ ){
			fgets( line, sizeof( line ), fp );
			n_fields = split(line, fields, " \t\n");
			for( f = 0; f < n_fields; f++ ){
			    v5 = f / 4;
			    v6 = f % 4;
			    lval = NINT( 100.0*atof( fields[f] ) );
			    efdp->e_sint4[v1][v2][v3][v4][v5][v6]= lval;
			    free( fields[ f ] );
			}
		    }
		}
	    }
	}

	for( v1 = 0; v1 < 6; v1++ ){
	    for( v2 = 0; v2 < 6; v2++ ){
		for( worst = -999, v3 = 0; v3 < 4; v3++ ){
		    for( v4 = 0; v4 < 4; v4++ ){
			for( v5 = 0; v5 < 4; v5++ ){
			    for( v6 = 0; v6 < 4; v6++ ){
				worst = MAX( worst,
				    efdp->e_sint4[v1][v2][v3][v4][v5][v6] );
			    }
			}
		    }
		}
		for( v3 = 0; v3 < 5; v3++ ){
		    for( v4 = 0; v4 < 5; v4++ ){
			for( v5 = 0; v5 < 5; v5++ ){
			    efdp->e_sint4[v1][v2][v3][v4][v5][ 4] = worst;
			    efdp->e_sint4[v1][v2][v3][v4][ 4][v5] = worst;
			    efdp->e_sint4[v1][v2][v3][ 4][v4][v5] = worst;
			    efdp->e_sint4[v1][v2][ 4][v3][v4][v5] = worst;
			}
		    }
		}
	    }
	}

CLEAN_UP : ;
	fclose( fp );

	return( rval );
}

static	int	symtest( void )
{
	int	v1, v2, v3, v4, v5, v6, v1a, v2a;
	int	rval;

	for( rval = 1, v1 = 0; v1 < 6; v1++ ){
	    for( v2 = 0; v2 < 6; v2++ ){
		v1a = v1 >= 4 && v1 < 6 ? 9 - v1 : 3 - v1;
		v2a = v2 >= 4 && v2 < 6 ? 9 - v2 : 3 - v2;
		for( v3 = 0; v3 < 4; v3++ ){
		    for( v4 = 0; v4 < 4; v4++ ){
			if( efdp->e_sint2[v1][v2][v3][v4] !=
				efdp->e_sint2[v2a][v1a][v4][v3] )
			{
			    rval = 0;
			    sprintf( emsg,
"symtest: sint2 failure: sint2[%d][%d][%d][%d] (%d) != sint2[%d][%d][%d][%d] (%d)",
				v1,v2,v3,v4,efdp->e_sint2[v1][v2][v3][v4],
				v2a,v1a,v4,v3,efdp->e_sint2[v2a][v1a][v4][v3] );
			    RM_errormsg( 0, emsg );
			}
		    }
		}
	    }
	}

	for( v1 = 0; v1 < 6; v1++ ){
	    for( v2 = 0; v2 < 6; v2++ ){
		v1a = v1 >= 4 && v1 < 6 ? 9 - v1 : 3 - v1;
		v2a = v2 >= 4 && v2 < 6 ? 9 - v2 : 3 - v2;
		for( v3 = 0; v3 < 4; v3++ ){
		    for( v4 = 0; v4 < 4; v4++ ){
			for( v5 = 0; v5 < 4; v5++ ){
			    for( v6 = 0; v6 < 4; v6++ ){
				if(efdp->e_sint4[v1][v2][v3][v4][v5][v6] !=
				    efdp->e_sint4[v2a][v1a][v6][v5][v4][v3] )
				{
				    rval = 0;
				    sprintf( emsg, 
"symtest: sint4 failure: sint4[%d][%d][%d][%d][%d][%d] (%d) != sint4[%d][%d][%d][%d][%d][%d] (%d)\n",
					v1, v2, v3, v4, v5, v6,
					efdp->e_sint4[v1][v2][v3][v4][v5][v6],
					v2a, v1a, v6, v5, v4, v3,
				    efdp->e_sint4[v2a][v1a][v6][v5][v4][v3] );
				    RM_errormsg( 0, emsg );
				}
			    }
			}
		    }
		}
	    }
	}

	return( rval );
}
static	int	getasymint( char fname[] )
{
	char	pname[ 256 ];
	FILE	*fp;
	char	line[ 256 ];
	int	v1, v2, v3, v4, v5;
	char	*fields[ 24 ];
	int	f, n_fields;
	int	lval;
	int	rval;
	
	sprintf( pname, "%s/%s", rm_efndatadir, fname );
	if( ( fp = fopen( pname, "r" ) ) == NULL ){
		sprintf( emsg,
			"getasymint: can't read asym-1x2 loop file '%s'.",
			pname );
		RM_errormsg( 0, emsg );
		return( 0 );
	}
	rval = 1;

	/* Skip the header */	
	if( !skipto( fp, "<--", sizeof( line ), line ) ){
		sprintf( emsg, "getasymint: error in asym-1x2 loop file '%s'.",
			fname );
		RM_errormsg( 0, emsg );
		rval = 0;
		goto CLEAN_UP;
	}

	for( v1 = 0; v1 < 6; v1++ ){
	    for( v2 = 0; v2 < 6; v2++ ){
		for( v3 = 0; v3 < 5; v3++ ){
		    for( v4 = 0; v4 < 5; v4++ ){
			for( v5 = 0; v5 < 5; v5++ )
			    efdp->e_asint1x2[v1][v2][v3][v4][v5] = EFN_INFINITY;
		    }
		}
	    }
	}

	for( v1 = 0; v1 < 6; v1++ ){
	    for( v5 = 0; v5 < 4; v5++ ){
		if( !skipto( fp, "<--", sizeof( line ), line ) ){
			sprintf( emsg,
		"getasymint: premature end of asym-1x2 loop file '%s'.",
				fname );
			RM_errormsg( 0, emsg );
			rval = 0;
			goto CLEAN_UP;
		}
		for( v3 = 0; v3 < 4; v3++ ){
		    fgets( line, sizeof( line ), fp );
		    n_fields = split( line, fields, " \t\n" );
		    for( f = 0; f < n_fields; f++ ){
			v2 = f / 4;
			v4 = f % 4;
			lval = NINT( 100.0*atof( fields[ f ] ) );
			efdp->e_asint1x2[v1][v2][v3][v4][v5] = lval;
			free( fields[ f ] );
		    }
		}
	    }
	}

CLEAN_UP : ;
	fclose( fp );
	
	return( rval );
}

static	int	packloop( char loop[] )
{
	char	*lp;
	int	num;

	for( lp = loop, num = 0; *lp; lp++ ){
		switch( *lp ){
		case 'A' :
		case 'a' :
			num = ( num << 3 ) + 1;
			break;
		case 'C' :
		case 'c' :
			num = ( num << 3 ) + 2;
			break;
		case 'G' :
		case 'g' :
			num = ( num << 3 ) + 3;
			break;
		case 'T' :
		case 't' :
		case 'U' :
		case 'u' :
			num = ( num << 3 ) + 4;
			break;
		default :
			sprintf( emsg,
				"packloop: illegal char %c (%d)", *lp, *lp );
			RM_errormsg( 1, emsg );
			exit( 1 );
		}
	}
	return( num );
}

static	int	skipto( FILE *fp, char str[], long s_line, char line[] )
{

	while( fgets( line, s_line, fp ) ){
		if( strstr( line, str ) )
			return( 1 );
	}
	return( 0 );
}

void	RM_dumpefndata( FILE *fp )
{

	dumpdangle( fp );
	dumpibhloop( fp );
	dumpstack( fp, "stack", efdp->e_stack );
	dumpstack( fp, "tstackh", efdp->e_tstkh );
	dumpstack( fp, "tstacki", efdp->e_tstki );
	dumpsint( fp );
}

static	void	dumpdangle( FILE *fp )
{
	int	v1, v2, v3, v4;
	float	dval;

	fprintf( fp, "\ndangle:\n" );
	for( v4 = 0; v4 < 2; v4++ ){
		for( v1 = 0; v1 < 4; v1++ ){
			for( v2 = 0; v2 < 4; v2++ ){
				if( v2 > 0 )
					fprintf( fp, "|" );
				for( v3 = 0; v3 < 4; v3++ ){
					fprintf( fp, " %c%c  ", N2B( v1 ),
						v4 == 0 ? N2B( v3 ) : ' ' );
				}
			}
			fprintf( fp, "\n" );
			for( v2 = 0; v2 < 4; v2++ ){
				if( v2 > 0 )
					fprintf( fp, "|" );
				for( v3 = 0; v3 < 4; v3++ ){
					fprintf( fp, " %c%c  ", N2B( v2 ),
						v4 == 1 ? N2B( v3 ) : ' ' );
				}
			}
			fprintf( fp, "\n" );
			for( v2 = 0; v2 < 4; v2++ ){
				if( v2 > 0 )
					fprintf( fp, "|" );
				for( v3 = 0; v3 < 4; v3++ ){
					dval = 
					    0.01*efdp->e_dangle[v1][v2][v3][v4];
					if( dval == 0 )
						fprintf( fp, " .   " );
					else
						fprintf( fp, "%5.2f", dval );
				}
			}
			fprintf( fp, "\n" );
			fprintf( fp, "\n" );
		}
	}
}

static	void	dumpibhloop( FILE *fp )
{
	int	i;

	fprintf( fp, "\nibh:\n" );
	for( i = 1; i <= MAX_IBHLOOP; i++ ){
		fprintf( fp, "%3d", i );
		if( efdp->e_inter[ i ] == EFN_INFINITY )
			fprintf( fp, "   .  " );
		else
			fprintf( fp, " %5.2f", 0.01*efdp->e_inter[ i ] );
		if( efdp->e_bulge[ i ] == EFN_INFINITY )
			fprintf( fp, "   .  " );
		else
			fprintf( fp, " %5.2f", 0.01*efdp->e_bulge[ i ] );
		if( efdp->e_hairpin[ i ] == EFN_INFINITY )
			fprintf( fp, "   .  " );
		else
			fprintf( fp, " %5.2f", 0.01*efdp->e_hairpin[ i ] );
		fprintf( fp, "\n" );
	}
}

static	void	dumpstack( FILE *fp, char sname[], int stack[5][5][5][5] )
{
	int	v1, v2, v3, v4;
	float	dval;

	fprintf( fp, "\nstack '%s':\n", sname );
	for( v1 = 0; v1 < 4; v1++ ){
		for( v3 = 0; v3 < 4; v3++ ){
			if( v3 > 0 )
				fprintf( fp, "|" );
			for( v4 = 0; v4 < 4; v4++ ){
				fprintf( fp, " %cX  ", N2B( v1 ) );
			} 
		}
		fprintf( fp, "\n" );
		for( v3 = 0; v3 < 4; v3++ ){
			if( v3 > 0 )
				fprintf( fp, "|" );
			for( v4 = 0; v4 < 4; v4++ ){
				fprintf( fp, " %cY  ", N2B( v3 ) );
			} 
		}
		fprintf( fp, "\n" );
		for( v3 = 0; v3 < 4; v3++ ){
			for( v2 = 0; v2 < 4; v2++ ){
				if( v2 > 0 )
					fprintf( fp, "|" );
				for( v4 = 0; v4 < 4; v4++ ){
					dval = stack[v1][v2][v3][v4];
					if( dval == EFN_INFINITY )
						fprintf( fp, " .   " );
					else
						fprintf(fp, "%5.2f", 0.01*dval);
							

				} 
			}
			fprintf( fp, "\n" );
		}
	}
}

static	void	dumpsint( FILE *fp )
{
	int	v1, v2, v3, v4;
	int	x1, x2, y1, y2;

	fprintf( fp, "\nsint2:\n" );
	for( v1 = 0; v1 < 6; v1++ ){
		for( v3 = 0; v3 < 4; v3++ ){
			for( v2 = 0; v2 < 6; v2++ ){
				for( v4 = 0; v4 < 4; v4++ ){
					fprintf( fp, "%5.2f",
					    .01*efdp->e_sint2[v1][v2][v3][v4] );
				}
				if( v2 < 5 )
					fprintf( fp, "|" );
			}
			fprintf( fp, "\n" );
			if( v3 == 3 )
				fprintf( fp, "\n" );
		}
	}

	fprintf( fp, "\nsint4:\n" );
	for( v1 = 0; v1 < 6; v1++ ){
		for( v2 = 0; v2 < 6; v2++ ){
			for( v3 = 0; v3 < 16; v3++ ){
				x1 = v3 / 4;
				x2 = v3 % 4;
				for( v4 = 0; v4 < 16; v4++ ){
					y1 = v4 / 4;
					y2 = v4 % 4;
					fprintf( fp, "%5.2f",
				    .01*efdp->e_sint4[v1][v2][x1][x2][y1][y2] );
				}
				fprintf( fp, "\n" );
				if( v3 == 15 )
					fprintf( fp, "\n" );
			}
		}
	}
}

/* No knots allowed! */
int	RM_knotted( void )
{
	int	i, j, ip, k, l;
	int	rval;

	for( rval = 0, i = 0; i <= rm_l_base; i++ ){
		if( rm_basepr[ i ] != UNDEF ){
			j = MAX( i, rm_basepr[i] );
			ip = MIN( i, rm_basepr[i] );
			if( rm_basepr[ip] != j || rm_basepr[j] != ip ){
				rval = 1;
				sprintf( emsg,
					"Base pair %5d.%5d is not reflexive\n",
					rm_hstnum[ip], rm_hstnum[j] );
				RM_errormsg( 0, emsg );
			}
			for( k = ip+1; k <= j-1; k++ ){
				if( rm_basepr[ k ] != UNDEF ){
					l = rm_basepr[ k ];
					if( l <= ip || l >= j ){
						rval = 1;
						sprintf( emsg,
	"RM_knotted: Base pairs %5d.%5d and %5d.%5d are improperly nested.\n",
						rm_hstnum[ip], rm_hstnum[j],
						rm_hstnum[k], rm_hstnum[l] );
						RM_errormsg( 0, emsg );
					}
				}
			}
		}
	}
	return( rval );
}

/* energy function driver */
int	RM_efn( int i, int j, int open )
{
	int	e;
	int	ip, is, jp, js;
	int	k, kp, sum;

	e = 0;
	if( rm_basepr[i] == UNDEF || rm_basepr[j] == UNDEF ){
		if( open == 0 ){
			while( rm_basepr[i]==UNDEF && rm_basepr[i+1]==UNDEF ){
				i++;
				e += efdp->e_eparam[5];
				if( i >= j-1 )
					return( e );
			}
			while( rm_basepr[j]==UNDEF && rm_basepr[j-1]==UNDEF ){
				j--;
				e += efdp->e_eparam[5];
				if( i >= j-1 )
					return( e );
			}

			if( rm_basepr[i] == UNDEF && rm_basepr[i+1] > i+1 ){
				e += MIN( 0, e_dangle(rm_basepr[i+1],i+1,i,1) )
					+ efdp->e_eparam[5];
				i++;
			}
			if( rm_basepr[j] == UNDEF && rm_basepr[j-1] != UNDEF &&
				rm_basepr[j-1] < j-1 )
			{
				e += MIN( 0, e_dangle(j-1,rm_basepr[j-1],j,0) )
					+ efdp->e_eparam[5];
				j--;
			}
		}else{
			while( rm_basepr[i]==UNDEF && rm_basepr[i+1]==UNDEF ){
				i++;
				if( i >= j-1 )
					return( e );
			}
			while( rm_basepr[j]==UNDEF && rm_basepr[j-1]==UNDEF ){
				j--;
				if( i >= j-1 )
					return( e );
			}

			if( rm_basepr[i] == UNDEF && rm_basepr[i+1] > i+1 ){
				e += MIN( 0, e_dangle(rm_basepr[i+1],i+1,i,1) );
				i++;
			}
			if( rm_basepr[j] == UNDEF && rm_basepr[j-1] != UNDEF &&
				rm_basepr[j-1] < j-1 )
			{
				e += MIN( 0, e_dangle(j-1,rm_basepr[j-1],j,0) );
				j--;
			}
		}
	}

	if( rm_basepr[i] != j ){
		k = rm_basepr[i];
		kp = rm_basepr[j];
		if( k >= kp ){
			sprintf( emsg, "RM_efn: knot: (%5d.%5d) (%5d.%5d)\n",
				rm_hstnum[i], rm_hstnum[k],
				rm_hstnum[kp], rm_hstnum[j] );
			RM_errormsg( 0, emsg );
			return( EFN_INFINITY );
		}
		if( rm_basepr[k+1] != UNDEF ){
			e += RM_efn( i, k, open );
			e += RM_efn( k+1, j, open );
		}else if( rm_basepr[k+2] == UNDEF ){
			e += RM_efn( i, k+1, open );
			e += RM_efn( k+2, j, open );
		}else if(e_dangle( k,i,k+1,0 ) <=
			e_dangle( rm_basepr[k+2],k+2,k+1,1 ))
		{
			e += RM_efn( i, k+1, open );
			e += RM_efn( k+2, j, open );
		}else{
			e += RM_efn( i, k, open );
			e += RM_efn( k+1, j, open );
		}
		return( e );
	}else{
		if( !open )
			e += efdp->e_eparam[8];
		e += e_aupen( i, j );

		for( open = 0; ; ){
			if( rm_basepr[i+1] == j-1 ){
				e += e_stack( i, j );
				i++;
				j--;
				continue;
			}

			for( sum = 0, k = i+1; k < j; ){
				if( rm_basepr[k] > k ){
					sum++;
					ip = k;
					k = rm_basepr[k] + 1;
					jp = k - 1;
					if( k > j ){
						sprintf( emsg,
						"RM_efn: ERROR: %d\n", 51 );
						RM_errormsg( 0, emsg );
						return( EFN_INFINITY );
					}
				}else if( rm_basepr[k] == UNDEF )
					k++;
			}

			if( sum == 0 ){	/* hairpin */
				e += e_hploop( i, j );
				return( e );
			}else if( sum == 1 ){ /* internal or bulge loop */
				e += e_ibloop( i, j, ip, jp );
				i = ip;
				j = jp;
				continue;
			}else{
				is = i + 1;
				js = j - 1;
				e += efdp->e_eparam[4] +
					efdp->e_eparam[8] + e_aupen( i, j );
				if( rm_basepr[i+1]==UNDEF &&
					rm_basepr[i+2]!=UNDEF )
				{
					if( e_dangle(i,j,i+1,0) <=
						e_dangle(rm_basepr[i+2],
						i+2,i+1,1) )
					{
						is = i + 2;
						e += MIN( 0,
							e_dangle( i,j,i+1,0 )) +
							efdp->e_eparam[5];
					}
				}
				if( rm_basepr[i+1]==UNDEF &&
					rm_basepr[i+2]==UNDEF )
				{
					is = i + 2;
					e += MIN( 0, e_dangle( i,j,i+1,0 ) ) +
						efdp->e_eparam[5];
				}
				if( rm_basepr[j-1]==UNDEF &&
					rm_basepr[j-2]!=UNDEF )
				{
					if( e_dangle(i,j,j-1,1) <=
						e_dangle(j-2,rm_basepr[j-2],
						j-1,0) )
					{
						js = j - 2;
						e += MIN( 0,
							e_dangle( i,j,j-1,1 )) +
							efdp->e_eparam[5];
					}
				}
				if( rm_basepr[j-1]==UNDEF &&
					rm_basepr[j-2]==UNDEF )
				{
					js = j - 2;
					e += MIN( 0, e_dangle( i,j,j-1,1 ) ) +
						efdp->e_eparam[5];
				}
				e += RM_efn( is, js, 0 );
				return( e );
			}
		}
	}
	return( e );
}

/* helical stacking energy */
static	int	e_stack( int i, int j )
{
	int	rval;

	if( i == rm_l_base || j == rm_l_base + 1 )
		return( EFN_INFINITY );

	rval = efdp->e_stack[rm_bcseq[i]][rm_bcseq[j]]
		[rm_bcseq[i+1]][rm_bcseq[j-1]] +
		efdp->e_eparam[0];
	return( rval );
}

/* interior & bulge loop energy */
static	int	e_ibloop( int i, int j, int ip, int jp )
{
	int	size, size1, size2, min4;
	int	lopsid, loginc;
	int	lf, rt;
	int	rval;

	if( i<=rm_l_base && ip>rm_l_base || jp<=rm_l_base && j>rm_l_base )
		return( EFN_INFINITY );

	rval = 0;
	size1 = ip - i - 1;
	size2 = j - jp - 1;
	size = size1 + size2;
	min4 = MIN( 4, MIN( size1, size2 ) );

	if( size1 == 0 || size2 == 0 ){ /* bulges */
		if( size == 1 ){
			rval += 
	    efdp->e_stack[rm_bcseq[i]][rm_bcseq[j]][rm_bcseq[ip]][rm_bcseq[jp]]
			    + efdp->e_bulge[size] + efdp->e_eparam[1];
		}else{
			rval += e_aupen( i, j ) + e_aupen( ip, jp );
			if( size > 30 ){
				loginc = NINT(efdp->e_prelog*log(size / 30.0));
				rval += efdp->e_bulge[30] + loginc +
				efdp->e_eparam[1];
			}else
				rval += efdp->e_bulge[size] + efdp->e_eparam[1];
		}
	}else{	/* internal loops */
		lopsid = fabs( ( double )( size1 - size2 ) );
		if( size > 30 ){			/* BIG loops	*/
			loginc = NINT( efdp->e_prelog*log( size / 30. ) );
			if( ( size1==1 || size2==1 ) && efdp->e_eparam[15]==1 ){
				rval +=
		efdp->e_tstki[rm_bcseq[i]][rm_bcseq[j]][BCODE_A][BCODE_A] +
		efdp->e_tstki[rm_bcseq[jp]][rm_bcseq[ip]][BCODE_A][BCODE_A]+
					efdp->e_inter[30] + loginc +
					efdp->e_eparam[2] +
					MIN(efdp->e_maxpen,
						lopsid*efdp->e_poppen[min4]);
			}else{
				rval +=
efdp->e_tstki[rm_bcseq[i]][rm_bcseq[j]][rm_bcseq[i+1]][rm_bcseq[j-1]] +
efdp->e_tstki[rm_bcseq[jp]][rm_bcseq[ip]][rm_bcseq[jp+1]][rm_bcseq[ip-1]] +
					efdp->e_inter[30] + loginc +
					efdp->e_eparam[2] +
					MIN(efdp->e_maxpen,
						lopsid*efdp->e_poppen[min4]);
			}
		}else if( lopsid == 1 && size == 3 ){	/* 2x1 loops	*/
			if( size1 < size2 ){
				if( WC( rm_bcseq[i], rm_bcseq[j] ) )
					lf = rm_bcseq[i];
				else if( GU( rm_bcseq[i], rm_bcseq[j] ) )
					lf = 4;
				else if( GU( rm_bcseq[j], rm_bcseq[i] ) ) 
					lf = 5;
				else
					return( EFN_INFINITY );
				if( WC( rm_bcseq[ip], rm_bcseq[jp] ) )
					rt = rm_bcseq[ip];
				else if( GU( rm_bcseq[ip], rm_bcseq[jp] ) )
					rt = 4;
				else if( GU( rm_bcseq[jp], rm_bcseq[ip] ) ) 
					rt = 5;
				else
					return( EFN_INFINITY );
				if( size == 3 ){ /* allow exp. for 3x2 loops */
					rval += efdp->e_eparam[2] +
	efdp->e_asint1x2[lf][rt][rm_bcseq[i+1]][rm_bcseq[j-1]][rm_bcseq[jp+1]];
				}
			}else{
				if( WC( rm_bcseq[jp], rm_bcseq[ip] ) )
					lf = rm_bcseq[jp];
				else if( GU( rm_bcseq[jp], rm_bcseq[ip] ) )
					lf = 4;
				else if( GU( rm_bcseq[ip], rm_bcseq[jp] ) ) 
					lf = 5;
				else
					return( EFN_INFINITY );
				if( WC( rm_bcseq[j], rm_bcseq[i] ) )
					rt = rm_bcseq[j];
				else if( GU( rm_bcseq[j], rm_bcseq[i] ) )
					rt = 4;
				else if( GU( rm_bcseq[i], rm_bcseq[j] ) ) 
					rt = 5;
				else
					return( EFN_INFINITY );
				if( size == 3 ){ /* allow exp. for 3x2 loops */
					rval += efdp->e_eparam[2] +
	efdp->e_asint1x2[lf][rt][rm_bcseq[jp+1]][rm_bcseq[ip-1]][rm_bcseq[i+1]];
				}
			}
		}else if( lopsid == 0 && size <= 4 ){	/* 1x1, 2x2 loops */
			if( WC( rm_bcseq[i], rm_bcseq[j] ) )
				lf = rm_bcseq[i];
			else if( GU( rm_bcseq[i], rm_bcseq[j] ) ||
				GU( rm_bcseq[j], rm_bcseq[i] ) )
				lf = rm_bcseq[i] + 2;
			else
				return( EFN_INFINITY );

			if( WC( rm_bcseq[ip], rm_bcseq[jp] ) )
				rt = rm_bcseq[ip];
			else if( GU( rm_bcseq[ip], rm_bcseq[jp] ) ||
				GU( rm_bcseq[jp], rm_bcseq[ip] ) )
				rt = rm_bcseq[ip] + 2;
			else
				return( EFN_INFINITY );
			if( size == 2 ){
				rval += efdp->e_eparam[2] +
			    efdp->e_sint2[lf][rt][rm_bcseq[i+1]][rm_bcseq[j-1]];
			}else if( size == 4 ){
				rval += efdp->e_eparam[2] +
efdp->e_sint4[lf][rt][rm_bcseq[i+1]][rm_bcseq[j-1]][rm_bcseq[ip-1]][rm_bcseq[jp+1]];
			}
		}else{					/* 3x2 loops & up */
			if( ( size1==1 || size2==1 ) && efdp->e_eparam[15]==1 ){
				rval += efdp->e_eparam[2] +
		efdp->e_tstki[rm_bcseq[i]][rm_bcseq[j]][BCODE_A][BCODE_A] +
		efdp->e_tstki[rm_bcseq[jp]][rm_bcseq[ip]][BCODE_A][BCODE_A]+
					efdp->e_inter[size>30?30:size] +
					MIN(efdp->e_maxpen,
						lopsid*efdp->e_poppen[min4]);
			}else{
				rval += efdp->e_eparam[2] +
efdp->e_tstki[rm_bcseq[i]][rm_bcseq[j]][rm_bcseq[i+1]][rm_bcseq[j-1]] +
efdp->e_tstki[rm_bcseq[jp]][rm_bcseq[ip]][rm_bcseq[jp+1]][rm_bcseq[ip-1]] +
					efdp->e_inter[size>30?30:size] +
					MIN(efdp->e_maxpen,
						lopsid*efdp->e_poppen[min4]);
			}
		}
	}
	
	return( rval );
}

/* hairpin energy */
static	int	e_hploop( int i, int j )
{
	int	size, ccnt, k;
	int	key, lval, loginc;
	int	rval;

	if( i <= rm_l_base && j > rm_l_base )
		return( EFN_INFINITY );

	rval = 0;
	size = j - i - 1;

	/* poly c loop: */
	for( ccnt = 0, k = i + i; k < j; k++ ){
		if( rm_bcseq[k] == BCODE_C )
			ccnt++;
		else
			break;
	}
	if( ccnt == size ){
		rval = ( size == 3 ) ?
			efdp->e_eparam[13] :
			efdp->e_eparam[12]+size*efdp->e_eparam[11];
	}

	/* ggg loop */
	if( i > 1 && j <= rm_l_base ){
		if( rm_bcseq[i] == BCODE_G &&
			rm_bcseq[i-1] == BCODE_G &&
			rm_bcseq[i-2]==BCODE_G &&
			rm_bcseq[j] == BCODE_T )
		{
			rval += efdp->e_eparam[10];
		}
	}

	if( size <= 3 ){ /* loops of 1-3 */
		if( size == 3 ){
			key = rm_bcseq[i+size+1];
			for( k = size; k >= 0; k-- )
				key = ( key << 3 ) + rm_bcseq[i+k];
			for( lval = 0, k = 0; k < efdp->e_ntriloops; k++ ){
				if( efdp->e_triloops[k][0] == key ){
					lval = efdp->e_triloops[k][1];
					break;
				}
			}
		}else
			lval = 0;
		rval += efdp->e_hairpin[size] + efdp->e_eparam[3]
			+ e_aupen(i,j) + lval;
	}else if( size <= 30 ){ /* loops of 4-30 */
		if( size == 4 ){
			key = rm_bcseq[i+size+1];
			for( k = size; k >= 0; k-- )
				key = ( key << 3 ) + rm_bcseq[i+k];
			for( lval = 0, k = 0; k < efdp->e_ntloops; k++ ){
				if( efdp->e_tloops[k][0] == key ){
					lval = efdp->e_tloops[k][1];
					break;
				}
			}
		}else
			lval = 0;
		rval +=
	efdp->e_tstkh[rm_bcseq[i]][rm_bcseq[j]][rm_bcseq[i+1]][rm_bcseq[j-1]] +
			efdp->e_hairpin[size] + efdp->e_eparam[3] + lval;
	}else{	/* BIG (>30) loops */
		loginc = NINT( efdp->e_prelog*log( size / 30.0 ) );
		rval +=
	efdp->e_tstkh[rm_bcseq[i]][rm_bcseq[j]][rm_bcseq[i+1]][rm_bcseq[j-1]] +
			efdp->e_hairpin[30] + loginc + efdp->e_eparam[3];
	}

	return( rval );
}

/* dangling base energy */
static	int	e_dangle( int i, int j, int ip, int jp )
{
	int	rval;

	rval = efdp->e_dangle[ rm_bcseq[i] ][ rm_bcseq[j] ]
		[ rm_bcseq[ip] ][ jp ]; 
	return( rval );
}

static	int	e_aupen( int i, int j )
{
	static	int	pval[5][5] = {
		{ 0, 0, 0, 1, 0 },
		{ 0, 0, 0, 0, 0 },
		{ 0, 0, 0, 1, 0 },
		{ 1, 0, 1, 0, 0 },
		{ 0, 0, 0, 0, 0 } };
	int	rval = 0;

	rval = pval[ rm_bcseq[i] ][ rm_bcseq[j] ] * efdp->e_eparam[ 9 ];
	return( rval );
}

void	RM_initst( void )
{

	stkp = 0;
}

static	void	push( int a, int b, int c )
{

	stkp++;
	if( stkp >= STKSIZE ){
		RM_errormsg( 1, "push: stack overflow." );
		exit( 1 );
	}
	stk[stkp][0] = a;
	stk[stkp][1] = b;
	stk[stkp][2] = c;
}

static	int	pull( int *a, int *b, int *c )
{

	if( stkp == 0 )
		return( 1 );
	*a = stk[stkp][0];
	*b = stk[stkp][1];
	*c = stk[stkp][2];
	stkp--;
	return( 0 );
}
@


1.16
log
@removed unused arrays asin5[] and sint6[] which are only used
in efn2() to compute 2x3 and 3x3 loops.
@
text
@a40 1
static	int	asint3[ 6 ][ 6 ][ 5 ][ 5 ][ 5 ];
d42 32
a81 1
#define	EPARAM_SIZE	16
a82 1
#define	POPPEN_SIZE	4
a87 1
#define	MAXTLOOPS	100
a89 1
#define	MAXTRILOOPS	50
d96 1
d105 5
a109 5
static	int	gettloops( void );
static	int	gettriloops( void );
static	int	getmiscloop( void );
static	int	getdangle( void );
static	int	getibhloop( void );
d112 1
a112 1
static	int	getsymint( void );
d114 1
a114 1
static	int	getasymint( void );
d166 1
a166 1
	if( !gettloops() )
d169 1
a169 1
	if( !gettriloops() )
d172 1
a172 1
	if( !getmiscloop() )
d175 1
a175 1
	if( !getdangle() )
d178 1
a178 1
	if( !getibhloop() )
d181 1
a181 1
	if( !getstack( "stack.dat", stack, EFN_INFINITY ) )
d183 1
a183 1
	if( !stacktest( "stack.dat", stack ) )
d186 1
a186 1
	if( !getstack( "tstackh.dat", tstkh, 0 ) )
d188 2
a189 1
	if( !stacktest( "tstackh.dat", stack ) )
d191 1
d193 1
a193 1
	if( !getstack( "tstacki.dat", tstki, 0 ) )
d195 2
a196 1
	if( !stacktest( "tstacki.dat", stack ) )
d198 1
d200 1
a200 1
	if( !getsymint() )
d205 1
a205 1
	if( !getasymint() )
d211 1
a211 1
static	int	gettloops( void )
d213 1
a213 1
	char	fname[ 256 ];
d220 2
a221 2
	sprintf( fname, "%s/%s", rm_efndatadir, "tloop.dat" );
	if( ( fp = fopen( fname, "r" ) ) == NULL ){
d223 1
a223 1
			fname );
d232 3
a234 2
				tloops[ t ][ 0 ] = packloop( loop );
				tloops[ t ][ 1 ] = NINT( 100.0 * energy );
d246 1
a246 1
		n_tloops = MAXTLOOPS;
d248 1
a248 1
		n_tloops = t;
d253 1
a253 1
static	int	gettriloops( void )
d255 1
a255 1
	char	fname[ 256 ];
d262 2
a263 2
	sprintf( fname, "%s/%s", rm_efndatadir, "triloop.dat" );
	if( ( fp = fopen( fname, "r" ) ) == NULL ){
d265 1
a265 1
			fname );
d274 2
a275 2
				triloops[ t ][ 0 ] = packloop( loop );
				triloops[ t ][ 1 ] = NINT( 100.0 * energy );
d287 1
a287 1
		n_triloops = MAXTRILOOPS;
d289 1
a289 1
		n_triloops = t;
d294 1
a294 1
static	int	getmiscloop( void )
d296 1
a296 1
	char	fname[ 256 ];
d302 2
a303 2
	sprintf( fname, "%s/%s", rm_efndatadir, "miscloop.dat" );
	if( ( fp = fopen( fname, "r" ) ) == NULL ){
d305 1
a305 1
			fname );
d313 2
a314 2
		sscanf( line, "%f", &prelog );
		prelog *= 10.0;
d324 1
a324 1
		maxpen = NINT( 100.0*fv1 );
d334 5
a338 5
		poppen[ 0 ] = 0;
		poppen[ 1 ] = NINT( 100.0*fv1 );
		poppen[ 2 ] = NINT( 100.0*fv2 );
		poppen[ 3 ] = NINT( 100.0*fv3 );
		poppen[ 4 ] = NINT( 100.0*fv4 );
d345 6
a350 6
	eparam[ 0 ] = 0;
	eparam[ 1 ] = 0;
	eparam[ 2 ] = 0;
	eparam[ 3 ] = 0;
	eparam[ 6 ] = 30;
	eparam[ 7 ] = 30;
d355 3
a357 3
		eparam[ 4 ] = NINT( 100.0*fv1 );
		eparam[ 5 ] = NINT( 100.0*fv2 );
		eparam[ 8 ] = NINT( 100.0*fv3 );
d366 1
a366 1
			eparam[ i ] = 0;
d375 1
a375 1
			eparam[ 9 ] = NINT( 100.0*fv1 );
d386 1
a386 1
			eparam[ 10 ] = NINT( 100.0*fv1 );
d396 1
a396 1
			eparam[ 11 ] = NINT( 100.0*fv1 );
d406 1
a406 1
			eparam[ 12 ] = NINT( 100.0*fv1 );
d417 1
a417 1
			eparam[ 13 ] = NINT( 100.0*fv1 );
d428 1
a428 1
			eparam[ 14 ] = NINT( 100.0*fv1 );
d438 1
a438 1
			sscanf( line, "%d", &eparam[ 15 ] );
d452 1
a452 1
static	int	getdangle( void )
d454 1
a454 1
	char	fname[ 256 ];
d462 2
a463 2
	sprintf( fname, "%s/%s", rm_efndatadir, "dangle.dat" );
	if( ( fp = fopen( fname, "r" ) ) == NULL ){
d465 1
a465 1
			fname );
d492 1
a492 1
					dangle[v1][v2][v3][v4] = 
d505 1
a505 1
static	int	getibhloop( void )
d507 1
a507 1
	char	fname[ 256 ];
d514 2
a515 2
	sprintf( fname, "%s/%s", rm_efndatadir, "loop.dat" );
	if( ( fp = fopen( fname, "r" ) ) == NULL ){
d517 1
a517 1
			fname );
d535 1
a535 1
				inter[ i ] = EFN_INFINITY;
d537 2
a538 1
				inter[ i ] = NINT( 100.0*atof( fields[ 1 ] ) );
d540 1
a540 1
				bulge[ i ] = EFN_INFINITY;
d542 2
a543 1
				bulge[ i ] = NINT( 100.0*atof( fields[ 2 ] ) );
d545 1
a545 1
				hairpin[ i ] = EFN_INFINITY;
d547 2
a548 1
				hairpin[i] = NINT( 100.0*atof( fields[ 3 ] ) );
d562 1
a562 1
	char	fname[ 256 ];
d570 4
a573 4
	sprintf( fname, "%s/%s", rm_efndatadir, sfname );
	if( ( fp = fopen( fname, "r" ) ) == NULL ){
		sprintf( emsg, "getibhloop: can't read stack file '%s'.",
			sfname );
d592 1
a592 1
				fname );
d644 1
a644 1
static	int	getsymint( void )
d646 1
a646 1
	char	fname[ 256 ];
d655 2
a656 2
	sprintf( fname, "%s/%s", rm_efndatadir, "sint2.dat" );
	if( ( fp = fopen( fname, "r" ) ) == NULL ){
d658 1
a658 1
			fname );
d667 1
a667 1
			fname );
d677 1
a677 1
				fname );
d689 1
a689 1
				sint2[v1][v2][v3][v4] = lval;
d700 2
a701 1
					worst=MAX(worst, sint2[v1][v2][v3][v4]);
d704 2
a705 2
				sint2[v1][v2][v3][ 4] = worst;
				sint2[v1][v2][ 4][v3] = worst;
d710 2
a711 2
	sprintf( fname, "%s/%s", rm_efndatadir, "sint4.dat" );
	if( ( fp = fopen( fname, "r" ) ) == NULL ){
d713 1
a713 1
			fname );
d721 1
a721 1
			fname );
d732 1
a732 1
			fname );
d745 1
a745 1
			    sint4[v1][v2][v3][v4][v5][v6]= lval;
d760 1
a760 1
				    sint4[v1][v2][v3][v4][v5][v6] );
d768 4
a771 4
			    sint4[v1][v2][v3][v4][v5][ 4] = worst;
			    sint4[v1][v2][v3][v4][ 4][v5] = worst;
			    sint4[v1][v2][v3][ 4][v4][v5] = worst;
			    sint4[v1][v2][ 4][v3][v4][v5] = worst;
d795 3
a797 1
			if( sint2[v1][v2][v3][v4] != sint2[v2a][v1a][v4][v3] ){
d801 2
a802 2
				v1, v2, v3, v4, sint2[v1][v2][v3][v4],
				v2a, v1a, v4, v3, sint2[v2a][v1a][v4][v3] );
d818 3
a820 2
				if(sint4[v1][v2][v3][v4][v5][v6] !=
				    sint4[v2a][v1a][v6][v5][v4][v3] ){
d825 1
a825 1
					sint4[v1][v2][v3][v4][v5][v6],
d827 1
a827 1
					sint4[v2a][v1a][v6][v5][v4][v3] );
d839 1
a839 1
static	int	getasymint( void )
d841 1
a841 1
	char	fname[ 256 ];
d850 2
a851 2
	sprintf( fname, "%s/%s", rm_efndatadir, "asint1x2.dat" );
	if( ( fp = fopen( fname, "r" ) ) == NULL ){
d854 1
a854 1
			fname );
d874 1
a874 1
			    asint3[v1][v2][v3][v4][v5] = EFN_INFINITY;
d897 1
a897 1
			asint3[v1][v2][v3][v4][v5] = lval;
d960 3
a962 3
	dumpstack( fp, "stack", stack );
	dumpstack( fp, "tstackh", tstkh );
	dumpstack( fp, "tstacki", tstki );
d996 2
a997 1
					dval = 0.01*dangle[v1][v2][v3][v4];
d1017 1
a1017 1
		if( inter[ i ] == EFN_INFINITY )
d1020 2
a1021 2
			fprintf( fp, " %5.2f", 0.01*inter[ i ] );
		if( bulge[ i ] == EFN_INFINITY )
d1024 2
a1025 2
			fprintf( fp, " %5.2f", 0.01*bulge[ i ] );
		if( hairpin[ i ] == EFN_INFINITY )
d1028 1
a1028 1
			fprintf( fp, " %5.2f", 0.01*hairpin[ i ] );
d1086 1
a1086 1
						.01*sint2[v1][v2][v3][v4] );
d1107 1
a1107 1
					.01*sint4[v1][v2][x1][x2][y1][y2] );
d1164 1
a1164 1
				e += eparam[5];
d1170 1
a1170 1
				e += eparam[5];
d1177 1
a1177 1
					+ eparam[5];
d1184 1
a1184 1
					+ eparam[5];
d1240 1
a1240 1
			e += eparam[8];
d1278 2
a1279 1
				e += eparam[4] + eparam[8] + e_aupen( i, j );
d1290 1
a1290 1
							eparam[5];
d1298 1
a1298 1
						eparam[5];
d1310 1
a1310 1
							eparam[5];
d1318 1
a1318 1
						eparam[5];
d1336 3
a1338 2
	rval = stack[rm_bcseq[i]][rm_bcseq[j]][rm_bcseq[i+1]][rm_bcseq[j-1]] +
		eparam[0];
a1346 1
	int	a, b;
d1362 2
a1363 2
		    stack[rm_bcseq[i]][rm_bcseq[j]][rm_bcseq[ip]][rm_bcseq[jp]]
			    + bulge[size] + eparam[1];
d1367 3
a1369 2
				loginc = NINT( prelog*log( size / 30.0 ) );
				rval += bulge[30] + loginc + eparam[1];
d1371 1
a1371 1
				rval += bulge[size] + eparam[1];
d1376 2
a1377 2
			loginc = NINT( prelog*log( size / 30. ) );
			if( ( size1 == 1 || size2 == 1 ) && eparam[ 15 ] == 1 ){
d1379 6
a1384 4
			tstki[rm_bcseq[i]][rm_bcseq[j]][BCODE_A][BCODE_A] +
			tstki[rm_bcseq[jp]][rm_bcseq[ip]][BCODE_A][BCODE_A]+
					inter[30] + loginc + eparam[2] +
					MIN( maxpen, lopsid*poppen[min4] );
d1387 6
a1392 4
	tstki[rm_bcseq[i]][rm_bcseq[j]][rm_bcseq[i+1]][rm_bcseq[j-1]] +
	tstki[rm_bcseq[jp]][rm_bcseq[ip]][rm_bcseq[jp+1]][rm_bcseq[ip-1]] +
					inter[30] + loginc + eparam[2] +
					MIN( maxpen, lopsid*poppen[min4] );
d1397 1
a1397 1
					a = rm_bcseq[i];
d1399 1
a1399 1
					a = 4;
d1401 3
a1403 1
					a = 5;
d1405 1
a1405 1
					b = rm_bcseq[ip];
d1407 1
a1407 1
					b = 4;
d1409 3
a1411 1
					b = 5;
d1413 2
a1414 2
					rval += eparam[2] +
		asint3[a][b][rm_bcseq[i+1]][rm_bcseq[j-1]][rm_bcseq[jp+1]];
d1418 1
a1418 1
					a = rm_bcseq[jp];
d1420 1
a1420 1
					a = 4;
d1422 3
a1424 1
					a = 5;
d1426 1
a1426 1
					b = rm_bcseq[j];
d1428 1
a1428 1
					b = 4;
d1430 3
a1432 1
					b = 5;
d1434 2
a1435 2
					rval += eparam[2] +
		asint3[a][b][rm_bcseq[jp+1]][rm_bcseq[ip-1]][rm_bcseq[i+1]];
d1455 2
a1456 2
				rval += eparam[2] +
				    sint2[lf][rt][rm_bcseq[i+1]][rm_bcseq[j-1]];
d1458 2
a1459 2
				rval += eparam[2] +
sint4[lf][rt][rm_bcseq[i+1]][rm_bcseq[j-1]][rm_bcseq[ip-1]][rm_bcseq[jp+1]];
d1462 7
a1468 6
			if( ( size1 == 1 || size2 == 1 ) && eparam[15] == 1 ){
				rval += eparam[2] +
			tstki[rm_bcseq[i]][rm_bcseq[j]][BCODE_A][BCODE_A] +
			tstki[rm_bcseq[jp]][rm_bcseq[ip]][BCODE_A][BCODE_A]+
					inter[size>30?30:size] +
					MIN( maxpen, lopsid*poppen[min4] );
d1470 6
a1475 5
				rval += eparam[2] +
	tstki[rm_bcseq[i]][rm_bcseq[j]][rm_bcseq[i+1]][rm_bcseq[j-1]] +
	tstki[rm_bcseq[jp]][rm_bcseq[ip]][rm_bcseq[jp+1]][rm_bcseq[ip-1]] +
					inter[size>30?30:size] +
					MIN( maxpen, lopsid*poppen[min4] );
d1504 3
a1506 1
		rval = ( size == 3 ) ? eparam[13] : eparam[12]+size*eparam[11];
d1516 1
a1516 1
			rval += eparam[10];
d1525 3
a1527 3
			for( lval = 0, k = 0; k < n_triloops; k++ ){
				if( triloops[k][0] == key ){
					lval = triloops[k][1];
d1533 2
a1534 1
		rval += hairpin[size] + eparam[3] + e_aupen(i,j) + lval;
d1540 3
a1542 3
			for( lval = 0, k = 0; k < n_tloops; k++ ){
				if( tloops[k][0] == key ){
					lval = tloops[k][1];
d1549 2
a1550 2
		tstkh[rm_bcseq[i]][rm_bcseq[j]][rm_bcseq[i+1]][rm_bcseq[j-1]] +
			hairpin[size] + eparam[3] + lval;
d1552 1
a1552 1
		loginc = NINT( prelog*log( size / 30.0 ) );
d1554 2
a1555 2
		tstkh[rm_bcseq[i]][rm_bcseq[j]][rm_bcseq[i+1]][rm_bcseq[j-1]] +
			hairpin[30] + loginc + eparam[3];
d1566 2
a1567 1
	rval = dangle[ rm_bcseq[i] ][ rm_bcseq[j] ][ rm_bcseq[ip] ][ jp ]; 
d1581 1
a1581 1
	rval = pval[ rm_bcseq[i] ][ rm_bcseq[j] ] * eparam[ 9 ];
@


1.15
log
@fixed bug in efn.c that had a '=' instead of a '==' in a while
loop that resulted in the BP table being corrupted, producing a
pknot, causing an infinite recursion! Ugh.  Occurred only for the
1st hairpin and then only if the first hairpin did not cover the
entire sequence.
@
text
@a41 1
static	int	asint5[ 6 ][ 6 ][ 5 ][ 5 ][ 5 ][ 5 ][ 5 ];
a57 1
static	int	sint6[ 6 ][ 6 ][ 25 ][ 5 ][ 5 ][ 5 ][ 5 ];
@


1.14
log
@converted RM_efn() from interated function to recursive.  Much easier
to understand.
@
text
@d1149 1
a1149 1
			while( rm_basepr[i]= UNDEF && rm_basepr[i+1]==UNDEF ){
@


1.13
log
@about to reorder RM_efn() to straighten the loop and then make it
recursive.
@
text
@d105 1
a105 1
static	void	initst( void );
d1114 1
a1114 1
int	RM_efn( int ii, int ji, int xopen )
d1116 2
a1117 2
	int	e, eold;
	int	i, ip, is, j, jp, js, open;
d1121 49
a1169 52
	eold = 0;

	initst();
	push( ii, ji, xopen );

L100 : ;
	if( pull( &i, &j, &open ) )
		return( e );

	if( rm_basepr[i] == j )
		goto L300;
	if( open == 0 ){
		while( rm_basepr[i] == UNDEF && rm_basepr[i+1] == UNDEF ){
			i++;
			e += eparam[5];
			if( i >= j-1 )
				goto L100;
		}
		while( rm_basepr[j] == UNDEF && rm_basepr[j-1] == UNDEF ){
			j--;
			e += eparam[5];
			if( i >= j-1 )
				goto L100;
		}

		if( rm_basepr[i] == UNDEF && rm_basepr[i+1] > i+1 ){
			e += MIN( 0, e_dangle( rm_basepr[i+1], i+1, i, 1 ) ) +
				eparam[5];
			i++;
		}
		if( rm_basepr[j] == UNDEF && rm_basepr[j-1] != UNDEF &&
			rm_basepr[j-1] < j-1 )
		{
			e += MIN( 0, e_dangle( j-1,rm_basepr[j-1], j, 0 ) ) +
				eparam[5];
			j--;
		}
	}else{
		while( rm_basepr[i] == UNDEF && rm_basepr[i+1] == UNDEF ){
			i++;
			if( i >= j-1 )
				goto L100;
		}
		while( rm_basepr[j] == UNDEF && rm_basepr[j-1] == UNDEF ){
			j--;
			if( i >= j-1 )
				goto L100;
		}

		if( rm_basepr[i] == UNDEF && rm_basepr[i+1] > i+1 ){
			e += MIN( 0, e_dangle( rm_basepr[i+1], i+1, i, 1 ) );
			i++;
a1170 6
		if( rm_basepr[j] == UNDEF && rm_basepr[j-1] != UNDEF &&
			rm_basepr[j-1] < j-1 )
		{
			e += MIN( 0, e_dangle( j-1, rm_basepr[j-1], j, 0 ) );
			j--;
		}
d1184 2
a1185 2
			push( i, k, open );
			push( k+1, j, open );
d1187 2
a1188 2
			push( i, k+1, open );
			push( k+2, j, open );
d1192 2
a1193 2
			push( i, k+1, open );
			push( k+2, j, open );
d1195 2
a1196 2
			push( i, k, open );
			push( k+1, j, open );
d1198 28
a1225 30
		goto L100;
	}

L300 : ;
	if( !open )
		e += eparam[8];
	e += e_aupen( i, j );

L310 : ;

	open = 0;
	eold = e;

	if( rm_basepr[i+1] == j-1 ){
		e += e_stack( i, j );
		i++;
		j--;
		goto L310;
	}

	for( sum = 0, k = i+1; k < j; ){
		if( rm_basepr[k] > k ){
			sum++;
			ip = k;
			k = rm_basepr[k] + 1;
			jp = k - 1;
			if( k > j ){
				sprintf( emsg, "RM_efn: ERROR: %d\n", 51 );
				RM_errormsg( 0, emsg );
				return( EFN_INFINITY );
a1226 3
		}else if( rm_basepr[k] == UNDEF )
			k++;
	}
d1228 54
a1281 19

	if( sum == 0 ){	/* hairpin */
		e += e_hploop( i, j );
		goto L100;
	}else if( sum == 1 ){ /* internal or bulge loop */
		e += e_ibloop( i, j, ip, jp );
		i = ip;
		j = jp;
		goto L310;
	}else{
		is = i + 1;
		js = j - 1;
		e += eparam[4] + eparam[8] + e_aupen( i, j );
		if( rm_basepr[i+1] == UNDEF && rm_basepr[i+2] != UNDEF ){
			if( e_dangle(i,j,i+1,0) <=
				e_dangle(rm_basepr[i+2],i+2,i+1,1) )
			{
				is = i + 2;
				e += MIN( 0, e_dangle( i,j,i+1,0 )) + eparam[5];
a1283 18
		if( rm_basepr[i+1] == UNDEF && rm_basepr[i+2] == UNDEF ){
			is = i + 2;
			e += MIN( 0, e_dangle( i,j,i+1,0 ) ) + eparam[5];
		}
		if( rm_basepr[j-1] == UNDEF && rm_basepr[j-2] != UNDEF ){
			if( e_dangle(i,j,j-1,1) <=
				e_dangle(j-2,rm_basepr[j-2],j-1,0) )
			{
				js = j - 2;
				e += MIN( 0, e_dangle( i,j,j-1,1 )) + eparam[5];
			}
		}
		if( rm_basepr[j-1] == UNDEF && rm_basepr[j-2] == UNDEF ){
			js = j - 2;
			e += MIN( 0, e_dangle( i,j,j-1,1 ) ) + eparam[5];
		}
		push( is, js, 0 );
		goto L100;
d1285 1
d1526 1
a1526 1
static	void	initst( void )
@


1.12
log
@converted all headers from K&R to ANSI.
@
text
@d1116 1
a1116 1
	int	e, eold, em;
a1118 1
	int	predangle, postdangle;
a1129 5
/*
fprintf( stderr, "RM_efn: New segment: (%5d,%5d), open = %d, Energy = %7d\n",
	rm_hstnum[i], rm_hstnum[j], open, e );
*/

a1194 6

/*
fprintf( stderr, "RM_efn: bifuration.1: (%5d.%5d) (%5d %5d)\n",
	rm_hstnum[i], rm_hstnum[k], rm_hstnum[k+1], rm_hstnum[j] );
*/

a1197 6

/*
fprintf( stderr, "RM_efn: bifuration.2: (%5d.%5d) (%5d %5d)\n",
	rm_hstnum[i], rm_hstnum[k+1], rm_hstnum[k+2], rm_hstnum[j] );
*/

a1202 6

/*
fprintf( stderr, "RM_efn: bifuration.3: (%5d.%5d) (%5d %5d)\n",
	rm_hstnum[i], rm_hstnum[k+1], rm_hstnum[k+2], rm_hstnum[j] );
*/

a1205 6

/*
fprintf( stderr, "RM_efn: bifuration.4: (%5d.%5d) (%5d %5d)\n",
	rm_hstnum[i], rm_hstnum[k], rm_hstnum[k+1], rm_hstnum[j] );
*/

d1216 1
a1217 7

/*
fprintf( stderr,
	"RM_efn: base pair: %c%c, (%5d.%5d), Energy = %7d, E-inc = %6d\n",
	N2B( rm_bcseq[i] ), N2B( rm_bcseq[j] ), i+1, j+1, e, e - eold );
*/
	
a1244 6

/*
fprintf( stderr, "RM_efn: hairpin loop closed by (%5d.%5d), Energy = %7d\n",
	rm_hstnum[i], rm_hstnum[j], e_hploop( i, j ) );
*/

a1251 26
/*
		em = eparam[4] + eparam[8] + e_aupen( i, j );
		for( k = i+1; k < j; k++ ){
			if( rm_basepr[k] == UNDEF ){
				if( rm_basepr[k-1] != UNDEF )
					predangle = MIN( 0,
					    e_dangle(k-1,rm_basepr[k-1],k,0) );
				else
					predangle = 0;
				if( rm_basepr[k+1] != UNDEF )
					postdangle = MIN( 0,
					    e_dangle(rm_basepr[k+1],k+1,k,1) );
				else
					postdangle = 0;
				em += eparam[5] + MIN( predangle, postdangle );
			}else{
				em += eparam[8] + e_aupen( k, rm_basepr[k] );
				k = rm_basepr[k];
			}
		} 

fprintf( stderr,
	"RM_efn: multi-branch loop closed by (%5d.%5d), Energy = %7d\n",
	rm_hstnum[i], rm_hstnum[j], em );
*/

@


1.11
log
@commented out debug code that computed the energy of the
bifurcation and then ignored it.
@
text
@d76 1
a76 1
char	*getenv();
d78 30
a107 32
int	RM_getefndata();
static	int	gettloops();
static	int	gettriloops();
static	int	getmiscloop();
static	int	getdangle();
static	int	getibhloop();
static	int	getstack();
static	int	getsymint();
static	int	getasymint();

static	int	stacktest();
static	int	symtest();

static	void	dumpdata();
static	void	dumpdangle();
static	void	dumpibhloop();
static	void	dumpstack();
static	void	dumpsint();

static	int	packloop();
static	int	skipto();

int	efn();
static	int	e_stack();
static	int	e_ibloop();
static	int	e_hploop();
static	int	e_dangle();
static	int	e_aupen();

static	void	initst();
static	void	push();
static	int	pull();
d109 1
a109 2
int	RM_allocefnds( size )
int	size;
d131 1
a131 1
int	RM_getefndata()
d181 1
a181 1
static	int	gettloops()
d222 1
a222 1
static	int	gettriloops()
d263 1
a263 1
static	int	getmiscloop()
d421 1
a421 1
static	int	getdangle()
d474 1
a474 1
static	int	getibhloop()
d526 1
a526 4
static	int	getstack( sfname, stack, defval ) 
char	sfname[];
int	stack[5][5][5][5];
int	defval;
d585 1
a585 3
static	int	stacktest( sname, stack )
char	sname[];
int	stack[5][5][5][5];
d610 1
a610 1
static	int	getsymint()
d749 1
a749 1
static	int	symtest()
d801 1
a801 1
static	int	getasymint()
d872 1
a872 2
static	int	packloop( loop )
char	loop[];
d907 1
a907 5
static	int	skipto( fp, str, s_line, line )
FILE	*fp;
char	str[];
long	s_line;
char	line[];
d917 1
a917 2
void	RM_dumpefndata( fp )
FILE	*fp;
d928 1
a928 2
static	void	dumpdangle( fp )
FILE	*fp;
d971 1
a971 2
static	void	dumpibhloop( fp )
FILE	*fp;
d994 1
a994 4
static	void	dumpstack( fp, sname, stack )
FILE	*fp;
char	sname[];
int	stack[5][5][5][5];
d1036 1
a1036 2
static	void	dumpsint( fp )
FILE	*fp;
d1079 1
a1079 1
int	RM_knotted()
d1114 1
a1114 4
int	RM_efn( ii, ji, xopen )
int	ii;
int	ji;
int	xopen;
d1117 1
a1117 1
	int	i, ip, is, j, jp, js, open, junk;
d1128 1
a1128 1
	if( pull( &i, &j, &open, &junk ) )
d1353 1
a1353 2
static	int	e_stack( i, j )
int	i, j;
d1366 1
a1366 5
static	int	e_ibloop( i, j, ip, jp )
int	i;
int	j;
int	ip;
int	jp;
d1493 1
a1493 3
static	int	e_hploop( i, j )
int	i;
int	j;
d1568 1
a1568 5
static	int	e_dangle( i, j, ip, jp )
int	i;
int	j;
int	ip;
int	jp;
d1576 1
a1576 2
static	int	e_aupen( i, j )
int	i, j;
d1590 1
a1590 1
static	void	initst()
d1596 1
a1596 4
static	void	push( a, b, c )
int	a;
int	b;
int	c;
d1609 1
a1609 4
static	int	pull( a, b, c )
int	*a;
int	*b;
int	*c;
@


1.10
log
@fixed a bug in RM_efn() which control multi-armed loops.
@
text
@d1317 1
a1337 1
/*
@


1.9
log
@had split() that was not freeing its memory
@
text
@d1230 1
a1230 1
		}else if( rm_basepr[k+1] == UNDEF ){
d1243 1
a1243 1
			push( k+1, j, open );
@


1.8
log
@commented out debug output.
@
text
@d483 1
a483 1
	int	i;
d505 1
a505 1
			split( line, fields, " \t\n" );
d518 2
@


1.7
log
@a few core dumps involving [] vs *.  (I still don't understand this.)
but it works!
@
text
@d1223 1
d1226 1
d1232 1
d1235 1
d1243 1
d1246 1
d1252 1
d1255 1
d1335 1
d1339 1
@


1.6
log
@looks like its ready to try.
@
text
@a23 1
#define	INFINITY	16000
d34 4
a38 5
int	rm_l_base;
int	*rm_hstnum;
int	*rm_bcseq;
int	*rm_basepr;

d111 23
d138 5
d158 1
a158 1
	if( !getstack( "stack.dat", stack, INFINITY ) )
d507 1
a507 1
				inter[ i ] = INFINITY;
d511 1
a511 1
				bulge[ i ] = INFINITY;
d515 1
a515 1
				hairpin[ i ] = INFINITY;
d574 1
a574 1
					stack[v1][v2][v3][v4] = INFINITY;
d842 1
a842 1
			    asint3[v1][v2][v3][v4][v5] = INFINITY;
d992 1
a992 1
		if( inter[ i ] == INFINITY )
d996 1
a996 1
		if( bulge[ i ] == INFINITY )
d1000 1
a1000 1
		if( hairpin[ i ] == INFINITY )
d1040 1
a1040 1
					if( dval == INFINITY )
d1152 1
d1155 1
d1217 1
a1217 1
			return( INFINITY );
d1261 1
d1265 1
d1285 1
a1285 1
				return( INFINITY );
d1295 1
d1298 1
d1370 1
a1370 1
		return( INFINITY );
d1391 1
a1391 1
		return( INFINITY );
d1472 1
a1472 1
				return( INFINITY );
d1480 1
a1480 1
				return( INFINITY );
d1518 1
a1518 1
		return( INFINITY );
@


1.5
log
@about to promote the static func knotted in efn_drv.c to RM_knotted
and move it here.
@
text
@d1070 35
@


1.4
log
@moved the basic data: rm_bcseq (orig numseq), rm_basepr, rm_hstnum from
efn to efn_drv.
@
text
@d103 5
a107 4
static	int	erg2();
static	int	erg3();
static	int	erg4();
static	int	erg6();
a108 2
static	int	au_pen();

a112 1

d852 51
a902 1
static	void	dumpdata( fp )
a1069 50
static	int	packloop( loop )
char	loop[];
{
	char	*lp;
	int	num;

	for( lp = loop, num = 0; *lp; lp++ ){
		switch( *lp ){
		case 'A' :
		case 'a' :
			num = ( num << 3 ) + 1;
			break;
		case 'C' :
		case 'c' :
			num = ( num << 3 ) + 2;
			break;
		case 'G' :
		case 'g' :
			num = ( num << 3 ) + 3;
			break;
		case 'T' :
		case 't' :
		case 'U' :
		case 'u' :
			num = ( num << 3 ) + 4;
			break;
		default :
			sprintf( emsg,
				"packloop: illegal char %c (%d)", *lp, *lp );
			RM_errormsg( 1, emsg );
			exit( 1 );
		}
	}
	return( num );
}

static	int	skipto( fp, str, s_line, line )
FILE	*fp;
char	str[];
long	s_line;
char	line[];
{

	while( fgets( line, s_line, fp ) ){
		if( strstr( line, str ) )
			return( 1 );
	}
	return( 0 );
}

d1111 1
a1111 1
			e += MIN( 0, erg6( rm_basepr[i+1], i+1, i, 1 ) ) +
d1118 1
a1118 1
			e += MIN( 0, erg6( j-1,rm_basepr[j-1], j, 0 ) ) +
d1135 1
a1135 1
			e += MIN( 0, erg6( rm_basepr[i+1], i+1, i, 1 ) );
d1141 1
a1141 1
			e += MIN( 0, erg6( j-1, rm_basepr[j-1], j, 0 ) );
d1170 3
a1172 1
		}else if(erg6( k,i,k+1,0 ) <= erg6( rm_basepr[k+2],k+2,k+1,1 )){
d1193 1
a1193 1
	e += au_pen( i, j );
d1205 1
a1205 1
		e += erg2( i, j );
d1228 1
a1228 1
		e += erg4( i, j );
d1231 1
a1231 1
	rm_hstnum[i], rm_hstnum[j], erg4( i, j ) );
d1235 1
a1235 1
		e += erg3( i, j, ip, jp );
d1240 1
a1240 1
		em = eparam[4] + eparam[8] + au_pen( i, j );
d1245 1
a1245 1
						erg6(k-1,rm_basepr[k-1],k,0) );
d1250 1
a1250 1
						erg6(rm_basepr[k+1],k+1,k,1) );
d1255 1
a1255 1
				em += eparam[8] + au_pen( k, rm_basepr[k] );
d1266 1
a1266 1
		e += eparam[4] + eparam[8] + au_pen( i, j );
d1268 3
a1270 1
			if( erg6(i,j,i+1,0) <= erg6(rm_basepr[i+2],i+2,i+1,1) ){
d1272 1
a1272 1
				e += MIN( 0, erg6( i,j,i+1,0 ) ) + eparam[5];
d1277 1
a1277 1
			e += MIN( 0, erg6( i,j,i+1,0 ) ) + eparam[5];
d1280 3
a1282 1
			if( erg6(i,j,j-1,1) <= erg6(j-2,rm_basepr[j-2],j-1,0) ){
d1284 1
a1284 1
				e += MIN( 0, erg6( i,j,j-1,1 ) ) + eparam[5];
d1289 1
a1289 1
			e += MIN( 0, erg6( i,j,j-1,1 ) ) + eparam[5];
d1297 1
a1297 1
static	int	erg2( i, j )
d1311 1
a1311 1
static	int	erg3( i, j, ip, jp )
d1338 1
a1338 1
			rval += au_pen( i, j ) + au_pen( ip, jp );
d1442 1
a1442 1
static	int	erg4( i, j )
d1491 1
a1491 1
		rval += hairpin[size] + eparam[3] + au_pen(i,j) + lval;
d1519 1
a1519 1
static	int	erg6( i, j, ip, jp )
d1531 1
a1531 1
static	int	au_pen( i, j )
d1534 1
a1534 1
	static	int	inc2[5][5] = {
d1542 1
a1542 1
	rval = inc2[ rm_bcseq[i] ][ rm_bcseq[j] ] * eparam[ 9 ];
@


1.3
log
@more changes involved in integration: this time moving the source
of where to find the data to rm_efndatadir and saving its status
in rm_efndataok.
@
text
@d36 4
a39 6
int	n_bases;
int	l_base;
int	*hstnum;
int	*force;
int	*numseq;
int	*basepr;
d1094 1
a1094 1
	hstnum[i], hstnum[j], open, e );
d1096 1
a1096 1
	if( basepr[i] == j )
d1099 1
a1099 1
		while( basepr[i] == UNDEF && basepr[i+1] == UNDEF ){
d1105 1
a1105 1
		while( basepr[j] == UNDEF && basepr[j-1] == UNDEF ){
d1112 2
a1113 2
		if( basepr[i] == UNDEF && basepr[i+1] > i+1 ){
			e += MIN( 0, erg6( basepr[i+1], i+1, i, 1 ) ) +
d1117 2
a1118 2
		if( basepr[j] == UNDEF && basepr[j-1] != UNDEF &&
			basepr[j-1] < j-1 )
d1120 1
a1120 1
			e += MIN( 0, erg6( j-1,basepr[j-1], j, 0 ) ) +
d1125 1
a1125 1
		while( basepr[i] == UNDEF && basepr[i+1] == UNDEF ){
d1130 1
a1130 1
		while( basepr[j] == UNDEF && basepr[j-1] == UNDEF ){
d1136 2
a1137 2
		if( basepr[i] == UNDEF && basepr[i+1] > i+1 ){
			e += MIN( 0, erg6( basepr[i+1], i+1, i, 1 ) );
d1140 2
a1141 2
		if( basepr[j] == UNDEF && basepr[j-1] != UNDEF &&
			basepr[j-1] < j-1 )
d1143 1
a1143 1
			e += MIN( 0, erg6( j-1, basepr[j-1], j, 0 ) );
d1148 3
a1150 3
	if( basepr[i] != j ){
		k = basepr[i];
		kp = basepr[j];
d1153 2
a1154 1
				hstnum[i], hstnum[k], hstnum[kp], hstnum[j] );
d1158 1
a1158 1
		if( basepr[k+1] != UNDEF ){
d1163 1
a1163 1
	hstnum[i], hstnum[k], hstnum[k+1], hstnum[j] );
d1165 1
a1165 1
		}else if( basepr[k+1] == UNDEF ){
d1170 1
a1170 1
	hstnum[i], hstnum[k+1], hstnum[k+2], hstnum[j] );
d1172 1
a1172 1
		}else if( erg6( k,i,k+1,0 ) <= erg6( basepr[k+2],k+2,k+1,1 ) ){
d1177 1
a1177 1
	hstnum[i], hstnum[k+1], hstnum[k+2], hstnum[j] );
d1184 1
a1184 1
	hstnum[i], hstnum[k], hstnum[k+1], hstnum[j] );
d1200 1
a1200 1
	N2B( numseq[i] ), N2B( numseq[j] ), i+1, j+1, e, e - eold );
d1204 1
a1204 1
	if( basepr[i+1] == j-1 ){
d1212 1
a1212 1
		if( basepr[k] > k ){
d1215 1
a1215 1
			k = basepr[k] + 1;
d1222 1
a1222 1
		}else if( basepr[k] == UNDEF )
d1231 1
a1231 1
	hstnum[i], hstnum[j], erg4( i, j ) );
d1242 2
a1243 2
			if( basepr[k] == UNDEF ){
				if( basepr[k-1] != UNDEF )
d1245 1
a1245 1
						erg6( k-1,basepr[k-1],k,0 ) );
d1248 1
a1248 1
				if( basepr[k+1] != UNDEF )
d1250 1
a1250 1
						erg6( basepr[k+1],k+1,k,1 ) );
d1255 2
a1256 2
				em += eparam[8] + au_pen( k, basepr[k] );
				k = basepr[k];
d1262 1
a1262 1
	hstnum[i], hstnum[j], em );
d1267 2
a1268 2
		if( basepr[i+1] == UNDEF && basepr[i+2] != UNDEF ){
			if( erg6(i,j,i+1,0) <= erg6(basepr[i+2],i+2,i+1,1) ){
d1273 1
a1273 1
		if( basepr[i+1] == UNDEF && basepr[i+2] == UNDEF ){
d1277 2
a1278 2
		if( basepr[j-1] == UNDEF && basepr[j-2] != UNDEF ){
			if( erg6(i,j,j-1,1) <= erg6(j-2,basepr[j-2],j-1,0) ){
d1283 1
a1283 1
		if( basepr[j-1] == UNDEF && basepr[j-2] == UNDEF ){
d1298 1
a1298 1
	if( i == l_base || j == l_base + 1 )
d1301 2
a1302 1
	rval = stack[numseq[i]][numseq[j]][numseq[i+1]][numseq[j-1]]+eparam[0];
d1319 1
a1319 1
	if( i <= l_base && ip > l_base || jp <= l_base && j > l_base )
d1331 1
a1331 1
			    stack[numseq[i]][numseq[j]][numseq[ip]][numseq[jp]]
d1347 2
a1348 2
			tstki[numseq[i]][numseq[j]][BCODE_A][BCODE_A] +
			tstki[numseq[jp]][numseq[ip]][BCODE_A][BCODE_A]+
d1353 2
a1354 2
		tstki[numseq[i]][numseq[j]][numseq[i+1]][numseq[j-1]] +
		tstki[numseq[jp]][numseq[ip]][numseq[jp+1]][numseq[ip-1]] +
d1360 3
a1362 3
				if( WC( numseq[i], numseq[j] ) )
					a = numseq[i];
				else if( GU( numseq[i], numseq[j] ) )
d1364 1
a1364 1
				else if( GU( numseq[j], numseq[i] ) ) 
d1366 3
a1368 3
				if( WC( numseq[ip], numseq[jp] ) )
					b = numseq[ip];
				else if( GU( numseq[ip], numseq[jp] ) )
d1370 1
a1370 1
				else if( GU( numseq[jp], numseq[ip] ) ) 
d1374 1
a1374 1
			asint3[a][b][numseq[i+1]][numseq[j-1]][numseq[jp+1]];
d1377 3
a1379 3
				if( WC( numseq[jp], numseq[ip] ) )
					a = numseq[jp];
				else if( GU( numseq[jp], numseq[ip] ) )
d1381 1
a1381 1
				else if( GU( numseq[ip], numseq[jp] ) ) 
d1383 3
a1385 3
				if( WC( numseq[j], numseq[i] ) )
					b = numseq[j];
				else if( GU( numseq[j], numseq[i] ) )
d1387 1
a1387 1
				else if( GU( numseq[i], numseq[j] ) ) 
d1391 1
a1391 1
			asint3[a][b][numseq[jp+1]][numseq[ip-1]][numseq[i+1]];
d1395 5
a1399 5
			if( WC( numseq[i], numseq[j] ) )
				lf = numseq[i];
			else if( GU( numseq[i], numseq[j] ) ||
				GU( numseq[j], numseq[i] ) )
				lf = numseq[i] + 2;
d1403 5
a1407 5
			if( WC( numseq[ip], numseq[jp] ) )
				rt = numseq[ip];
			else if( GU( numseq[ip], numseq[jp] ) ||
				GU( numseq[jp], numseq[ip] ) )
				rt = numseq[ip] + 2;
d1412 1
a1412 1
				    sint2[lf][rt][numseq[i+1]][numseq[j-1]];
d1415 1
a1415 1
	sint4[lf][rt][numseq[i+1]][numseq[j-1]][numseq[ip-1]][numseq[jp+1]];
d1420 2
a1421 2
			tstki[numseq[i]][numseq[j]][BCODE_A][BCODE_A] +
			tstki[numseq[jp]][numseq[ip]][BCODE_A][BCODE_A]+
d1426 2
a1427 2
		tstki[numseq[i]][numseq[j]][numseq[i+1]][numseq[j-1]] +
		tstki[numseq[jp]][numseq[ip]][numseq[jp+1]][numseq[ip-1]] +
d1446 1
a1446 1
	if( i <= l_base && j > l_base )
d1454 1
a1454 1
		if( numseq[k] == BCODE_C )
d1464 5
a1468 5
	if( i > 1 && j <= l_base ){
		if( numseq[i] == BCODE_G &&
			numseq[i-1] == BCODE_G &&
			numseq[i-2]==BCODE_G &&
			numseq[j] == BCODE_T )
d1476 1
a1476 1
			key = numseq[i+size+1];
d1478 1
a1478 1
				key = ( key << 3 ) + numseq[i+k];
d1490 1
a1490 1
			key = numseq[i+size+1];
d1492 1
a1492 1
				key = ( key << 3 ) + numseq[i+k];
d1501 2
a1502 1
		rval += tstkh[numseq[i]][numseq[j]][numseq[i+1]][numseq[j-1]] +
d1506 2
a1507 1
		rval += tstkh[numseq[i]][numseq[j]][numseq[i+1]][numseq[j-1]] +
d1523 1
a1523 1
	rval = dangle[ numseq[i] ][ numseq[j] ][ numseq[ip] ][ jp ]; 
d1538 1
a1538 1
	rval = inc2[ numseq[i] ][ numseq[j] ] * eparam[ 9 ];
@


1.2
log
@uses RM_errormsg() instead of fprintf( stderr, "..." );
@
text
@d33 3
d119 1
a119 9
	char	*ep;
	char	efndata[ 256 ];
	int	rval = 0;

	if( ( ep = getenv( "EFNDATA" ) ) == NULL ){
		RM_errormsg( 0, "RM_getefndata: EFNDATA not defined." );
		return( 1 );
	}else
		strcpy( efndata, ep );
d121 2
a122 2
	if( gettloops( efndata ) )
		rval = 1;
d124 2
a125 2
	if( gettriloops( efndata ) )
		rval = 1;
d127 2
a128 2
	if( getmiscloop( efndata ) )
		rval = 1;
d130 2
a131 2
	if( getdangle( efndata ) )
		rval = 1;
d133 2
a134 2
	if( getibhloop( efndata ) )
		rval = 1;
d136 4
a139 4
	if( getstack( efndata, "stack.dat", stack, INFINITY ) )
		rval = 1;
	if( stacktest( "stack.dat", stack ) )
		rval = 1;
d141 4
a144 4
	if( getstack( efndata, "tstackh.dat", tstkh, 0 ) )
		rval = 1;
	if( stacktest( "tstackh.dat", stack ) )
		rval = 1;
d146 4
a149 4
	if( getstack( efndata, "tstacki.dat", tstki, 0 ) )
		rval = 1;
	if( stacktest( "tstacki.dat", stack ) )
		rval = 1;
d151 4
a154 4
	if( getsymint( efndata ) )
		rval = 1;
	if( symtest() )
		rval = 1;
d156 2
a157 2
	if( getasymint( efndata ) )
		rval = 1;
d162 1
a162 2
static	int	gettloops( efndata )
char	efndata[];
d171 1
a171 1
	sprintf( fname, "%s/%s", efndata, "tloop.dat" );
d176 1
a176 1
		return( 1 );
d178 1
a178 1
	rval = 0;
d188 1
a188 1
		rval = 1;
d203 1
a203 2
static	int	gettriloops( efndata )
char	efndata[];
d212 1
a212 1
	sprintf( fname, "%s/%s", efndata, "triloop.dat" );
d217 1
a217 1
		return( 1 );
d219 1
a219 1
	rval = 0;
d229 1
a229 1
		rval = 1;
d244 1
a244 2
static	int	getmiscloop( efndata )
char	efndata[];
d252 1
a252 1
	sprintf( fname, "%s/%s", efndata, "miscloop.dat" );
d257 1
a257 1
		return( 1 );
d260 1
a260 1
	rval = 0;
d267 1
a267 1
		rval = 1;
d277 1
a277 1
		rval = 1;
d291 1
a291 1
		rval = 1;
d310 1
a310 1
		rval = 1;
d329 1
a329 1
			rval = 1;
d339 1
a339 1
			rval = 1;
d349 1
a349 1
			rval = 1;
d360 1
a360 1
			rval = 1;
d371 1
a371 1
			rval = 1;
d382 1
a382 1
			rval = 1;
d391 1
a391 1
			rval = 1;
d402 1
a402 2
static	int	getdangle( efndata )
char	efndata[];
d412 1
a412 1
	sprintf( fname, "%s/%s", efndata, "dangle.dat" );
d417 1
a417 1
		return( 1 );
d419 1
a419 1
	rval = 0;
d432 1
a432 1
				rval = 1;
d455 1
a455 2
static	int	getibhloop( efndata )
char	efndata[];
d464 1
a464 1
	sprintf( fname, "%s/%s", efndata, "loop.dat" );
d469 1
a469 1
		return( 1 );
d471 1
a471 1
	rval = 0;
d477 1
a477 1
		rval = 1;
d505 1
a505 2
static	int	getstack( efndata, sfname, stack, defval ) 
char	efndata[];
d518 1
a518 1
	sprintf( fname, "%s/%s", efndata, sfname );
d523 1
a523 1
		return( 1 );
d525 1
a525 1
	rval = 0;
d542 1
a542 1
			rval = 1;
d574 1
a574 1
	for( rval = 0, v1 = 0; v1 < 4; v1++ ){
d585 1
a585 1
						rval = 1;
d594 1
a594 2
static	int	getsymint( efndata )
char	efndata[];
d605 1
a605 1
	sprintf( fname, "%s/%s", efndata, "sint2.dat" );
d610 1
a610 1
		return( 1 );
d612 1
a612 1
	rval = 0;
d619 1
a619 1
		rval = 1;
d629 1
a629 1
			rval = 1;
d659 1
a659 1
	sprintf( fname, "%s/%s", efndata, "sint4.dat" );
d664 1
a664 1
		return( 1 );
d672 1
a672 1
		rval = 1;
d683 1
a683 1
		    rval = 1;
d738 1
a738 1
	for( rval = 0, v1 = 0; v1 < 6; v1++ ){
d745 1
a745 1
			    rval = 1;
d767 1
a767 1
				    rval = 1;
d785 1
a785 2
static	int	getasymint( efndata )
char	efndata[];
d796 1
a796 1
	sprintf( fname, "%s/%s", efndata, "asint1x2.dat" );
d802 1
a802 1
		return( 1 );
d804 1
a804 1
	rval = 0;
d811 1
a811 1
		rval = 1;
d833 1
a833 1
			rval = 1;
@


1.1
log
@Initial revision
@
text
@a24 3
#define	MAXN		20000
#define	MAXSIZ		20000

d30 3
d40 2
a72 8
static	char	seq[ 2*MAXN ];
static	char	ctlabel[ 50 ];
static	char	ctnam[ 50 ];

static	char	num2base[ 4 ] = { 'A', 'C', 'G', 'T' };
#define	N2B(n)	((n)>=0&&(n)<=3?num2base[(n)]:'X')
static	int	base2num();

a78 3
static	int	getct();
static	int	knotted();

d89 1
a89 1
static	int	stest();
a113 30
static	int	base2num( b )
int	b;
{

	switch( b ){
	case 'a' :
	case 'A' :
		return( BCODE_A );
		break;
	case 'c' :
	case 'C' :
		return( BCODE_C );
		break;
	case 'g' :
	case 'G' :
		return( BCODE_G );
		break;
	case 't' :
	case 'T' :
	case 'u' :
	case 'U' :
		return( BCODE_T );
		break;

	default :
		return( BCODE_N );
		break;
	}
}

d118 1
a118 1
	int	i;
d121 1
a121 1
		fprintf( stderr, "RM_getefndata: EFNDATA not defined.\n" );
d127 1
a127 1
		return( 1 );
d130 1
a130 1
		return( 1 );
d133 1
a133 1
		return( 1 );
d136 1
a136 1
		return( 1 );
d139 1
a139 1
		return( 1 );
d142 3
a144 3
		return( 1 );
	if( stest( "stack.dat", stack ) )
		return( 1 );
d147 3
a149 1
		return( 1 );
d152 3
a154 1
		return( 1 );
d157 1
a157 1
		return( 1 );
d159 1
a159 1
		return( 1 );
d162 1
a162 1
		return( 1 );
d164 1
a164 1
	return( 0 );
d179 1
a179 1
		fprintf( stderr, "gettloops: can't read tloops file '%s'.\n",
d181 1
d198 2
a199 2
		fprintf( stderr,
"gettloops: # of tloops (%d) exceeds MAXTLOOPS (%d), last %d tloops ignored.\n",
d201 1
d221 1
a221 2
		fprintf( stderr,
			"gettriloops: can't read triloops file '%s'.\n",
d223 1
d240 2
a241 2
		fprintf( stderr,
"gettloops: # of triloops (%d) exceeds MAXTRILOOPS (%d), last %d triloops ignored.\n",
d243 1
d262 1
a262 2
		fprintf( stderr,
			"getmiscloop: can't read miscloop file '%s'.\n",
d264 1
d274 1
a274 1
		fprintf( stderr, "getmiscloop: no prelog.\n" );
d284 1
a284 1
		fprintf( stderr, "getmiscloop: no maxpen.\n" );
d298 1
a298 1
		fprintf( stderr, "getmiscloop: no poppen values.\n" );
d317 1
a317 1
		fprintf( stderr, "getmiscloop: no poppen values.\n" );
d335 2
a336 2
			fprintf( stderr,
				"getmiscloop: no terminal AU penalty.\n" );
d346 1
a346 2
			fprintf( stderr,
				"getmiscloop: no GGG hairpin term.\n" );
d356 1
a356 2
			fprintf( stderr,
				"getmiscloop: no c hairpin slope.\n" );
d366 2
a367 2
			fprintf( stderr,
				"getmiscloop: no c hairpin intercept.\n" );
d377 2
a378 2
			fprintf( stderr,
				"getmiscloop: no c hairpin of 3 term.\n" );
d388 2
a389 2
			fprintf( stderr,
			"getmiscloop: no Intermol init free energy.\n" );
d398 1
a398 2
			fprintf( stderr,
			"getmiscloop: no GAIL Rule term.\n" );
d423 1
a423 2
		fprintf( stderr,
			"getdangle: can't read dangle file '%s'.\n",
d425 1
d437 1
a437 1
				fprintf( stderr,
d440 1
a469 1
	int	v1, v2, v3;
d471 1
a471 1
	int	i, f, n_fields;
d476 1
a476 2
		fprintf( stderr,
			"getibhloop: can't read ibhloop file '%s'.\n",
d478 1
d484 1
a484 2
		fprintf( stderr,
			"getibhloop: error in ibhloop file '%s'.\n",
d486 1
d493 1
a493 1
			n_fields = split( line, fields, " \t\n" );
d526 1
a526 1
	int	i, f, n_fields;
d531 1
a531 2
		fprintf( stderr,
			"getibhloop: can't read stack file '%s'.\n",
d533 1
d549 2
a550 2
			fprintf( stderr,
				"getstack: premature end of stack file '%s'.\n",
d552 1
d578 1
a578 1
static	int	stest( sname, stack )
d591 2
a592 2
						fprintf( stderr,
			"stest: stack '%s' symmetry error at %d,%d,%d,%d\n",
d595 1
d619 1
a619 2
		fprintf( stderr,
			"getsymint: can't read sym-2 loop file '%s'.\n",
d621 1
d628 1
a628 1
		fprintf( stderr, "getsymint: error in sym-2 loop file '%s'.\n",
d630 1
d637 2
a638 2
			fprintf( stderr,
			"getsymint: premature end of sym-2 loop file '%s'.\n",
d640 1
d673 1
a673 2
		fprintf( stderr,
			"getsymint: can't read sym-4 loop file '%s'.\n",
d675 1
d681 1
a681 1
		fprintf( stderr, "getsymint: error in sym-4 loop file '%s'.\n",
d683 1
d691 2
a692 2
		    fprintf( stderr,
			"getsymint: premature end of sym-2 loop file '%s'.\n",
d694 1
d758 2
a759 3
			    fprintf( stderr, "symtest: sint2 failure: " );
			    fprintf( stderr,
		"sint2[%d][%d][%d][%d] (%d) != sint2[%d][%d][%d][%d] (%d)\n",
d762 1
d780 2
a781 4
				    fprintf( stderr,
					"symtest: sint4 failure: " );
				    fprintf( stderr, 
"sint4[%d][%d][%d][%d][%d][%d] (%d) != sint4[%d][%d][%d][%d][%d][%d] (%d)\n",
d786 1
d806 1
a806 1
	int	lval, worst;
d811 2
a812 2
		fprintf( stderr,
			"getasymint: can't read asym-1x2 loop file '%s'.\n",
d814 1
d821 1
a821 2
		fprintf( stderr,
			"getasymint: error in asym-1x2 loop file '%s'.\n",
d823 1
d842 2
a843 2
			fprintf( stderr,
		"getasymint: premature end of asym-1x2 loop file '%s'.\n",
d845 1
d1064 3
a1066 2
			fprintf( stderr,
				"packloop: illegal char %c (%d)\n", *lp, *lp );
a1092 1
	int	error;
a1099 1
	error = 0;
d1167 1
a1167 1
			fprintf( stderr, "RM_efn: knot: (%5d.%5d) (%5d.%5d)\n",
d1169 1
d1232 2
a1233 1
				fprintf( stderr, "RM_efn: ERROR: %d\n", 51 );
d1506 1
a1506 1
			for( lval = 0, k = 0; k < n_triloops; k++ ){
d1567 1
a1567 1
		fprintf( stderr, "push: stack overflow.\n" );
@
