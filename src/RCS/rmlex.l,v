head	1.36;
access;
symbols;
locks; strict;
comment	@ * @;


1.36
date	2003.07.21.20.43.10;	author macke;	state Exp;
branches;
next	1.35;

1.35
date	2001.07.30.19.48.47;	author macke;	state Exp;
branches;
next	1.34;

1.34
date	2000.12.18.03.04.34;	author macke;	state Exp;
branches;
next	1.33;

1.33
date	2000.12.15.23.08.11;	author macke;	state Exp;
branches;
next	1.32;

1.32
date	2000.12.15.22.41.30;	author macke;	state Exp;
branches;
next	1.31;

1.31
date	2000.12.14.05.32.02;	author macke;	state Exp;
branches;
next	1.30;

1.30
date	2000.12.09.22.04.28;	author macke;	state Exp;
branches;
next	1.29;

1.29
date	2000.12.05.18.44.01;	author macke;	state Exp;
branches;
next	1.28;

1.28
date	2000.04.25.00.22.22;	author macke;	state Exp;
branches;
next	1.27;

1.27
date	2000.03.18.21.52.16;	author macke;	state Exp;
branches;
next	1.26;

1.26
date	2000.03.08.03.55.10;	author macke;	state Exp;
branches;
next	1.25;

1.25
date	99.10.19.16.45.20;	author macke;	state Exp;
branches;
next	1.24;

1.24
date	99.10.03.19.06.29;	author macke;	state Exp;
branches;
next	1.23;

1.23
date	99.09.11.03.13.15;	author macke;	state Exp;
branches;
next	1.22;

1.22
date	99.09.04.20.36.50;	author macke;	state Exp;
branches;
next	1.21;

1.21
date	99.09.04.04.08.05;	author macke;	state Exp;
branches;
next	1.20;

1.20
date	99.04.05.01.07.28;	author macke;	state Exp;
branches;
next	1.19;

1.19
date	98.12.29.21.30.45;	author macke;	state Exp;
branches;
next	1.18;

1.18
date	98.12.23.19.40.14;	author macke;	state Exp;
branches;
next	1.17;

1.17
date	98.12.19.03.30.51;	author macke;	state Exp;
branches;
next	1.16;

1.16
date	98.12.18.22.05.58;	author macke;	state Exp;
branches;
next	1.15;

1.15
date	98.12.18.04.35.13;	author macke;	state Exp;
branches;
next	1.14;

1.14
date	98.12.15.04.19.43;	author macke;	state Exp;
branches;
next	1.13;

1.13
date	98.12.15.04.18.17;	author macke;	state Exp;
branches;
next	1.12;

1.12
date	98.12.14.18.10.58;	author macke;	state Exp;
branches;
next	1.11;

1.11
date	98.12.14.04.22.36;	author macke;	state Exp;
branches;
next	1.10;

1.10
date	98.12.14.04.12.30;	author macke;	state Exp;
branches;
next	1.9;

1.9
date	98.12.14.03.24.56;	author macke;	state Exp;
branches;
next	1.8;

1.8
date	98.12.12.17.49.28;	author macke;	state Exp;
branches;
next	1.7;

1.7
date	98.12.12.04.11.55;	author macke;	state Exp;
branches;
next	1.6;

1.6
date	98.12.11.17.54.13;	author macke;	state Exp;
branches;
next	1.5;

1.5
date	98.12.11.17.51.56;	author macke;	state Exp;
branches;
next	1.4;

1.4
date	98.12.11.05.21.57;	author macke;	state Exp;
branches;
next	1.3;

1.3
date	98.12.08.17.37.19;	author macke;	state Exp;
branches;
next	1.2;

1.2
date	98.11.28.05.21.50;	author macke;	state Exp;
branches;
next	1.1;

1.1
date	98.11.28.04.06.09;	author macke;	state Exp;
branches;
next	;


desc
@first version
@


1.36
log
@4 new symbols: BEGIN, END, HOLD, RELEASE for use with carry around
score sections.
@
text
@%{

#include <string.h>
#include "rnamot.h"
#include "y.tab.h"

double	atof();
char	*RM_str2seq();

extern	int	rm_context;
extern	char	*rm_wdfname;
extern	int	rm_lineno;
extern	int	rm_emsg_lineno;
extern	VALUE_T	rm_tokval;

static	char	*sp;
static	POS_T	*posp;
static	char	emsg[ 256 ];

typedef	struct	fname_t	{
	struct	fname_t	*f_left;
	struct	fname_t	*f_right;
	char	*f_name;
} FNAME_T;

static	FNAME_T	*ftree;

static	void	setfileinfo( char [] );
static	FNAME_T	*enter_fname( FNAME_T **, char [] );

%}
%%

^#\ line.*	setfileinfo( yytext );
#.*		;

\n		;

[\ \t\f]+	;

parms		return( SYM_PARMS );
descr		return( SYM_DESCR );
sites		return( SYM_SITES );
score		return( SYM_SCORE );

se		return( SYM_SE );
ctx		return( SYM_CTX );
ss		return( SYM_SS );
h5		return( SYM_H5 );
h3		return( SYM_H3 );
p5		return( SYM_P5 );
p3		return( SYM_P3 );
t1		return( SYM_T1 );
t2		return( SYM_T2 );
t3		return( SYM_T3 );
q1		return( SYM_Q1 );
q2		return( SYM_Q2 );
q3		return( SYM_Q3 );
q4		return( SYM_Q4 );

ACCEPT		return( SYM_ACCEPT );
BEGIN		return( SYM_BEGIN );
END		return( SYM_END );
HOLD		return( SYM_HOLD );
REJECT		return( SYM_REJECT );
RELEASE		return( SYM_RELEASE );
break		return( SYM_BREAK );
continue	return( SYM_CONTINUE );
else		return( SYM_ELSE );
for		return( SYM_FOR );
if		return( SYM_IF );
in		return( SYM_IN );
while		return( SYM_WHILE );

[a-zA-Z][_a-zA-Z0-9]*	{
		  sp = ( char * )malloc(( yyleng + 1 ) *sizeof( char ));
		  if( sp == NULL ){
			RM_errormsg( 1, 
				"lex.yy.c: can't alloc sp for SYM_IDENT." );
		  }
		  strcpy( sp, yytext );
		  rm_tokval.v_type = T_STRING;
		  rm_tokval.v_value.v_pval = sp;
		  return( SYM_IDENT );
		}
[0-9]+		{ rm_tokval.v_type = T_INT;
		  rm_tokval.v_value.v_ival = atoi( yytext );
		  return( SYM_INT );
		}
([0-9]+[eE][\+\-]?[0-9]+)|((([0-9]+\.[0-9]*)|(\.[0-9]+))([eE][\+\-]?[0-9]+)?) {
		  rm_tokval.v_type = T_FLOAT;
		  rm_tokval.v_value.v_dval = atof( yytext );
		  return( SYM_FLOAT );
		}
\"[^"\n]*	{ if( yytext[ yyleng - 1 ] == '\\' )
			yymore();
		  else{
			yytext[ yyleng++ ] = input();
			yytext[ yyleng ] = '\0';
			sp = ( char * )malloc( ( yyleng - 1 )*sizeof( char ) );
			if( sp == NULL ){
				RM_errormsg( 1,
				"lex.yy.c: can't alloc sp for SYM_STRING." );
			}
			strncpy( sp, &yytext[1], yyleng - 2 );
			sp[ yyleng - 2 ] = '\0';
			rm_tokval.v_type = T_STRING;
/*
			rm_tokval.v_value.v_pval = sp;
*/
			rm_tokval.v_value.v_pval = RM_str2seq( sp );
			return( SYM_STRING );
		  }
		}
\'[^'\n]*	{ if( yytext[ yyleng - 1 ] == '\\' )
			yymore();
		  else{
			yytext[ yyleng++ ] = input();
			yytext[ yyleng ] = '\0';
			sp = ( char * )malloc( ( yyleng - 1 )*sizeof( char ) );
			if( sp == NULL ){
				RM_errormsg( 1,
				"lex.yy.c: can't alloc sp for SYM_STRING." );
			}
			strncpy( sp, &yytext[1], yyleng - 2 );
			sp[ yyleng - 2 ] = '\0';
			rm_tokval.v_type = T_STRING;
			rm_tokval.v_value.v_pval = sp;
			return( SYM_STRING );
		  }
		}

&&		return( SYM_AND );
=		return( SYM_ASSIGN );
\$		{ posp = ( POS_T * )malloc( sizeof( POS_T ) );
		  if( posp == NULL ){
			RM_errormsg( 1,
				"lex.yy.c: can't alloc posp for SYM_DOLLAR." );
		  }
		  posp->p_type = SYM_DOLLAR;
		  posp->p_lineno = rm_lineno;
		  posp->p_tag = NULL;
		  posp->p_addr.a_l2r = 0;
		  posp->p_addr.a_offset = 0;
		  rm_tokval.v_type = T_POS;
		  rm_tokval.v_value.v_pval = posp;
		  return( SYM_DOLLAR );
		}
!~		return( SYM_DONT_MATCH );
==		return( SYM_EQUAL );
\>		return( SYM_GREATER );
\>=		return( SYM_GREATER_EQUAL );
\<		return( SYM_LESS );
\<=		return( SYM_LESS_EQUAL );
=~		return( SYM_MATCH );
\-		return( SYM_MINUS );
\-=		return( SYM_MINUS_ASSIGN );
\-\-		return( SYM_MINUS_MINUS );
!		return( SYM_NOT );
!=		return( SYM_NOT_EQUAL );
\|\|		return( SYM_OR );
%		return( SYM_PERCENT );
%=		return( SYM_PERCENT_ASSIGN );
\+		return( SYM_PLUS );
\+=		return( SYM_PLUS_ASSIGN );
\+\+		return( SYM_PLUS_PLUS );
\*		return( SYM_STAR );
\*=		return( SYM_STAR_ASSIGN );
\/		return( SYM_SLASH );
\/=		return( SYM_SLASH_ASSIGN );

\(		return( SYM_LPAREN );
\)		return( SYM_RPAREN );
\[		return( SYM_LBRACK );
\]		return( SYM_RBRACK );
\{		return( SYM_LCURLY );
\}		return( SYM_RCURLY );
\,		return( SYM_COMMA );
:		return( SYM_COLON );
;		return( SYM_SEMICOLON );

.		return( SYM_ERROR );

%%

int	yywrap()
{

	return( 1 );
}

static	void	setfileinfo( char data[] )
{
	char	*dp, *qp;
	int	lnum;
	char	work[ 256 ];
	FNAME_T	*fnp;

	dp = &data[ 6 ];	/* skip # line	*/
	if( !isspace( *dp ) )
		return;
	dp += strspn( dp, " \t" );
	if( !isdigit( *dp ) )
		return;
	for( lnum = *dp++ - '0'; isdigit( *dp ); dp++ )
		lnum = 10 * lnum + *dp - '0';
	if( !isspace( *dp ) )
		return;
	for( ; isspace( *dp ); dp++ )
		;
	if( *dp != '\'' )
		return;
	dp++;
	if( qp = strchr( dp, '\'' ) ){
		rm_lineno = lnum;
		strncpy( work, dp, qp - dp );
		work[ qp - dp ] = '\0';
		fnp = enter_fname( &ftree, work );
		rm_wdfname = fnp->f_name;
	}
}

static	FNAME_T	*enter_fname( FNAME_T **root, char fname[] )
{
	char	*sp;
	FNAME_T	*fnp;
	int	cv;

	if( *root == NULL ){
		fnp = ( FNAME_T * )malloc( sizeof( FNAME_T ) );
		if( fnp == NULL ){
			sprintf( emsg,
			"enter_fname: can't allocate space for fnp for '%s'.",
				fname );
			rm_emsg_lineno = rm_lineno;
			RM_errormsg( 1, emsg );
		}
		fnp->f_left = NULL;
		fnp->f_right = NULL;
		sp = ( char * )malloc( strlen( fname ) + 1 );
		if( sp == NULL ){
			sprintf( emsg,
		"enter_fname: can't allocate space for f_name for '%s'.",
				fname );
			rm_emsg_lineno = rm_lineno;
			RM_errormsg( 1, emsg );
		}
		strcpy( sp, fname );
		fnp->f_name = sp;
		*root = fnp;
	}else if( ( cv = strcmp( ( *root )->f_name, fname ) ) < 0 )
		fnp = enter_fname( &( *root )->f_right, fname );
	else if( cv > 0 )
		fnp = enter_fname( &( *root )->f_left, fname );
	else
		fnp = *root;
	return( fnp );
}
@


1.35
log
@added coded to return SYM_CTX on encountering new symbol ctx.
@
text
@d62 3
d66 1
@


1.34
log
@rm_wdfname is now always allocated and all of its value are live during
a run. Save the file name from the # line N 'XXX' lines.
@
text
@d47 1
@


1.33
log
@changed extern def of rm_wdfname from *rm_wdfname to rm_wdfname[].
@
text
@d11 1
a11 1
extern	char	rm_wdfname[];
d13 1
d20 8
d29 1
d37 1
a37 1
\n		rm_lineno++;
d191 2
d211 4
a214 2
		strncpy( rm_wdfname, dp, qp - dp );
		rm_wdfname[ qp - dp ] = '\0';
d216 37
@


1.32
log
@removed ipf* stuff as it is no longer used.  Added new func()
setfileinfo() to parse the # line N 'fname' lines, thus setting the
current file name.
@
text
@d11 1
a11 1
extern	char	*rm_wdfname;
@


1.31
log
@removed all include stuff as it is now handled upstream.  yyin is
fully expanded before passing to lex.
@
text
@d11 1
d19 1
a19 4
char	*rm_ipfname;
static	FILE	*ipfp;
static	int	ipfd;
static	long	ipfsize;	
d24 1
d175 27
@


1.30
log
@include stuff: RM_include(), RM_pushfile() and RM_popfile() is now here.
@
text
@d6 1
a8 3
FILE	*RM_include();
FILE	*RM_pushfile();
FILE	*RM_popfile();
d10 1
a12 9
extern	char	*rm_cldfname;
extern	int	rm_usecldfile;

#define	RM_DFSTK_SIZE	10
FSTK_T	rm_dfstk[ RM_DFSTK_SIZE ];
int	rm_dfstkp = -1;		/* MT stack contains -descr XXX fneme	*/
char	*rm_dfname = NULL;
#define	IS_FSTK_EMPTY()	(rm_dfstkp==0)
#define	IS_FSTK_FULL()	(rm_dfstkp>=RM_DFSTK_SIZE-1)
a13 2
INCDIR_T	*rm_idlist;

d18 5
a25 1
#\ *include[\ \t]+.*	yyin = RM_include( yytext );
d33 1
a33 10
descr		{ 
		  if( rm_cldfname != NULL){
			if( rm_usecldfile ){
				rm_usecldfile = 0;
				yyin = RM_pushfile( rm_cldfname );
			}else
		  		return( SYM_DESCR );
		  }else
		  	return( SYM_DESCR );
		}
a174 5
	for( yyin = RM_popfile(); yyin; yyin = RM_popfile() ){
		if( !feof( yyin ) ){
			return( 0 );
		}
	}
a175 113
}

FILE	*RM_pushfile( char fname[] )
{
	char	*sp;
	FILE	*fp;
	FSTK_T	*fsp;

	if( IS_FSTK_FULL() ){
		sprintf( emsg, "RM_pushfile: fstk overflow: %s.", fname );
		RM_errormsg( 1, emsg );
	}
	sp = ( char * )malloc( strlen( fname ) + 1 );
	if( sp == NULL ){
		sprintf( emsg, "RM_pushfile: can't allocate fname for: %s.",
			fname );
		RM_errormsg( 1, emsg );
	}
	strcpy( sp, fname );
	if( ( fp = fopen( fname, "r" ) ) == NULL ){
		sprintf( emsg, "RM_pushfile: can't read %s.", fname );
		RM_errormsg( 1, emsg );
	}
	if( !IS_FSTK_EMPTY() )
		rm_dfstk[ rm_dfstkp ].f_lineno = rm_lineno;
	rm_dfstkp++;
	fsp = &rm_dfstk[ rm_dfstkp ];
	fsp->f_fname = sp;
	fsp->f_fp = fp;
	fsp->f_lineno = 1;
	rm_dfname = fsp->f_fname;
	rm_lineno = 1;

#ifndef	FLEX
	fseek( yyin, -( long )( yyleng  + ( yysptr - yysbuf ) ), 1 );
	yysptr = yysbuf;
	yyleng = 0;
	*yytext = '\0';
#endif

	return( fp );
}

FILE	*RM_popfile( void )
{
	FSTK_T	*fsp;

	if( IS_FSTK_EMPTY() )
		return( NULL );

	fsp = &rm_dfstk[ rm_dfstkp ];
	fclose( fsp->f_fp );
	free( fsp->f_fname );

	rm_dfstkp--;
	fsp = &rm_dfstk[ rm_dfstkp ];
	rm_dfname = fsp->f_fname;
	rm_lineno = fsp->f_lineno;

	return( fsp->f_fp );
}

FILE	*RM_include( char str[] )
{
	char	*sp, *sp1;
	char	fname[ 256 ], path[ 256 ];
	int	c;
	FILE	*fp;
	INCDIR_T	*idp;

	for( sp = &str[1]; isspace( *sp ); sp++ )
		;
	for( ; *sp && !isspace( *sp ); sp++ )
		;
	if( *sp == '\0' ){
		RM_errormsg( 1, "RM_include: no filename." );
	}
	for( ; isspace( *sp ); sp++ )
		;
	if( *sp == '"' )
		c = '"';
	else if( *sp == '<' )
		c = '>';
	else if( *sp == '\'' )
		c = '\'';
	else{
		sprintf( emsg, "RM_include: bad include filename '%s'.", sp );
		RM_errormsg( 1, emsg );
	}
	sp++;
	if( ( sp1 = strchr( sp, c ) ) == NULL ){
		sprintf( emsg, "RM_include: bad include filename '%s'.", sp );
		RM_errormsg( 1, emsg );
	}
	strncpy( fname, sp, sp1 - sp );
	fname[ sp1 - sp ] = '\0';

	if( rm_idlist == NULL )
		fp = RM_pushfile( fname );
	else{
		for( idp = rm_idlist; idp; idp = idp->i_next ){
			sprintf( path, "%s/%s", idp->i_name, fname );
			if( fp = RM_pushfile( path ) )
				break;
		}
	}
	if( fp == NULL ){
		sprintf( emsg,
			"RM_include: can't find include file '%s'.", fname );
		RM_errormsg( 1, emsg );
	}

	return( fp );
@


1.29
log
@added new rule for #include.  Also modified yywrap() to unstack
any interpolated files.
@
text
@d9 1
d14 12
d28 1
d41 10
a50 1
descr		return( SYM_DESCR );
d198 113
@


1.28
log
@change float v_fval to double v_dval
@
text
@d3 1
d6 1
a6 1
double	atof();		/* get it it if we ever need reals	*/
d8 2
d19 1
d169 5
@


1.27
log
@added lines to recognize [ and ] as SYM_LBRACK and SYM_RBRACK.
@
text
@d68 1
a68 1
		  rm_tokval.v_value.v_fval = atof( yytext );
@


1.26
log
@added '' strings which are uninterpreted.  Added call to RM_str2seq()
in "" string as these strings must be converted IUPAC sequences.
@
text
@d150 2
@


1.25
log
@added new res. word 'se' which is any structure element for use in the
score section.
@
text
@d6 1
d72 20
@


1.24
log
@changed refs to errormsg to RM_errormsg().
@
text
@d26 1
@


1.23
log
@added patters for break & continue.
@
text
@d52 1
a52 1
			errormsg( 1, 
d76 1
a76 1
				errormsg( 1,
d91 1
a91 1
			errormsg( 1,
@


1.22
log
@added patterns for the symbols to be used in the score section.
@
text
@d41 2
@


1.21
log
@added pattern for floating pt numbers (period and/or e fmt)
@
text
@d24 2
d39 8
d85 1
a86 4
\+=		return( SYM_PLUS_ASSIGN );
\-=		return( SYM_MINUS_ASSIGN );
\+		return( SYM_PLUS );
\-		return( SYM_MINUS );
d101 23
d130 1
@


1.20
log
@replace p_l2r & p_offset with p_addr.a_l2r & p_addr.a_offset.
@
text
@d52 5
@


1.19
log
@converted fprintf( stderr error messages into calls to errormsg().
SYM_DOLLAR now creates a value of type T_POS.
@
text
@d83 2
a84 2
		  posp->p_l2r = 0;
		  posp->p_offset = 0;
@


1.18
log
@change name of rmlineno & rmval to rm_lineno & rm_tokval.
@
text
@d10 1
d40 2
a41 3
			fprintf( stderr,
		"lex.yy.c: FATAL: can't alloc sp for SYM_IDENT.\n" );
			exit( 1 );
d59 2
a60 3
				fprintf( stderr,
			"lex.yy.c: FATAL: can't alloc sp for SYM_STRING.\n" );
				exit( 1 );
d75 14
a88 1
\$		return( SYM_DOLLAR );
@


1.17
log
@moved rmval to compile; changed name of rm_lineno to rmlineno & moved it
compile.c
@
text
@d7 2
a8 2
extern	int	rmlineno;
extern	VALUE_T	rmval;
d16 1
a16 1
\n		rmlineno++;
d44 2
a45 2
		  rmval.v_type = T_STRING;
		  rmval.v_value.v_pval = sp;
d48 2
a49 2
[0-9]+		{ rmval.v_type = T_INT;
		  rmval.v_value.v_ival = atoi( yytext );
d65 2
a66 2
			rmval.v_type = T_STRING;
			rmval.v_value.v_pval = sp;
@


1.16
log
@put { for INT on the same line as the pattern, as the \ continue didn't
work for linux
@
text
@d7 2
a8 2
int	rmlineno = 1;
VALUE_T	rmval;
@


1.15
log
@split white space into white + newlines; accum. newlines in rmlineno.
@
text
@d36 2
a37 2
[a-zA-Z][_a-zA-Z0-9]*	\
		{ sp = ( char * )malloc(( yyleng + 1 ) *sizeof( char ));
@


1.14
log
@changed (again) EQUAL to ASSIGN.
@
text
@d7 1
d16 3
a18 1
[\ \t\f\n]+	;
@


1.13
log
@combine all pointers in VALUE_T into void* v_pval
@
text
@d68 3
a70 3
=		return( SYM_EQUAL );
\+=		return( SYM_PLUS_EQUAL );
\-=		return( SYM_MINUS_EQUAL );
@


1.12
log
@changed rws parm, site to parms, sites.
@
text
@d42 1
a42 1
		  rmval.v_value.v_cval = sp;
d63 1
a63 1
			rmval.v_value.v_cval = sp;
@


1.11
log
@removed pattern \. as period was no longer used.
@
text
@d17 1
a17 1
parm		return( SYM_PARM );
d19 1
a19 1
site		return( SYM_SITE );
@


1.10
log
@change rmval to hold the `type' of the value vs the symbol that is
associated with.
@
text
@a77 1
\.		return( SYM_PERIOD );
@


1.9
log
@removed 3 former reserved words: pair, mismatch, mispair.
@
text
@d41 1
a41 1
		  rmval.v_sym = SYM_IDENT;
d45 1
a45 1
[0-9]+		{ rmval.v_sym = SYM_INT;
d62 1
a62 1
			rmval.v_sym = SYM_STRING;
@


1.8
log
@added new tokens +=, -= & +; reordered the rules.
@
text
@a16 1
pair		return( SYM_PAIR );
a18 2
mismatch	return( SYM_MISMATCH );
mispair		return( SYM_MISPAIR );
@


1.7
log
@rmval now contains a v_sym which contains the current symbol.  Some
symbols: SYM_INT, SYM_STRING & SYM_IDENT have values of type v_ival,
v_cval & v_cval resp.  Other symbols (now at least) do not have associated
values.
@
text
@d72 5
d81 1
a82 3
\-		return( SYM_MINUS );
\$		return( SYM_DOLLAR );
\.		return( SYM_PERIOD );
@


1.6
log
@removed debug message.
@
text
@d44 1
a44 1
		  rmval.v_type = T_STRING;
d48 1
a48 1
[0-9]+		{ rmval.v_type = T_INT;
d65 1
a65 1
			rmval.v_type = T_STRING;
@


1.5
log
@copy yytext for string/ident into rmval.  die if string space can't
be allocated.
@
text
@a66 1
fprintf( stderr, "STRING = '%s'\n", sp );
@


1.4
log
@save the value of literals in rmval.
@
text
@d8 1
d36 12
a47 1
[a-zA-Z][_a-zA-Z0-9]*	return( SYM_IDENT );
d55 1
a55 1
			yytext[ yyleng ] = input();
d57 8
a64 2
			strcpy( yytext, &yytext[ 1 ] );
			yyleng = strlen( yytext );
d66 2
a67 1
			rmval.v_value.v_cval = yytext;
@


1.3
log
@working version.  shortened kws;
@
text
@d2 2
d5 4
d36 4
a39 1
[0-9]+		return( SYM_INT );
d46 3
@


1.2
log
@added reserved words covering the structure of the input: pairings,
parameters, descriptor, positions, and mismatch, mispair, pair.
include y.tab.h now.
@
text
@d10 3
a12 3
pairings	return( SYM_PAIRINGS );
parameters	return( SYM_PARAMETERS );
descriptor	return( SYM_DESCRIPTOR );
d15 13
a27 13
positions	return( SYM_POSITIONS );
ss		return( SYM_SINGLE );
h5		return( SYM_HELIX5 );
h3		return( SYM_HELIX3 );
p5		return( SYM_PARALLEL5 );
p3		return( SYM_PARALLEL3 );
t1		reteun( SYM_TRIPLEX1 );
t2		reteun( SYM_TRIPLEX2 );
t3		reteun( SYM_TRIPLEX3 );
q1		reteun( SYM_QUAD1 );
q2		reteun( SYM_QUAD2 );
q3		reteun( SYM_QUAD3 );
q4		reteun( SYM_QUAD4 );
@


1.1
log
@Initial revision
@
text
@d1 3
d10 6
d41 1
d44 2
d49 1
@
