head	1.27;
access;
symbols;
locks; strict;
comment	@ * @;


1.27
date	2000.03.18.21.52.16;	author macke;	state Exp;
branches;
next	1.26;

1.26
date	2000.03.08.03.55.10;	author macke;	state Exp;
branches;
next	1.25;

1.25
date	99.10.19.16.45.20;	author macke;	state Exp;
branches;
next	1.24;

1.24
date	99.10.03.19.06.29;	author macke;	state Exp;
branches;
next	1.23;

1.23
date	99.09.11.03.13.15;	author macke;	state Exp;
branches;
next	1.22;

1.22
date	99.09.04.20.36.50;	author macke;	state Exp;
branches;
next	1.21;

1.21
date	99.09.04.04.08.05;	author macke;	state Exp;
branches;
next	1.20;

1.20
date	99.04.05.01.07.28;	author macke;	state Exp;
branches;
next	1.19;

1.19
date	98.12.29.21.30.45;	author macke;	state Exp;
branches;
next	1.18;

1.18
date	98.12.23.19.40.14;	author macke;	state Exp;
branches;
next	1.17;

1.17
date	98.12.19.03.30.51;	author macke;	state Exp;
branches;
next	1.16;

1.16
date	98.12.18.22.05.58;	author macke;	state Exp;
branches;
next	1.15;

1.15
date	98.12.18.04.35.13;	author macke;	state Exp;
branches;
next	1.14;

1.14
date	98.12.15.04.19.43;	author macke;	state Exp;
branches;
next	1.13;

1.13
date	98.12.15.04.18.17;	author macke;	state Exp;
branches;
next	1.12;

1.12
date	98.12.14.18.10.58;	author macke;	state Exp;
branches;
next	1.11;

1.11
date	98.12.14.04.22.36;	author macke;	state Exp;
branches;
next	1.10;

1.10
date	98.12.14.04.12.30;	author macke;	state Exp;
branches;
next	1.9;

1.9
date	98.12.14.03.24.56;	author macke;	state Exp;
branches;
next	1.8;

1.8
date	98.12.12.17.49.28;	author macke;	state Exp;
branches;
next	1.7;

1.7
date	98.12.12.04.11.55;	author macke;	state Exp;
branches;
next	1.6;

1.6
date	98.12.11.17.54.13;	author macke;	state Exp;
branches;
next	1.5;

1.5
date	98.12.11.17.51.56;	author macke;	state Exp;
branches;
next	1.4;

1.4
date	98.12.11.05.21.57;	author macke;	state Exp;
branches;
next	1.3;

1.3
date	98.12.08.17.37.19;	author macke;	state Exp;
branches;
next	1.2;

1.2
date	98.11.28.05.21.50;	author macke;	state Exp;
branches;
next	1.1;

1.1
date	98.11.28.04.06.09;	author macke;	state Exp;
branches;
next	;


desc
@first version
@


1.27
log
@added lines to recognize [ and ] as SYM_LBRACK and SYM_RBRACK.
@
text
@%{

#include "rnamot.h"
#include "y.tab.h"
double	atof();		/* get it it if we ever need reals	*/
char	*RM_str2seq();

extern	int	rm_lineno;
extern	VALUE_T	rm_tokval;
static	char	*sp;
static	POS_T	*posp;

%}
%%

#.*		;

\n		rm_lineno++;

[\ \t\f]+	;

parms		return( SYM_PARMS );
descr		return( SYM_DESCR );
sites		return( SYM_SITES );
score		return( SYM_SCORE );

se		return( SYM_SE );
ss		return( SYM_SS );
h5		return( SYM_H5 );
h3		return( SYM_H3 );
p5		return( SYM_P5 );
p3		return( SYM_P3 );
t1		return( SYM_T1 );
t2		return( SYM_T2 );
t3		return( SYM_T3 );
q1		return( SYM_Q1 );
q2		return( SYM_Q2 );
q3		return( SYM_Q3 );
q4		return( SYM_Q4 );

ACCEPT		return( SYM_ACCEPT );
REJECT		return( SYM_REJECT );
break		return( SYM_BREAK );
continue	return( SYM_CONTINUE );
else		return( SYM_ELSE );
for		return( SYM_FOR );
if		return( SYM_IF );
in		return( SYM_IN );
while		return( SYM_WHILE );

[a-zA-Z][_a-zA-Z0-9]*	{
		  sp = ( char * )malloc(( yyleng + 1 ) *sizeof( char ));
		  if( sp == NULL ){
			RM_errormsg( 1, 
				"lex.yy.c: can't alloc sp for SYM_IDENT." );
		  }
		  strcpy( sp, yytext );
		  rm_tokval.v_type = T_STRING;
		  rm_tokval.v_value.v_pval = sp;
		  return( SYM_IDENT );
		}
[0-9]+		{ rm_tokval.v_type = T_INT;
		  rm_tokval.v_value.v_ival = atoi( yytext );
		  return( SYM_INT );
		}
([0-9]+[eE][\+\-]?[0-9]+)|((([0-9]+\.[0-9]*)|(\.[0-9]+))([eE][\+\-]?[0-9]+)?) {
		  rm_tokval.v_type = T_FLOAT;
		  rm_tokval.v_value.v_fval = atof( yytext );
		  return( SYM_FLOAT );
		}
\"[^"\n]*	{ if( yytext[ yyleng - 1 ] == '\\' )
			yymore();
		  else{
			yytext[ yyleng++ ] = input();
			yytext[ yyleng ] = '\0';
			sp = ( char * )malloc( ( yyleng - 1 )*sizeof( char ) );
			if( sp == NULL ){
				RM_errormsg( 1,
				"lex.yy.c: can't alloc sp for SYM_STRING." );
			}
			strncpy( sp, &yytext[1], yyleng - 2 );
			sp[ yyleng - 2 ] = '\0';
			rm_tokval.v_type = T_STRING;
/*
			rm_tokval.v_value.v_pval = sp;
*/
			rm_tokval.v_value.v_pval = RM_str2seq( sp );
			return( SYM_STRING );
		  }
		}
\'[^'\n]*	{ if( yytext[ yyleng - 1 ] == '\\' )
			yymore();
		  else{
			yytext[ yyleng++ ] = input();
			yytext[ yyleng ] = '\0';
			sp = ( char * )malloc( ( yyleng - 1 )*sizeof( char ) );
			if( sp == NULL ){
				RM_errormsg( 1,
				"lex.yy.c: can't alloc sp for SYM_STRING." );
			}
			strncpy( sp, &yytext[1], yyleng - 2 );
			sp[ yyleng - 2 ] = '\0';
			rm_tokval.v_type = T_STRING;
			rm_tokval.v_value.v_pval = sp;
			return( SYM_STRING );
		  }
		}

&&		return( SYM_AND );
=		return( SYM_ASSIGN );
\$		{ posp = ( POS_T * )malloc( sizeof( POS_T ) );
		  if( posp == NULL ){
			RM_errormsg( 1,
				"lex.yy.c: can't alloc posp for SYM_DOLLAR." );
		  }
		  posp->p_type = SYM_DOLLAR;
		  posp->p_lineno = rm_lineno;
		  posp->p_tag = NULL;
		  posp->p_addr.a_l2r = 0;
		  posp->p_addr.a_offset = 0;
		  rm_tokval.v_type = T_POS;
		  rm_tokval.v_value.v_pval = posp;
		  return( SYM_DOLLAR );
		}
!~		return( SYM_DONT_MATCH );
==		return( SYM_EQUAL );
\>		return( SYM_GREATER );
\>=		return( SYM_GREATER_EQUAL );
\<		return( SYM_LESS );
\<=		return( SYM_LESS_EQUAL );
=~		return( SYM_MATCH );
\-		return( SYM_MINUS );
\-=		return( SYM_MINUS_ASSIGN );
\-\-		return( SYM_MINUS_MINUS );
!		return( SYM_NOT );
!=		return( SYM_NOT_EQUAL );
\|\|		return( SYM_OR );
%		return( SYM_PERCENT );
%=		return( SYM_PERCENT_ASSIGN );
\+		return( SYM_PLUS );
\+=		return( SYM_PLUS_ASSIGN );
\+\+		return( SYM_PLUS_PLUS );
\*		return( SYM_STAR );
\*=		return( SYM_STAR_ASSIGN );
\/		return( SYM_SLASH );
\/=		return( SYM_SLASH_ASSIGN );

\(		return( SYM_LPAREN );
\)		return( SYM_RPAREN );
\[		return( SYM_LBRACK );
\]		return( SYM_RBRACK );
\{		return( SYM_LCURLY );
\}		return( SYM_RCURLY );
\,		return( SYM_COMMA );
:		return( SYM_COLON );
;		return( SYM_SEMICOLON );

.		return( SYM_ERROR );

%%

int	yywrap()
{

	return( 1 );
}
@


1.26
log
@added '' strings which are uninterpreted.  Added call to RM_str2seq()
in "" string as these strings must be converted IUPAC sequences.
@
text
@d150 2
@


1.25
log
@added new res. word 'se' which is any structure element for use in the
score section.
@
text
@d6 1
d72 20
@


1.24
log
@changed refs to errormsg to RM_errormsg().
@
text
@d26 1
@


1.23
log
@added patters for break & continue.
@
text
@d52 1
a52 1
			errormsg( 1, 
d76 1
a76 1
				errormsg( 1,
d91 1
a91 1
			errormsg( 1,
@


1.22
log
@added patterns for the symbols to be used in the score section.
@
text
@d41 2
@


1.21
log
@added pattern for floating pt numbers (period and/or e fmt)
@
text
@d24 2
d39 8
d85 1
a86 4
\+=		return( SYM_PLUS_ASSIGN );
\-=		return( SYM_MINUS_ASSIGN );
\+		return( SYM_PLUS );
\-		return( SYM_MINUS );
d101 23
d130 1
@


1.20
log
@replace p_l2r & p_offset with p_addr.a_l2r & p_addr.a_offset.
@
text
@d52 5
@


1.19
log
@converted fprintf( stderr error messages into calls to errormsg().
SYM_DOLLAR now creates a value of type T_POS.
@
text
@d83 2
a84 2
		  posp->p_l2r = 0;
		  posp->p_offset = 0;
@


1.18
log
@change name of rmlineno & rmval to rm_lineno & rm_tokval.
@
text
@d10 1
d40 2
a41 3
			fprintf( stderr,
		"lex.yy.c: FATAL: can't alloc sp for SYM_IDENT.\n" );
			exit( 1 );
d59 2
a60 3
				fprintf( stderr,
			"lex.yy.c: FATAL: can't alloc sp for SYM_STRING.\n" );
				exit( 1 );
d75 14
a88 1
\$		return( SYM_DOLLAR );
@


1.17
log
@moved rmval to compile; changed name of rm_lineno to rmlineno & moved it
compile.c
@
text
@d7 2
a8 2
extern	int	rmlineno;
extern	VALUE_T	rmval;
d16 1
a16 1
\n		rmlineno++;
d44 2
a45 2
		  rmval.v_type = T_STRING;
		  rmval.v_value.v_pval = sp;
d48 2
a49 2
[0-9]+		{ rmval.v_type = T_INT;
		  rmval.v_value.v_ival = atoi( yytext );
d65 2
a66 2
			rmval.v_type = T_STRING;
			rmval.v_value.v_pval = sp;
@


1.16
log
@put { for INT on the same line as the pattern, as the \ continue didn't
work for linux
@
text
@d7 2
a8 2
int	rmlineno = 1;
VALUE_T	rmval;
@


1.15
log
@split white space into white + newlines; accum. newlines in rmlineno.
@
text
@d36 2
a37 2
[a-zA-Z][_a-zA-Z0-9]*	\
		{ sp = ( char * )malloc(( yyleng + 1 ) *sizeof( char ));
@


1.14
log
@changed (again) EQUAL to ASSIGN.
@
text
@d7 1
d16 3
a18 1
[\ \t\f\n]+	;
@


1.13
log
@combine all pointers in VALUE_T into void* v_pval
@
text
@d68 3
a70 3
=		return( SYM_EQUAL );
\+=		return( SYM_PLUS_EQUAL );
\-=		return( SYM_MINUS_EQUAL );
@


1.12
log
@changed rws parm, site to parms, sites.
@
text
@d42 1
a42 1
		  rmval.v_value.v_cval = sp;
d63 1
a63 1
			rmval.v_value.v_cval = sp;
@


1.11
log
@removed pattern \. as period was no longer used.
@
text
@d17 1
a17 1
parm		return( SYM_PARM );
d19 1
a19 1
site		return( SYM_SITE );
@


1.10
log
@change rmval to hold the `type' of the value vs the symbol that is
associated with.
@
text
@a77 1
\.		return( SYM_PERIOD );
@


1.9
log
@removed 3 former reserved words: pair, mismatch, mispair.
@
text
@d41 1
a41 1
		  rmval.v_sym = SYM_IDENT;
d45 1
a45 1
[0-9]+		{ rmval.v_sym = SYM_INT;
d62 1
a62 1
			rmval.v_sym = SYM_STRING;
@


1.8
log
@added new tokens +=, -= & +; reordered the rules.
@
text
@a16 1
pair		return( SYM_PAIR );
a18 2
mismatch	return( SYM_MISMATCH );
mispair		return( SYM_MISPAIR );
@


1.7
log
@rmval now contains a v_sym which contains the current symbol.  Some
symbols: SYM_INT, SYM_STRING & SYM_IDENT have values of type v_ival,
v_cval & v_cval resp.  Other symbols (now at least) do not have associated
values.
@
text
@d72 5
d81 1
a82 3
\-		return( SYM_MINUS );
\$		return( SYM_DOLLAR );
\.		return( SYM_PERIOD );
@


1.6
log
@removed debug message.
@
text
@d44 1
a44 1
		  rmval.v_type = T_STRING;
d48 1
a48 1
[0-9]+		{ rmval.v_type = T_INT;
d65 1
a65 1
			rmval.v_type = T_STRING;
@


1.5
log
@copy yytext for string/ident into rmval.  die if string space can't
be allocated.
@
text
@a66 1
fprintf( stderr, "STRING = '%s'\n", sp );
@


1.4
log
@save the value of literals in rmval.
@
text
@d8 1
d36 12
a47 1
[a-zA-Z][_a-zA-Z0-9]*	return( SYM_IDENT );
d55 1
a55 1
			yytext[ yyleng ] = input();
d57 8
a64 2
			strcpy( yytext, &yytext[ 1 ] );
			yyleng = strlen( yytext );
d66 2
a67 1
			rmval.v_value.v_cval = yytext;
@


1.3
log
@working version.  shortened kws;
@
text
@d2 2
d5 4
d36 4
a39 1
[0-9]+		return( SYM_INT );
d46 3
@


1.2
log
@added reserved words covering the structure of the input: pairings,
parameters, descriptor, positions, and mismatch, mispair, pair.
include y.tab.h now.
@
text
@d10 3
a12 3
pairings	return( SYM_PAIRINGS );
parameters	return( SYM_PARAMETERS );
descriptor	return( SYM_DESCRIPTOR );
d15 13
a27 13
positions	return( SYM_POSITIONS );
ss		return( SYM_SINGLE );
h5		return( SYM_HELIX5 );
h3		return( SYM_HELIX3 );
p5		return( SYM_PARALLEL5 );
p3		return( SYM_PARALLEL3 );
t1		reteun( SYM_TRIPLEX1 );
t2		reteun( SYM_TRIPLEX2 );
t3		reteun( SYM_TRIPLEX3 );
q1		reteun( SYM_QUAD1 );
q2		reteun( SYM_QUAD2 );
q3		reteun( SYM_QUAD3 );
q4		reteun( SYM_QUAD4 );
@


1.1
log
@Initial revision
@
text
@d1 3
d10 6
d41 1
d44 2
d49 1
@
