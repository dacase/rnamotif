head	1.104;
access;
symbols;
locks; strict;
comment	@ * @;


1.104
date	2001.07.31.17.12.45;	author macke;	state Exp;
branches;
next	1.103;

1.103
date	2001.07.30.20.59.31;	author macke;	state Exp;
branches;
next	1.102;

1.102
date	2001.07.30.20.04.07;	author macke;	state Exp;
branches;
next	1.101;

1.101
date	2001.02.07.19.30.37;	author macke;	state Exp;
branches;
next	1.100;

1.100
date	2000.11.27.18.30.44;	author macke;	state Exp;
branches;
next	1.99;

1.99
date	2000.11.27.00.18.51;	author macke;	state Exp;
branches;
next	1.98;

1.98
date	2000.10.07.18.37.27;	author macke;	state Exp;
branches;
next	1.97;

1.97
date	2000.10.07.15.59.49;	author macke;	state Exp;
branches;
next	1.96;

1.96
date	2000.10.07.05.57.04;	author macke;	state Exp;
branches;
next	1.95;

1.95
date	2000.09.04.22.35.51;	author macke;	state Exp;
branches;
next	1.94;

1.94
date	2000.09.04.22.28.26;	author macke;	state Exp;
branches;
next	1.93;

1.93
date	2000.06.13.17.53.51;	author macke;	state Exp;
branches;
next	1.92;

1.92
date	2000.04.27.21.20.16;	author macke;	state Exp;
branches;
next	1.91;

1.91
date	2000.04.25.00.19.44;	author macke;	state Exp;
branches;
next	1.90;

1.90
date	2000.04.24.01.20.27;	author macke;	state Exp;
branches;
next	1.89;

1.89
date	2000.03.20.06.04.12;	author macke;	state Exp;
branches;
next	1.88;

1.88
date	2000.03.20.05.16.15;	author macke;	state Exp;
branches;
next	1.87;

1.87
date	2000.03.18.21.48.43;	author macke;	state Exp;
branches;
next	1.86;

1.86
date	2000.03.17.23.32.11;	author macke;	state Exp;
branches;
next	1.85;

1.85
date	2000.03.03.19.46.26;	author macke;	state Exp;
branches;
next	1.84;

1.84
date	2000.02.10.00.12.29;	author macke;	state Exp;
branches;
next	1.83;

1.83
date	99.11.07.23.40.24;	author macke;	state Exp;
branches;
next	1.82;

1.82
date	99.10.31.01.20.07;	author macke;	state Exp;
branches;
next	1.81;

1.81
date	99.10.22.18.19.06;	author macke;	state Exp;
branches;
next	1.80;

1.80
date	99.10.18.19.52.05;	author macke;	state Exp;
branches;
next	1.79;

1.79
date	99.10.08.17.57.39;	author macke;	state Exp;
branches;
next	1.78;

1.78
date	99.10.06.00.36.32;	author macke;	state Exp;
branches;
next	1.77;

1.77
date	99.10.03.19.03.07;	author macke;	state Exp;
branches;
next	1.76;

1.76
date	99.10.03.18.16.37;	author macke;	state Exp;
branches;
next	1.75;

1.75
date	99.09.30.18.55.39;	author macke;	state Exp;
branches;
next	1.74;

1.74
date	99.09.24.02.02.41;	author macke;	state Exp;
branches;
next	1.73;

1.73
date	99.09.16.22.51.00;	author macke;	state Exp;
branches;
next	1.72;

1.72
date	99.09.10.17.10.15;	author macke;	state Exp;
branches;
next	1.71;

1.71
date	99.09.03.18.22.31;	author macke;	state Exp;
branches;
next	1.70;

1.70
date	99.08.28.04.03.26;	author macke;	state Exp;
branches;
next	1.69;

1.69
date	99.08.27.19.12.02;	author macke;	state Exp;
branches;
next	1.68;

1.68
date	99.08.21.03.39.38;	author macke;	state Exp;
branches;
next	1.67;

1.67
date	99.08.20.15.50.32;	author macke;	state Exp;
branches;
next	1.66;

1.66
date	99.08.02.22.40.03;	author macke;	state Exp;
branches;
next	1.65;

1.65
date	99.08.02.22.21.50;	author macke;	state Exp;
branches;
next	1.64;

1.64
date	99.07.26.22.55.12;	author macke;	state Exp;
branches;
next	1.63;

1.63
date	99.07.14.21.10.29;	author macke;	state Exp;
branches;
next	1.62;

1.62
date	99.07.10.23.24.34;	author macke;	state Exp;
branches;
next	1.61;

1.61
date	99.07.08.01.37.57;	author macke;	state Exp;
branches;
next	1.60;

1.60
date	99.07.06.19.50.44;	author macke;	state Exp;
branches;
next	1.59;

1.59
date	99.07.06.19.39.56;	author macke;	state Exp;
branches;
next	1.58;

1.58
date	99.07.06.01.33.40;	author macke;	state Exp;
branches;
next	1.57;

1.57
date	99.07.06.01.23.48;	author macke;	state Exp;
branches;
next	1.56;

1.56
date	99.07.06.01.11.14;	author macke;	state Exp;
branches;
next	1.55;

1.55
date	99.07.06.00.54.19;	author macke;	state Exp;
branches;
next	1.54;

1.54
date	99.07.01.05.51.36;	author macke;	state Exp;
branches;
next	1.53;

1.53
date	99.06.30.21.46.42;	author macke;	state Exp;
branches;
next	1.52;

1.52
date	99.06.30.18.04.11;	author macke;	state Exp;
branches;
next	1.51;

1.51
date	99.06.30.00.34.11;	author macke;	state Exp;
branches;
next	1.50;

1.50
date	99.06.29.00.03.53;	author macke;	state Exp;
branches;
next	1.49;

1.49
date	99.06.22.05.48.57;	author macke;	state Exp;
branches;
next	1.48;

1.48
date	99.06.20.01.37.28;	author macke;	state Exp;
branches;
next	1.47;

1.47
date	99.06.19.03.56.47;	author macke;	state Exp;
branches;
next	1.46;

1.46
date	99.06.12.23.45.26;	author macke;	state Exp;
branches;
next	1.45;

1.45
date	99.06.12.17.01.36;	author macke;	state Exp;
branches;
next	1.44;

1.44
date	99.06.11.23.23.34;	author macke;	state Exp;
branches;
next	1.43;

1.43
date	99.06.11.14.16.41;	author macke;	state Exp;
branches;
next	1.42;

1.42
date	99.06.11.00.40.11;	author macke;	state Exp;
branches;
next	1.41;

1.41
date	99.06.10.22.21.22;	author macke;	state Exp;
branches;
next	1.40;

1.40
date	99.06.10.17.01.12;	author macke;	state Exp;
branches;
next	1.39;

1.39
date	99.06.02.17.15.29;	author macke;	state Exp;
branches;
next	1.38;

1.38
date	99.05.31.14.36.24;	author macke;	state Exp;
branches;
next	1.37;

1.37
date	99.05.27.20.36.38;	author macke;	state Exp;
branches;
next	1.36;

1.36
date	99.05.25.17.36.39;	author macke;	state Exp;
branches;
next	1.35;

1.35
date	99.05.25.03.32.02;	author macke;	state Exp;
branches;
next	1.34;

1.34
date	99.05.25.03.17.43;	author macke;	state Exp;
branches;
next	1.33;

1.33
date	99.05.23.21.12.06;	author macke;	state Exp;
branches;
next	1.32;

1.32
date	99.05.12.20.34.38;	author macke;	state Exp;
branches;
next	1.31;

1.31
date	99.05.11.20.07.18;	author macke;	state Exp;
branches;
next	1.30;

1.30
date	99.05.11.05.21.41;	author macke;	state Exp;
branches;
next	1.29;

1.29
date	99.05.11.04.51.26;	author macke;	state Exp;
branches;
next	1.28;

1.28
date	99.05.11.02.57.33;	author macke;	state Exp;
branches;
next	1.27;

1.27
date	99.05.11.01.48.26;	author macke;	state Exp;
branches;
next	1.26;

1.26
date	99.05.11.01.30.19;	author macke;	state Exp;
branches;
next	1.25;

1.25
date	99.05.10.05.22.55;	author macke;	state Exp;
branches;
next	1.24;

1.24
date	99.05.08.20.11.11;	author macke;	state Exp;
branches;
next	1.23;

1.23
date	99.05.08.04.58.57;	author macke;	state Exp;
branches;
next	1.22;

1.22
date	99.05.04.03.27.55;	author macke;	state Exp;
branches;
next	1.21;

1.21
date	99.05.01.06.16.48;	author macke;	state Exp;
branches;
next	1.20;

1.20
date	99.04.30.00.14.04;	author macke;	state Exp;
branches;
next	1.19;

1.19
date	99.04.29.16.05.41;	author macke;	state Exp;
branches;
next	1.18;

1.18
date	99.04.29.03.39.23;	author macke;	state Exp;
branches;
next	1.17;

1.17
date	99.04.19.02.07.18;	author macke;	state Exp;
branches;
next	1.16;

1.16
date	99.04.05.01.08.15;	author macke;	state Exp;
branches;
next	1.15;

1.15
date	99.04.05.00.50.50;	author macke;	state Exp;
branches;
next	1.14;

1.14
date	99.04.05.00.45.25;	author macke;	state Exp;
branches;
next	1.13;

1.13
date	99.04.05.00.38.21;	author macke;	state Exp;
branches;
next	1.12;

1.12
date	99.04.05.00.18.23;	author macke;	state Exp;
branches;
next	1.11;

1.11
date	99.03.31.06.41.54;	author macke;	state Exp;
branches;
next	1.10;

1.10
date	99.03.31.06.32.48;	author macke;	state Exp;
branches;
next	1.9;

1.9
date	99.03.30.16.17.40;	author macke;	state Exp;
branches;
next	1.8;

1.8
date	99.03.27.02.32.07;	author macke;	state Exp;
branches;
next	1.7;

1.7
date	99.03.25.06.13.39;	author macke;	state Exp;
branches;
next	1.6;

1.6
date	99.03.14.20.51.43;	author macke;	state Exp;
branches;
next	1.5;

1.5
date	99.02.28.04.06.37;	author macke;	state Exp;
branches;
next	1.4;

1.4
date	99.02.22.23.27.26;	author macke;	state Exp;
branches;
next	1.3;

1.3
date	99.02.06.21.21.44;	author macke;	state Exp;
branches;
next	1.2;

1.2
date	99.02.03.05.44.08;	author macke;	state Exp;
branches;
next	1.1;

1.1
date	99.01.29.20.49.05;	author macke;	state Exp;
branches;
next	;


desc
@this is it -- the actual search code that looks for the motifs.  Suddenly
realized that the only way I have to access GB is via irefs & the file
map.  Need to fix this.
@


1.104
log
@added code to set_context() to check minlen and/or seq (if set in the
descriptor.)
@
text
@#include <stdio.h>
#include <string.h>
#include <math.h>
#include "rnamot.h"
#include "y.tab.h"

#define	MIN(a,b)	((a)<(b)?(a):(b))
#define	MAX(a,b)	((a)>(b)?(a):(b))
#define	ODD(i)		((i)&0x1)
#define	EPS		1e-6

extern	int	rm_emsg_lineno;
extern	STREL_T	rm_descr[];
extern	int	rm_n_descr;
extern	STREL_T	*rm_lctx;
extern	int	rm_lctx_explicit;
extern	STREL_T	*rm_rctx;
extern	int	rm_rctx_explicit;
extern	int	rm_dminlen;
extern	int	rm_dmaxlen;
extern	SITE_T	*rm_sites;
extern	int	rm_b2bc[];

extern	SEARCH_T	**rm_searches;

extern	VALUE_T	*rm_sval;

extern	int	circf;	/* reg. exp. ^ kludge	*/

static	char	fm_emsg[ 256 ];
static	char	*fm_sid;
static	char	*fm_sdef;
static	int	fm_comp;
static	int	fm_slen;
static	char	*fm_sbuf;
static	int	*fm_winbuf;	/* windowsize + 2, 1 before, 1 after	*/
static	int	*fm_window;	/* fm_winbuf[1]				*/
static	int	fm_windowsize;
static	int	fm_szero;
static	char	*fm_chk_seq;

IDENT_T	*RM_find_id( char [] );

int	RM_paired( PAIRSET_T *, int, int );
int	RM_triple( PAIRSET_T *, int, int, int );
int	RM_quad( PAIRSET_T *, int, int, int, int );

static	int	find_motif( SEARCH_T * );
static	int	find_1_motif( SEARCH_T * );
static	int	find_ss( SEARCH_T * );
static	int	find_wchlx( SEARCH_T * );
static	int	find_pknot( SEARCH_T * );
static	int	find_pknot5( SEARCH_T * );
static	int	find_pknot3( SEARCH_T *, int );
static	int	find_minlen( int, int );
static	int	find_maxlen( int, int );
static	void	upd_pksearches( STREL_T *, int, int, int );
static	int	find_phlx( SEARCH_T * );
static	int	find_triplex( SEARCH_T * );
static	int	find_4plex( SEARCH_T * );
static	int	find_4plex_inner( SEARCH_T *, int, int );
static	int	match_wchlx( STREL_T *, STREL_T *, int, int, int,
			int [], int [], int [] );
static	int	match_phlx( STREL_T *, STREL_T *,
			int, int, int, int, int *, int * );
static	int	match_triplex( STREL_T *, STREL_T *,
			int, int, int, int, int * );
static	int	match_4plex( STREL_T *, STREL_T *,
			int, int, int, int, int, int * );
static	void	mark_ss( STREL_T *, int, int );
static	void	unmark_ss( STREL_T *, int, int );
static	void	mark_duplex( STREL_T *, int, STREL_T *, int, int );
static	void	unmark_duplex( STREL_T *, int, STREL_T *, int, int );
static	int	chk_wchlx0( SEARCH_T *, int, int );
static	int	chk_motif( int, STREL_T [], SITE_T * );
static	int	chk_wchlx( STREL_T *, int, STREL_T [] );
static	int	chk_phlx( STREL_T *, int, STREL_T [] );
static	int	chk_triplex( STREL_T *, int, STREL_T [] );
static	int	chk_4plex( STREL_T *, int, STREL_T [] );
static	int	set_context( int, STREL_T [] );
static	int	chk_sites( int, STREL_T [], SITE_T * );
static	int	chk_1_site( int, STREL_T *, SITE_T * );
static	int	chk_seq( STREL_T *, char [], int );

static	void	print_match( FILE *, char [], int, int, STREL_T [] );
static	void	mk_cstr( char [], char [] );

int	find_motif_driver( int n_searches, SEARCH_T *searches[],
	SITE_T *sites,
	char sid[], char sdef[], int comp, int slen, char sbuf[] )
{
	int	w_winsize;
	int	l_szero;
	IDENT_T	*ip;
	SEARCH_T	*srp;
	int	rv;
	
	if( fm_winbuf == NULL ){
		ip = RM_find_id( "windowsize" );
		if( ip == NULL )
			RM_errormsg( 1,
				"find_motif_driver: windowsize undefined." );
	
			if( ip->i_val.v_value.v_ival <= 0 )
				RM_errormsg( 1,
					"find_motif_driver: windowsize <= 0." );
		else
			fm_windowsize = ip->i_val.v_value.v_ival;
		fm_winbuf = ( int * )malloc( (fm_windowsize+2) * sizeof(int) );
		if( fm_winbuf == NULL )
			RM_errormsg( 1,
				"find_motif_driver: can't allocate fm_winbuf.");
		fm_window = &fm_winbuf[ 1 ];
		fm_chk_seq = ( char * )malloc((fm_windowsize+1) * sizeof(char));
		if( fm_chk_seq == NULL )
			RM_errormsg( 1,
			"find_motif_driver: can't allocate fm_chk_seq." );
	}

	fm_sid = sid;
	fm_sdef = sdef;
	fm_comp = comp;
	fm_slen = slen;
	fm_sbuf = sbuf;

	w_winsize = rm_dmaxlen < fm_windowsize ? rm_dmaxlen : fm_windowsize;

	srp = searches[ 0 ];
	l_szero = slen - w_winsize;
	for( rv = 0, fm_szero = 0; fm_szero < l_szero; fm_szero++ ){
		srp->s_zero = fm_szero;
		srp->s_dollar = fm_szero + w_winsize - 1;
		fm_window[ srp->s_zero - 1 - fm_szero ] = UNDEF;
		fm_window[ srp->s_dollar + 1 - fm_szero ] = UNDEF;
		rv |= find_motif( srp );
	}

	l_szero = slen - rm_dminlen;
	srp->s_dollar = slen - 1;
	for( ; fm_szero <= l_szero; fm_szero++ ){
		srp->s_zero = fm_szero;
		rv |= find_motif( srp );
	}
	return( rv );
}

static	int	find_motif( SEARCH_T *srp )
{
	STREL_T	*stp;
	SEARCH_T	*n_srp;
	int	sdollar, o_sdollar, f_sdollar, l_sdollar; 
	int	rv, loop;

	rv = 0;
	stp = srp->s_descr;

	if( stp->s_next != NULL ){
		n_srp = rm_searches[ stp->s_next->s_searchno ]; 
		loop = 1;
	}else if( stp->s_outer == NULL ){
		n_srp = NULL;
		loop = 1;
	}else{	/* last element of an inner chain.	*/
		n_srp = NULL;
		loop = 0;
	}

	o_sdollar = srp->s_dollar;

	f_sdollar = MIN( srp->s_dollar, srp->s_zero + stp->s_maxglen - 1 );
	l_sdollar = srp->s_zero + stp->s_minglen - 1;

	if( loop ){
		rv = 0;
		for( sdollar = f_sdollar; sdollar >= l_sdollar; sdollar-- ){
			srp->s_dollar = sdollar;
			if( n_srp != NULL ){
				n_srp->s_zero = sdollar + 1;
				n_srp->s_dollar = o_sdollar;
			}
			rv |= find_1_motif( srp );
		}
	}else
		rv = find_1_motif( srp );

	srp->s_dollar = o_sdollar;

	return( rv );
}

static	int	find_1_motif( SEARCH_T *srp )
{
	STREL_T	*stp;
	int	rv;

	stp = srp->s_descr;
	switch( stp->s_type ){
	case SYM_SS :
		rv = find_ss( srp );
		break;
	case SYM_H5 :
		if( stp->s_attr & SA_PROPER )
			rv = find_wchlx( srp );
		else
			rv = find_pknot( srp );
		break;
	case SYM_P5 :
		rv = find_phlx( srp );
		break;
	case SYM_T1 :
		rv = find_triplex( srp );
		break;
	case SYM_Q1 :
		rv = find_4plex( srp );
		break;
	case SYM_H3 :
	case SYM_P3 :
	case SYM_T2 :
	case SYM_T3 :
	case SYM_Q2 :
	case SYM_Q3 :
	case SYM_Q4 :
	default :
		rv = 0;
		rm_emsg_lineno = stp->s_lineno;
		sprintf( fm_emsg, "find_motif: illegal symbol %d.",
			stp->s_type );
		RM_errormsg( 1, fm_emsg );
		break;
	}

	return( rv );
}

static	int	find_ss( SEARCH_T *srp )
{
	STREL_T	*stp;
	int	slen, szero, sdollar;
	STREL_T	*n_stp;
	SEARCH_T	*n_srp;
	int	rv;

	stp = srp->s_descr;
	stp->s_n_mismatches = 0;
	stp->s_n_mispairs = 0;
	szero = srp->s_zero;
	sdollar = srp->s_dollar;
	slen = sdollar - szero + 1;

	if( slen < stp->s_minlen || slen > stp->s_maxlen )
		return( 0 );

	if( stp->s_seq != NULL ){
		if( !chk_seq( stp, &fm_sbuf[ szero ], slen ) )
			return( 0 );
	}

	mark_ss( stp, szero, slen);
	n_stp = srp->s_forward;
	if( n_stp != NULL ){
		n_srp = rm_searches[ n_stp->s_searchno ];
		rv = find_motif( n_srp );
	}else{
		rv = 1;
		if( !set_context( rm_n_descr, rm_descr ) ){
			rv = 0;
		}else if( !chk_sites( rm_n_descr, rm_descr, rm_sites ) ){
			rv = 0;
		}else if( RM_score( fm_comp, fm_slen, fm_sbuf ) )
			print_match( stdout,
				fm_sid, fm_comp, rm_n_descr, rm_descr );
/*
		if( chk_motif( rm_n_descr, rm_descr, rm_sites ) ){
			rv = 1;
			print_match( stdout, fm_sid, fm_comp,
				rm_n_descr, rm_descr );
		}else
			rv = 0;
*/
	}
	unmark_ss( stp, szero, slen );
	return( rv );
}

static	int	find_wchlx( SEARCH_T *srp )
{
	STREL_T	*stp, *stp3;
	int	s3lim, szero, sdollar;
	int	h_maxl;
	int	i_minl, i_maxl, i_len;
	int	h3[ 101 ], hlen[ 101 ], n_mpr[ 101 ];
	int	h, n_h3;
	STREL_T	*i_stp;
	SEARCH_T	*i_srp;
	int	rv;

	szero = srp->s_zero;
	sdollar = srp->s_dollar;

	stp = srp->s_descr;
	stp->s_n_mismatches = 0;
	stp->s_n_mispairs = 0;
	stp3 = stp->s_mates[ 0 ];
	stp3->s_n_mismatches = 0;
	stp3->s_n_mispairs = 0;

	h_maxl = stp->s_maxlen;
	i_minl = stp->s_minilen;
	i_maxl = stp->s_maxilen;

	s3lim = sdollar - szero + 1;
	s3lim = ( s3lim - i_minl ) / 2;
	s3lim = MIN( s3lim, h_maxl );
	s3lim = sdollar - s3lim + 1;

	rv = 0;

	if(n_h3=match_wchlx(stp,stp3,szero,sdollar,s3lim,h3,hlen,n_mpr )){

		for( h = 0; h < n_h3; h++ ){
/*
			if( !chk_wchlx0( srp, szero, h3[h] ) )
				return( 0 );
*/

			i_len = h3[h] - szero - 2 * hlen[h] + 1;
/*
			if( i_len > i_maxl )
				return( 0 );
*/
			if( i_len > i_maxl )
				continue;

			stp->s_n_mispairs = n_mpr[h];
			stp3->s_n_mispairs = n_mpr[h];
			mark_duplex( stp, szero, stp3, h3[h], hlen[h] );

			i_stp = stp->s_inner;
			i_srp = rm_searches[ i_stp->s_searchno ];
			i_srp->s_zero = szero + hlen[h];
			i_srp->s_dollar = h3[h] - hlen[h];

			rv |= find_motif( i_srp );
			unmark_duplex( stp, szero, stp3, h3[h], hlen[h] );
		}
	}
	return( rv );
}

static	int	find_pknot( SEARCH_T *srp )
{
	STREL_T	*stp, *stp1;
	int	szero, sdollar;
	int	s;
	SEARCH_T	*srp1;
	int	rv = 0;

	szero = srp->s_zero;
	sdollar = srp->s_dollar;
	stp = srp->s_descr;

	if( stp->s_scope == 0 ){ 
		for( s = 1; s < stp->s_n_scopes; s++ ){
			stp1 = stp->s_scopes[ s ];
			if( stp1->s_type == SYM_H5 ){
				stp1->s_matchoff = UNDEF;
				stp1->s_matchlen = UNDEF;
				srp1 = rm_searches[ stp1->s_searchno ];
				srp1->s_zero = szero;
				srp1->s_dollar = sdollar;
			}
		}
	}

	rv = find_pknot5( srp );

	return( rv );
}

static	int	find_pknot5( SEARCH_T *srp )
{
	STREL_T	*stp0, *stp5, *stpn;
	int	szero, sdollar, slen;
	int	p_minl, p_maxl;
	int	r_minl, r_maxl;
	int	s5, f_s5, l_s5;
	int	rv = 0;

	szero = srp->s_zero;
	sdollar = srp->s_dollar;
	slen = sdollar - szero + 1;
	stp5 = srp->s_descr;

	stp0 = stp5->s_scopes[ 0 ];
	stpn = stp5->s_scopes[ stp5->s_n_scopes - 1 ];

	p_minl = find_minlen( stp0->s_index, stp5->s_index - 1 );
	p_maxl = find_maxlen( stp0->s_index, stp5->s_index - 1 );

	r_minl = find_minlen( stp5->s_index, stpn->s_index );
	r_maxl = find_maxlen( stp5->s_index, stpn->s_index );

	if( p_maxl + r_maxl < slen )
		return( 0 );

	f_s5 = szero + p_minl;
	l_s5 = szero + MIN( p_maxl, slen - r_minl );

	for( rv = 0, s5 = f_s5; s5 <= l_s5; s5++ )
		rv |= find_pknot3( srp, s5 );

	return( rv );
}

static	int	find_pknot3( SEARCH_T *srp, int s5 )
{
	STREL_T	*stp5, *stp3, *stpn;
	int	sdollar, slen;
	int	g_minl;
	int	h_minl, h_maxl;
	int	i_minl;
	int	s_minl, s_maxl;
	int	s3, f_s3, l_s3;
	int	s3lim;
	int	h3[ 101 ], hlen[ 101 ], n_mpr[ 101 ];
	int	h, n_h3;
	SEARCH_T	*n_srp;
	int	rv = 0;

	sdollar = srp->s_dollar;
	slen = sdollar - s5 + 1;
	stp5 = srp->s_descr;

	stp3 = stp5->s_mates[ 0 ];
	stpn = stp5->s_scopes[ stp5->s_n_scopes - 1 ];

	h_minl = stp5->s_minlen;
	h_maxl = stp5->s_maxlen;

	i_minl = find_minlen( stp5->s_index + 1, stp3->s_index - 1 );

	g_minl = 2*h_minl + i_minl;

	s_minl = find_minlen( stp3->s_index + 1, stpn->s_index );
	s_maxl = find_maxlen( stp3->s_index + 1, stpn->s_index );

	if( g_minl + s_minl > slen )
		return( 0 );

	f_s3 = sdollar - s_minl;
	l_s3 = sdollar - MIN( slen - g_minl, s_maxl );

	for( rv = 0, s3 = f_s3; s3 >= l_s3; s3-- ){
		s3lim = s3 - s5 + 1;
		s3lim = ( s3lim - i_minl ) / 2;
		s3lim = MIN( s3lim, h_maxl );
		s3lim = s3 - s3lim + 1;

		if( n_h3=match_wchlx( stp5,stp3,s5,s3,s3lim,h3,hlen,n_mpr )){
			for( h = 0; h < n_h3; h++ ){
				stp5->s_n_mispairs = n_mpr[h];
				stp3->s_n_mispairs = n_mpr[h];
				mark_duplex( stp5, s5, stp3, h3[h], hlen[h] );
				upd_pksearches( stp5, s5, h3[h], hlen[h] );
				n_srp = rm_searches[ stp5->s_searchno + 1 ];
				rv |= find_motif( n_srp );
				unmark_duplex( stp5, s5, stp3, h3[h], hlen[h] );
			}
		}
	}
	
	return( rv );
}

static	int	find_minlen( int fd, int ld )
{
	STREL_T	*stp;
	int	minl, d;

	stp = &rm_descr[ fd ];
	for( minl = 0, d = fd; d <= ld; d++, stp++ ){
		minl += ( stp->s_matchlen != UNDEF ) ?
			stp->s_matchlen : stp->s_minlen;
	}
	return( minl );
}

static	int	find_maxlen( int fd, int ld )
{
	STREL_T	*stp;
	int	maxl, d;

	stp = &rm_descr[ fd ];
	for( maxl = 0, d = fd; d <= ld; d++, stp++ )
		maxl += ( stp->s_matchlen != UNDEF ) ?
			stp->s_matchlen : stp->s_maxlen;
	return( maxl );
}

static	void	upd_pksearches( STREL_T *stp, int h5, int h3, int hlen )
{
	STREL_T	*stp3, *i_stp;
	SEARCH_T	*i_srp;
	
	if( stp->s_scope > 0 ){
		i_stp = stp->s_scopes[ stp->s_scope - 1 ];
		i_stp = i_stp->s_inner;
		if( i_stp != NULL ){
			i_srp = rm_searches[ i_stp->s_searchno ];
			i_srp->s_dollar = h5 - 1;
		}
	}
	i_stp = stp->s_inner;
	if( i_stp != NULL ){
		i_srp = rm_searches[ i_stp->s_searchno ];
		i_srp->s_zero = h5 + hlen;
	}

	stp3 = stp->s_mates[ 0 ];
	i_stp = stp3->s_scopes[ stp3->s_scope - 1 ];
	i_stp = i_stp->s_inner;
	if( i_stp != NULL ){
		i_srp = rm_searches[ i_stp->s_searchno ];
		i_srp->s_dollar = h3 - hlen;
	}

	if( stp3->s_scope < stp3->s_n_scopes - 1 ){
		i_stp = stp3->s_inner;
		if( i_stp != NULL ){
			i_srp = rm_searches[ i_stp->s_searchno ];
			i_srp->s_zero = h3 + 1;
		}
	}
}

static	int	find_phlx( SEARCH_T *srp )
{
	STREL_T	*stp, *stp3, *i_stp;
	int	ilen, slen, szero, sdollar;
	int	s5hi, s5lo;
	int	h_minl, h_maxl;
	int	i_minl, i_maxl, i_len;
	int	hlen, n_mpr;
	SEARCH_T	*i_srp;
	int	rv;

	szero = srp->s_zero;
	sdollar = srp->s_dollar;
	slen = sdollar - szero + 1;
	stp = srp->s_descr;
	stp->s_n_mismatches = 0;
	stp->s_n_mispairs = 0;
	stp3 = stp->s_mates[ 0 ];
	stp3->s_n_mismatches = 0;
	stp3->s_n_mispairs = 0;
	

	h_minl = stp->s_minlen;
	h_maxl = stp->s_maxlen;
	i_minl = stp->s_minilen;
	i_maxl = stp->s_maxilen;

	s5hi = MIN( ( slen - i_minl ) / 2, h_maxl );
	s5hi = szero + s5hi - 1;

	ilen = slen - 2 * h_minl;
	ilen = MIN( ilen, i_maxl );
	s5lo = slen - ilen;
	if( ODD( s5lo ) )
		s5lo++;
	s5lo = MIN( s5lo / 2, h_maxl );
	s5lo = szero + s5lo - 1;

	rv = 0;
	if( match_phlx( stp, stp3, szero, sdollar, s5hi, s5lo, &hlen, &n_mpr )){

		i_len = sdollar - szero - 2 * hlen + 1;
		if( i_len > i_maxl  )
			return( 0 );

		stp->s_n_mispairs = n_mpr;
		stp3->s_n_mispairs = n_mpr;
		mark_duplex( stp, szero, stp3, sdollar, hlen );

		i_stp = stp->s_inner;
		i_srp = rm_searches[ i_stp->s_searchno ];
		i_srp->s_zero = szero + hlen;
		i_srp->s_dollar = sdollar - hlen;

		rv = find_motif( i_srp );
		unmark_duplex( stp, szero, stp3, sdollar, hlen );
	}
	return( rv );
}

static	int	find_triplex( SEARCH_T *srp )
{
	STREL_T	*stp, *stp1, *stp2;
	STREL_T	*i1_stp, *i2_stp;
	int	slen, szero, sdollar;
	int	s, s5hi, s5lo;
	int	h_minl, h_maxl;
	int	i_len;
	int	i1_len, i2_len;
	int	i1_minl, i1_maxl, i2_minl, i2_maxl;
	int	hlen, n_mpr;
	SEARCH_T	*i1_srp, *i2_srp;
	int	rv;

	szero = srp->s_zero;
	sdollar = srp->s_dollar;
	slen = sdollar - szero + 1;
	stp = srp->s_descr;
	stp->s_n_mismatches = 0; 
	stp->s_n_mispairs = 0; 
	stp1 = stp->s_scopes[ 1 ];
	stp1->s_n_mismatches = 0; 
	stp1->s_n_mispairs = 0; 
	stp2 = stp->s_scopes[ 2 ];
	stp2->s_n_mismatches = 0; 
	stp2->s_n_mispairs = 0; 

	h_minl = stp->s_minlen;
	h_maxl = stp->s_maxlen;
	i1_minl = stp->s_minilen;
	i1_maxl = stp->s_maxilen;
	i1_stp = stp->s_inner;
	i1_srp = rm_searches[ i1_stp->s_searchno ];
	i2_minl = stp1->s_minilen;
	i2_maxl = stp1->s_maxilen;
	i2_stp = stp1->s_inner;
	i2_srp = rm_searches[ i2_stp->s_searchno ];

	s5hi = MIN( ( slen - i1_minl - i2_minl ) / 2, h_maxl );
	s5hi = szero + s5hi - 1;

	i_len = slen - 2 * h_minl;
	i_len = MIN( i_len, i1_maxl + h_minl + i2_maxl );
	s5lo = slen - i_len;
	if( ODD( s5lo ) )
		s5lo++;
	s5lo = MIN( s5lo / 2, h_maxl );
	s5lo = szero + s5lo - 1;

	rv = 0;
	if( match_phlx( stp, stp2, szero, sdollar, s5hi, s5lo, &hlen, &n_mpr )){

		i_len = sdollar - szero - 2 * hlen + 1;
		if( i_len > i1_maxl + i2_maxl + hlen )
			return( 0 );

		mark_duplex( stp, szero, stp2, sdollar, hlen );

		for( s=sdollar-i2_minl-hlen; s>=szero+2*hlen+i1_minl-1; s-- ){
			if(match_triplex( stp, stp1, szero, s,
				sdollar, hlen, &n_mpr )){

				i1_len = s - 2 * hlen - szero + 1;
				if( i1_len > i1_maxl )
					continue;
				i2_len = sdollar - hlen - s;
				if( i2_len > i2_maxl )
					continue;

				stp->s_n_mispairs = n_mpr;
				stp1->s_n_mispairs = n_mpr;
				stp2->s_n_mispairs = n_mpr;
				mark_ss( stp1, s - hlen + 1, hlen );

				i1_srp->s_zero = szero + hlen;
				i1_srp->s_dollar = s - hlen;
				i2_srp->s_zero = s + 1;
				i2_srp->s_dollar = sdollar - hlen;

				rv |= find_motif( i1_srp );
				unmark_ss( stp1, s - hlen + 1, hlen );
			}
		}
		unmark_duplex( stp, szero, stp2, sdollar, hlen);
	}
	return( rv );
}

static	int	find_4plex( SEARCH_T *srp )
{
	STREL_T	*stp, *stp1, *stp2, *stp3;
	int	s3lim, szero, sdollar;
	int	h_minl, h_maxl;
	int	i_minl;
	int	i1_minl, i2_minl, i3_minl;
	int	h3[ 101 ], hlen[ 101 ], n_mpr[ 101 ];
	int	h, n_h3;
	int	rv;

	szero = srp->s_zero;
	sdollar = srp->s_dollar;

	stp = srp->s_descr;
	stp->s_n_mismatches = 0;
	stp->s_n_mispairs = 0;
	stp1 = stp->s_mates[ 0 ];
	stp1->s_n_mismatches = 0;
	stp1->s_n_mispairs = 0;
	stp2 = stp->s_mates[ 1 ];
	stp2->s_n_mismatches = 0;
	stp2->s_n_mispairs = 0;
	stp3 = stp->s_mates[ 2 ];
	stp3->s_n_mismatches = 0;
	stp3->s_n_mispairs = 0;

	h_minl = stp->s_minlen;
	h_maxl = stp->s_maxlen;
	i1_minl = stp->s_minilen;
	i2_minl = stp1->s_minilen;
	i3_minl = stp2->s_minilen;

	i_minl = i1_minl + i2_minl + i3_minl + 2 * h_minl;

	s3lim = sdollar - szero + 1;
	s3lim = ( s3lim - i_minl ) / 2;
	s3lim = MIN( s3lim, h_maxl );
	s3lim = sdollar - s3lim + 1;

	rv = 0;
	if(n_h3=match_wchlx(stp,stp3,szero,sdollar,s3lim,h3,hlen,n_mpr)){
		for( h = 0; h < n_h3; h++ ){
			mark_duplex( stp, szero, stp3, h3[h], hlen[h] );
			rv |= find_4plex_inner( srp, h3[h], hlen[h] );
			unmark_duplex( stp, szero, stp3, h3[h], hlen[h] );
		}
	}
	return( rv );
}

static	int	find_4plex_inner( SEARCH_T *srp, int s3, int hlen )
{
	STREL_T	*stp, *stp1, *stp2, *stp3;
	int	szero;
	int	s1, s1lim, s2, s2lim;
	int	i1_minl, i2_minl, i3_minl;
	int	i1_maxl, i2_maxl, i3_maxl;
	int	i1_len, i2_len, i3_len, n_mpr;
	STREL_T	*i1_stp, *i2_stp, *i3_stp;
	SEARCH_T	*i1_srp, *i2_srp, *i3_srp;
	int	rv;

	szero = srp->s_zero;

	stp = srp->s_descr;
	stp1 = stp->s_mates[ 0 ];
	stp2 = stp->s_mates[ 1 ];
	stp3 = stp->s_mates[ 2 ];

	i1_minl = stp->s_minilen;
	i1_maxl = stp->s_maxilen;
	i1_stp = stp->s_inner;
	i1_srp = rm_searches[ i1_stp->s_searchno ];
	
	i2_minl = stp1->s_minilen;
	i2_maxl = stp1->s_maxilen;
	i2_stp = stp1->s_inner;
	i2_srp = rm_searches[ i2_stp->s_searchno ];

	i3_minl = stp2->s_minilen;
	i3_maxl = stp2->s_maxilen;
	i3_stp = stp2->s_inner;
	i3_srp = rm_searches[ i3_stp->s_searchno ]; 

	rv = 0;
	s1lim = s3 - 3 * hlen - i3_minl - i2_minl;
	for( s1 = szero + hlen + i1_minl; s1 <= s1lim; s1++ ){
		s2lim = s1 + 2 * hlen + i2_minl;
		for( s2 = s3 - hlen - i3_minl; s2 >= s2lim; s2-- ){
			if( match_4plex( stp1, stp2,
				szero, s1, s2, s3, hlen, &n_mpr ) ){

				i1_len = s1 - szero - hlen + 1;
				if( i1_len > i1_maxl )
					continue;
				i2_len = s2 - s1 - 2 * hlen + 1;
				if( i2_len > i2_maxl )
					continue;
				i3_len = s3 - s2 - hlen + 1;
				if( i3_len > i3_maxl )
					continue;

				stp->s_n_mispairs = n_mpr;
				stp1->s_n_mispairs = n_mpr;
				stp2->s_n_mispairs = n_mpr;
				stp3->s_n_mispairs = n_mpr;
				mark_duplex( stp1, s1, stp2, s2, hlen );

				i1_srp->s_zero = szero + hlen;
				i1_srp->s_dollar = s1 - 1;
				i2_srp->s_zero = s1 + hlen;
				i2_srp->s_dollar = s2 - hlen;
				i3_srp->s_zero = s2 + 1;
				i3_srp->s_dollar = s3 - hlen;

				rv |= find_motif( i1_srp );
				unmark_duplex( stp1, s1, stp2, s2, hlen );
			}
		}
	}
	return( rv );
}

static	int	match_wchlx( STREL_T *stp, STREL_T *stp3,
	int s5, int s3, int s3lim, int h3[], int hlen[], int n_mpr[] )
{
	int	nh, hl, mpr, l_bpr;
	int	b5, b3;
	int	mplim; 
	int	pfrac;

	nh = 0;
	b5 = fm_sbuf[ s5 ];
	b3 = fm_sbuf[ s3 ];
	if( stp->s_minlen == 0 ){
		hl = 0;
		mpr = 0;
		if( stp->s_seq != NULL ){
			if( !chk_seq( stp, &fm_sbuf[ s5 ], hl ) )
				goto REAL_HELIX;
		}
		if( stp3->s_seq != NULL ){
			if( chk_seq(stp3, &fm_sbuf[s3-hl+1], hl ) ){
				h3[ nh ] = s3;
				hlen[ nh ] = hl;
				n_mpr[ nh ] = mpr;
				nh++;
			}
		}else{
			h3[ nh ] = s3;
			hlen[ nh ] = hl;
			n_mpr[ nh ] = mpr;
			nh++;
		}
	}

REAL_HELIX : ;

	if( RM_paired( stp->s_pairset, b5, b3 ) ){
		hl = 1;
		mpr = 0;
		l_bpr = 1;
	}else if( !( stp->s_attr & SA_5PAIRED ) ){
		hl = 1;
		mpr = 1;
		l_bpr = 0;
	}else if( stp->s_minlen == 0 )
		return( 1 );
	else
		return( 0 );

	if( stp->s_mispair > 0 ){
		mplim = stp->s_mispair;
		pfrac = 0;
	}else if( stp->s_pairfrac < 1.0 ){
		mplim = (1.-stp->s_pairfrac) *
			MIN(stp->s_maxlen, fm_windowsize) + 0.5;
		pfrac = 1;
	}else{
		mplim = 0;
		pfrac = 0;
	}

	if( hl >= stp->s_minlen ){
		if( !l_bpr && ( stp->s_attr & SA_3PAIRED ) )
			goto SKIP;

		if( pfrac ){
			if( 1.*( hl - mpr )/hl < stp->s_pairfrac - EPS )
				goto SKIP;
		}

		if( stp->s_seq != NULL ){
			if( !chk_seq( stp, &fm_sbuf[ s5 ], hl ) )
				goto SKIP;
		}

		if( stp3->s_seq != NULL ){
			if( chk_seq(stp3, &fm_sbuf[s3-hl+1], hl ) ){
				h3[ nh ] = s3;
				hlen[ nh ] = hl;
				n_mpr[ nh ] = mpr;
				nh++;
			}
		}else{
			h3[ nh ] = s3;
			hlen[ nh ] = hl;
			n_mpr[ nh ] = mpr;
			nh++;
		}
	}
SKIP : ;

	for( ; s3 - hl + 1 >= s3lim; ){

		if( hl >= stp->s_maxlen )
			break;

		b5 = fm_sbuf[ s5 + hl ];
		b3 = fm_sbuf[ s3 - hl ];
		if( RM_paired( stp->s_pairset, b5, b3 ) )
			l_bpr = 1;
		else{
			mpr++;
			if( mpr > mplim )
				break;
			l_bpr = 0;
		}
		hl++;
		if( hl >= stp->s_minlen ){
			if( !l_bpr && ( stp->s_attr & SA_3PAIRED ) )
				continue;

			if( pfrac ){	
				if( ( 1.*hl-mpr )/hl < stp->s_pairfrac-EPS )
					continue;
			}

			if( stp->s_seq != NULL ){
				if( !chk_seq( stp, &fm_sbuf[ s5 ], hl ) )
					continue;
			}

			if( stp3->s_seq != NULL ){
				if( chk_seq(stp3, &fm_sbuf[s3-hl+1], hl ) ){
					h3[ nh ] = s3;
					hlen[ nh ] = hl;
					n_mpr[ nh ] = mpr;
					nh++;
				}
			}else{
				h3[ nh ] = s3;
				hlen[ nh ] = hl;
				n_mpr[ nh ] = mpr;
				nh++;
			}
		}
	}

	return( nh );
}

static	int	match_phlx( STREL_T *stp, STREL_T *stp3,
	int s5, int s3, int s5hi, int s5lo, int *hlen, int *n_mpr )
{
	int	s, s1;
	int	b5, b3;
	int	mplim, l_pr;
	int	pfrac;

	mplim = 0;
	pfrac = 0;
	if( stp->s_mispair > 0 )
		mplim = stp->s_mispair;
	else if( stp->s_pairfrac < 1.0 ){
		mplim = (1.-stp->s_pairfrac) * 
			MIN(stp->s_maxlen, fm_windowsize) + 0.5;
		pfrac = 1;
	}

	b3 = fm_sbuf[ s3 ];
	for( s = s5hi; s >= s5lo; s-- ){
		b5 = fm_sbuf[ s ];
		if( RM_paired( stp->s_pairset, b5, b3 ) ){
			*hlen = 1;
			*n_mpr = 0;
			l_pr = 1;
		}else if( !( stp->s_attr & SA_5PAIRED ) ){
			*hlen = 1;
			*n_mpr = 1;
			l_pr = 0;
		}else
			continue;
		for( s1 = s - 1; s1 >= s5; s1-- ){
			b5 = fm_sbuf[ s1 ];
			b3 = fm_sbuf[ s3 - *hlen ];
			if( RM_paired( stp->s_pairset, b5, b3 ) ){
				l_pr = 1;
			}else{
				l_pr = 0;
				( *n_mpr )++;
				if( *n_mpr > mplim ){
					return( 0 );
				}
			}
			( *hlen )++;
		}
		if( !l_pr ){
			if( ( stp->s_attr & SA_3PAIRED ) )
				return( 0 );
		}
		if( *hlen < stp->s_minlen || *hlen > stp->s_maxlen )
			return( 0 );
		if( pfrac ){
			if( 1.*(*hlen-*n_mpr)/(*hlen) < stp->s_pairfrac-EPS )
				return( 0 );
		}

		if( stp->s_seq != NULL ){
			if( !chk_seq( stp, &fm_sbuf[ s5 ], *hlen ) )
				return( 0 );
		}
		if( stp3->s_seq != NULL ){
			if( !chk_seq( stp3, &fm_sbuf[ s3-*hlen+1 ], *hlen ) )
				return( 0 );
		}
		return( 1 );
	}
	return( 0 );
}

static	int	match_triplex( STREL_T *stp, STREL_T *stp1,
	int s1, int s2, int s3, int tlen, int *n_mpr )
{
	int	t;
	int	b1, b2, b3;
	int	mplim, l_pr;

	mplim = 0;
	if( stp->s_mispair > 0 )
		mplim = stp->s_mispair;
	else if( stp->s_pairfrac < 1.0 )
		mplim = (1.-stp->s_pairfrac)*tlen + 0.5;
	
	b1 = fm_sbuf[ s1 ];
	b2 = fm_sbuf[ s2 ];
	b3 = fm_sbuf[ s3 - tlen + 1 ];
	if( RM_triple( stp->s_pairset, b1, b2, b3 ) ){
		*n_mpr = 0;
		l_pr = 1;
	}else if( !( stp->s_attr & SA_5PAIRED ) ){
		*n_mpr = 1;
		l_pr = 0;
	}else
		return( 0 );
	
	for( t = 1; t < tlen; t++ ){
		b1 = fm_sbuf[ s1 + t ];
		b2 = fm_sbuf[ s2 - t ];
		b3 = fm_sbuf[ s3 - tlen + 1 + t ];
		if( !RM_triple( stp->s_pairset, b1, b2, b3 ) ){
			l_pr = 0;
			( *n_mpr )++;
			if( *n_mpr > mplim )
				return( 0 );
		}else
			l_pr = 1;
	}

	if( !l_pr ){
		if( stp->s_attr & SA_3PAIRED )
			return( 0 );
	}

	if( stp1->s_seq != NULL ){
		if( !chk_seq( stp1, &fm_sbuf[ s2 - tlen + 1 ], tlen ) )
			return( 0 );
	}

	return( 1 );
}

static	int	match_4plex( STREL_T *stp1, STREL_T *stp2,
	int s1, int s2, int s3, int s4, int qlen, int *n_mpr )
{
	int	q;
	int	b1, b2, b3, b4;
	int	mplim, l_pr;

	mplim = 0;
	if( stp1->s_mispair > 0 )
		mplim = stp1->s_mispair;
	else if( stp1->s_pairfrac < 1.0 )
		mplim = (1.-stp1->s_pairfrac)*qlen + 0.5;

	b1 = fm_sbuf[ s1 + qlen - 1 ];
	b2 = fm_sbuf[ s2 ];
	b3 = fm_sbuf[ s3 ];
	b4 = fm_sbuf[ s4 - qlen + 1 ];
	if( RM_quad( stp1->s_pairset, b1, b2, b3, b4 ) ){
		*n_mpr = 0;
		l_pr = 1;
	}else if( !( stp1->s_attr & SA_5PAIRED ) ){
		*n_mpr = 1;
		l_pr = 0;
	}else
		return( 0 );

	for( *n_mpr = 0, q = 1; q < qlen; q++ ){
		b1 = fm_sbuf[ s1 + qlen - 1 - q ];
		b2 = fm_sbuf[ s2 + q ];
		b3 = fm_sbuf[ s3 - q ];
		b4 = fm_sbuf[ s4 - qlen + 1 + q ];
		if( !RM_quad( stp1->s_pairset, b1, b2, b3, b4 ) ){
			l_pr = 0;
			( *n_mpr )++;
			if( *n_mpr > mplim )
				return( 0 );
		}else
			l_pr = 1;
	}
	if( !l_pr ){
		if( stp1->s_attr & SA_3PAIRED )
			return( 0 );
	}

	if( stp1->s_seq != NULL ){
		if( !chk_seq( stp1, &fm_sbuf[ s2 ], qlen ) )
			return( 0 );
	}

	if( stp2->s_seq != NULL ){
		if( !chk_seq( stp2, &fm_sbuf[ s3 - qlen + 1 ], qlen ) )
			return( 0 );
	}

	return( 1 );
}

int	RM_paired( PAIRSET_T *ps, int b5, int b3 )
{
	BP_MAT_T	*bpmatp;
	int	b5i, b3i;
	int	rv;
	
	bpmatp = ps->ps_mat[ 0 ];
	b5i = rm_b2bc[ b5 ];
	b3i = rm_b2bc[ b3 ];
	rv = (*bpmatp)[b5i][b3i];
	return( rv );
}

int	RM_triple( PAIRSET_T *ps, int b1, int b2, int b3 )
{
	BT_MAT_T	*btmatp;
	int	b1i, b2i, b3i;
	int	rv;
	
	btmatp = ps->ps_mat[ 1 ];
	b1i = rm_b2bc[ b1 ];
	b2i = rm_b2bc[ b2 ];
	b3i = rm_b2bc[ b3 ];
	rv = (*btmatp)[b1i][b2i][b3i];
	return( rv );
}

int	RM_quad( PAIRSET_T *ps, int b1, int b2, int b3, int b4 )
{
	BQ_MAT_T	*bqmatp;
	int	b1i, b2i, b3i, b4i;
	int	rv;
	
	bqmatp = ps->ps_mat[ 1 ];
	b1i = rm_b2bc[ b1 ];
	b2i = rm_b2bc[ b2 ];
	b3i = rm_b2bc[ b3 ];
	b4i = rm_b2bc[ b4 ];
	rv = (*bqmatp)[b1i][b2i][b3i][b4i];
	return( rv );
}

static	void	mark_ss( STREL_T *stp, int s5, int slen )
{
	int	s;

	stp->s_matchoff = s5;
	stp->s_matchlen = slen;

	for( s = 0; s < slen; s++ )
		fm_window[ s5 + s - fm_szero ] = stp->s_index;
}

static	void	unmark_ss( STREL_T *stp, int s5, int slen )
{
	int	s;

	stp->s_matchoff = UNDEF;
	stp->s_matchlen = UNDEF;

	for( s = 0; s < slen; s++ )
		fm_window[ s5 + s - fm_szero ] = UNDEF;
}

static	void	mark_duplex( STREL_T *stp5, int h5,
	STREL_T *stp3, int h3, int hlen )
{
	int	h;

	stp5->s_matchoff = h5;
	stp5->s_matchlen = hlen;
	stp3->s_matchoff = h3 - hlen + 1;
	stp3->s_matchlen = hlen;

	for( h = 0; h < hlen; h++ ){
		fm_window[ h5+h-fm_szero ] = stp5->s_index;
		fm_window[ h3-h-fm_szero ] = stp5->s_index;
	}
}

static	void	unmark_duplex( STREL_T *stp5, int h5,
	STREL_T *stp3, int h3, int hlen )
{
	int	h;

	stp5->s_matchoff = UNDEF;
	stp5->s_matchlen = UNDEF;
	stp3->s_matchoff = UNDEF;
	stp3->s_matchlen = UNDEF;

	for( h = 0; h < hlen; h++ ){
		fm_window[ h5+h-fm_szero ] = UNDEF;
		fm_window[ h3-h-fm_szero ] = UNDEF;
	}
}

static	int	chk_wchlx0( SEARCH_T *srp, int s5, int s3 )
{
	STREL_T	*stp;
	int	b5, b3;

	if( srp->s_backup != NULL )
		return( 1 );
	if( s5 == 0 )
		return( 1 );
	if( s3 == fm_slen - 1 )
		return( 1 );
	b5 = fm_sbuf[ s5 - 1 ];
	b3 = fm_sbuf[ s3 + 1 ];
	stp = srp->s_descr;
	return( !RM_paired( stp->s_pairset, b5, b3 ) );
}

static	int	chk_motif( int n_descr, STREL_T descr[], SITE_T *sites )
{
	int	d;
	STREL_T	*stp;

	for( stp = descr, d = 0; d < n_descr; d++, stp++ ){
		switch( stp->s_type ){

		case SYM_H5 :
			if( !chk_wchlx( stp, n_descr, descr ) )
				return( 0 );
			break;

		case SYM_P5 :
			if( !chk_phlx( stp, n_descr, descr ) )
				return( 0 );
			break;
		case SYM_T1 :
			if( !chk_triplex( stp, n_descr, descr ) )
				return( 0 );
			break;
		case SYM_Q1 :
			if( !chk_4plex( stp, n_descr, descr ) )
				return( 0 );
			break;

		default :	
			break;
		}
	}
	if( chk_sites( n_descr, descr, sites ) )
		return( 1 );
	else
		return( 0 );
}

static	int	chk_wchlx( STREL_T *stp, int n_descr, STREL_T descr[] )
{
	STREL_T	*stp3, *stpd5, *stpd3;
	int	h5_5, h5_3;
	int	h3_5, h3_3;
	int	h5, h3, b5, b3;
	int	d5, d3;

	h5_5 = stp->s_matchoff;
	h5_3 = h5_5 + stp->s_matchlen - 1;

	stp3 = stp->s_mates[ 0 ];
	h3_5 = stp3->s_matchoff;
	h3_3 = h3_5 + stp3->s_matchlen - 1;

	if( h5_5 > 0 ){
		if( h3_3 < fm_slen - 1 ){
			h5 = h5_5 - 1;
			h3 = h3_3 + 1;
			d5 = fm_window[ h5 - fm_szero ];
			d3 = fm_window[ h3 - fm_szero ];
			stpd5 = &descr[ d5 ];
			stpd3 = &descr[ d3 ];
			if( stpd5->s_type==SYM_SS && stpd3->s_type==SYM_SS ){
				b5 = fm_sbuf[ h5 ];
				b3 = fm_sbuf[ h3 ];
				if( RM_paired( stp->s_pairset, b5, b3 ) )
					return( 0 );
			}
		}
	}

	h5 = h5_3 + 1;
	h3 = h3_5 - 1;
	d5 = fm_window[ h5 - fm_szero ];
	d3 = fm_window[ h3 - fm_szero ];
	stpd5 = &descr[ d5 ];
	stpd3 = &descr[ d3 ];
	if( stpd5->s_type==SYM_SS && stpd3->s_type==SYM_SS ){
		b5 = fm_sbuf[ h5 ];
		b3 = fm_sbuf[ h3 ];
		if( RM_paired( stp->s_pairset, b5, b3 ) )
			return( 0 );
	}

	return( 1 );
}

static	int	chk_phlx( STREL_T *stp, int n_descr, STREL_T descr[] )
{
	STREL_T	*stp3, *stpd5, *stpd3;
	int	h5_5, h5_3;
	int	h3_5, h3_3;
	int	h5, h3, b5, b3;
	int	d5, d3;

	h5_5 = stp->s_matchoff;
	h5_3 = h5_5 + stp->s_matchlen - 1;

	stp3 = stp->s_mates[ 0 ];
	h3_5 = stp3->s_matchoff;
	h3_3 = h3_5 + stp3->s_matchlen - 1;

	if( h5_5 > 0 ){
		h5 = h5_5 - 1;
		h3 = h3_5 - 1;
		d5 = fm_window[ h5 - fm_szero ];
		d3 = fm_window[ h3 - fm_szero ];
		stpd5 = &descr[ d5 ];
		stpd3 = &descr[ d3 ];
		if( stpd5->s_type==SYM_SS && stpd3->s_type==SYM_SS ){
			b5 = fm_sbuf[ h5 ];
			b3 = fm_sbuf[ h3 ];
			if( RM_paired( stp->s_pairset, b5, b3 ) )
				return( 0 );
		}
	}

	if( h3_3 < fm_slen - 1 ){
		h5 = h5_3 + 1;
		h3 = h3_3 + 1;
		d5 = fm_window[ h5 - fm_szero ];
		d3 = fm_window[ h3 - fm_szero ];
		stpd5 = &descr[ d5 ];
		stpd3 = &descr[ d3 ];
		if( stpd5->s_type==SYM_SS && stpd3->s_type==SYM_SS ){
			b5 = fm_sbuf[ h5 ];
			b3 = fm_sbuf[ h3 ];
			if( RM_paired( stp->s_pairset, b5, b3 ) )
				return( 0 );
		}
	}

	return( 1 );
}

static	int	chk_triplex( STREL_T *stp, int n_descr, STREL_T descr[] )
{
	STREL_T	*stp1, *stp2;
	int	t1_5, t2_3, t3_5;
	int	t1_3, t2_5, t3_3;
	int	t1, t2, t3;
	int	d1, d2, d3;
	int	b1, b2, b3;
	STREL_T	*stpd1, *stpd2, *stpd3;

	t1_5 = stp->s_matchoff;
	t1_3 = t1_5 + stp->s_matchlen - 1;

	stp1 = stp->s_mates[ 0 ];
	t2_5 = stp1->s_matchoff;
	t2_3 = t2_5 + stp1->s_matchlen - 1;

	stp2 = stp->s_mates[ 1 ];
	t3_5 = stp2->s_matchoff;
	t3_3 = t3_5 + stp2->s_matchlen - 1;

	if( t1_5 > 0 ){
		t1 = t1_5 - 1; 
		t2 = t2_3 + 1;
		t3 = t3_5 - 1;
		d1 = fm_window[ t1 - fm_szero ];
		d2 = fm_window[ t2 - fm_szero ];
		d3 = fm_window[ t3 - fm_szero ];
		stpd1 = &descr[ d1 ];
		stpd2 = &descr[ d2 ];
		stpd3 = &descr[ d3 ];
		if( stpd1->s_type==SYM_SS && stpd2->s_type==SYM_SS && 
				stpd3->s_type==SYM_SS){
			b1 = fm_sbuf[ d1 ];
			b2 = fm_sbuf[ d2 ];
			b3 = fm_sbuf[ d3 ];
			if( RM_triple( stp->s_pairset, b1, b2, b3 ) )
				return( 0 );
		}
	}

	if( t3_3 < fm_slen - 1 ){
		t1 = t1_3 + 1; 
		t2 = t2_5 - 1;
		t3 = t3_3 + 1;
		d1 = fm_window[ t1 - fm_szero ];
		d2 = fm_window[ t2 - fm_szero ];
		d3 = fm_window[ t3 - fm_szero ];
		stpd1 = &descr[ d1 ];
		stpd2 = &descr[ d2 ];
		stpd3 = &descr[ d3 ];
		if( stpd1->s_type==SYM_SS && stpd2->s_type==SYM_SS && 
				stpd3->s_type==SYM_SS){
			b1 = fm_sbuf[ d1 ];
			b2 = fm_sbuf[ d2 ];
			b3 = fm_sbuf[ d3 ];
			if( RM_triple( stp->s_pairset, b1, b2, b3 ) )
				return( 0 );
		}
	}

	return( 1 );
}

static	int	chk_4plex( STREL_T *stp, int n_descr, STREL_T descr[] )
{
	STREL_T	*stp1, *stp2, *stp3;
	int	q1_5, q2_3, q3_5, q4_3;
	int	q1_3, q2_5, q3_3, q4_5;
	int	q1, q2, q3, q4;
	int	d1, d2, d3, d4;
	int	b1, b2, b3, b4;
	STREL_T	*stpd1, *stpd2, *stpd3, *stpd4;

	q1_5 = stp->s_matchoff;
	q1_3 = q1_5 + stp->s_matchlen - 1;

	stp1 = stp->s_mates[ 0 ];
	q2_5 = stp1->s_matchoff;
	q2_3 = q2_5 + stp1->s_matchlen - 1;

	stp2 = stp->s_mates[ 1 ];
	q3_5 = stp2->s_matchoff;
	q3_3 = q3_5 + stp2->s_matchlen - 1;

	stp3 = stp->s_mates[ 2 ];
	q4_5 = stp3->s_matchoff;
	q4_3 = q4_5 + stp3->s_matchlen - 1;

	if( q1_5 > 0 ){
		if( q4_3 < fm_slen - 1 ){
			q1 = q1_5 - 1; 
			q2 = q2_3 + 1;
			q3 = q3_5 - 1;
			q4 = q4_3 + 1;
			d1 = fm_window[ q1 - fm_szero ];
			d2 = fm_window[ q2 - fm_szero ];
			d3 = fm_window[ q3 - fm_szero ];
			d4 = fm_window[ q4 - fm_szero ];
			stpd1 = &descr[ d1 ];
			stpd2 = &descr[ d2 ];
			stpd3 = &descr[ d3 ];
			stpd4 = &descr[ d4 ];
			if( stpd1->s_type==SYM_SS && stpd2->s_type==SYM_SS && 
				stpd3->s_type==SYM_SS&&stpd4->s_type==SYM_SS){
				b1 = fm_sbuf[ d1 ];
				b2 = fm_sbuf[ d2 ];
				b3 = fm_sbuf[ d3 ];
				b4 = fm_sbuf[ d4 ];
				if( RM_quad( stp->s_pairset, b1, b2, b3, b4 ) )
					return( 0 );
			}
		}
	}

	q1 = q1_3 + 1; 
	q2 = q2_5 - 1;
	q3 = q3_3 + 1;
	q4 = q4_5 - 1;
	d1 = fm_window[ q1 - fm_szero ];
	d2 = fm_window[ q2 - fm_szero ];
	d3 = fm_window[ q3 - fm_szero ];
	d4 = fm_window[ q4 - fm_szero ];
	stpd1 = &descr[ d1 ];
	stpd2 = &descr[ d2 ];
	stpd3 = &descr[ d3 ];
	stpd4 = &descr[ d4 ];
	if( stpd1->s_type==SYM_SS && stpd2->s_type==SYM_SS && 
		stpd3->s_type==SYM_SS && stpd3->s_type==SYM_SS ){
		b1 = fm_sbuf[ d1 ];
		b2 = fm_sbuf[ d2 ];
		b3 = fm_sbuf[ d3 ];
		b4 = fm_sbuf[ d4 ];
		if( RM_quad( stp->s_pairset, b1, b2, b3, b4 ) )
			return( 0 );
	}

	return( 1 );
}

static	int	set_context( int n_descr, STREL_T descr[] )
{
	STREL_T	*stp;
	int	offset, length;
	int	rv = 1;

	if( rm_lctx == NULL ){
		if( rm_rctx == NULL )
			return( 1 );
	}else{
		stp = &descr[ 0 ];
		offset = rm_lctx->s_matchoff =
			MAX( stp->s_matchoff - rm_lctx->s_maxlen, 0 );
		length = rm_lctx->s_matchlen = 
			stp->s_matchoff - rm_lctx->s_matchoff;
		if( length < rm_lctx->s_minlen )
			return( 0 );
		if( rm_lctx->s_seq != NULL ){
			if( !chk_seq( rm_lctx, &fm_sbuf[ offset ], length ) )
				return( 0 );
		}
	}
	if( rm_rctx != NULL ){
		stp = &descr[ n_descr - 1 ];
		rm_rctx->s_matchoff = stp->s_matchoff + stp->s_matchlen;
		offset = MIN( rm_rctx->s_matchoff+rm_rctx->s_maxlen, fm_slen );
		length = rm_rctx->s_matchlen = offset - rm_rctx->s_matchoff;
		if( length < rm_rctx->s_minlen )
			return( 0 );
		if( rm_rctx->s_seq != NULL ){
			if( !chk_seq( rm_rctx, &fm_sbuf[ offset ], length ) )
				return( 0 );
		}
	}

	return( rv );
}

static	int	chk_sites( int n_descr, STREL_T descr[], SITE_T *sites )
{
	SITE_T	*sip;

	for( sip = sites; sip; sip = sip->s_next ){
		if( !chk_1_site( n_descr, descr, sip ) )
			return( 0 );
	} 
	return( 1 );
}

static	int	chk_1_site( int n_descr, STREL_T descr[], SITE_T *sip )
{
	int	p;
	POS_T	*pp;
	ADDR_T	*ap;
	STREL_T	*stp;
	int	s[ 4 ];
	int	b[ 4 ];
	int	rv;

	for( pp = sip->s_pos, p = 0; p < sip->s_n_pos; p++, pp++ ){
/*
		stp = &descr[ pp->p_dindex ];
*/
		stp = pp->p_descr;
		ap = &pp->p_addr;
		if( ap->a_l2r ){
			if( ap->a_offset > stp->s_matchlen )
				return( 0 );
			else{
				s[ p ] = stp->s_matchoff + ap->a_offset - 1;
				b[ p ] = fm_sbuf[ s[ p ] ];
			}
		}else if( ap->a_offset >= stp->s_matchlen )
			return( 0 );
		else{
			s[ p ] = stp->s_matchoff+stp->s_matchlen-ap->a_offset-1;
			b[ p ] = fm_sbuf[ s[ p ] ];
		}
	}

	if( sip->s_n_pos == 2 ){
		rv = RM_paired( sip->s_pairset, b[ 0 ], b[ 1 ] );
	}else if( sip->s_n_pos == 3 ){
		rv = RM_triple( sip->s_pairset, b[ 0 ], b[ 1 ], b[ 2 ] );
	}else if( sip->s_n_pos == 4 ){
		rv = RM_quad( sip->s_pairset, b[ 0 ], b[ 1 ], b[ 2 ], b[ 3 ] );
	}
	return( rv );
}

static	int	chk_seq( STREL_T *stp, char seq[], int slen )
{
	int	i;
	char	*csp, *sp;

	for( csp = fm_chk_seq, sp = seq, i = 0; i < slen; i++, sp++ )
		*csp++ = ( *sp == 'u' || *sp == 'U' ) ? 't' : *sp;
	*csp = '\0';
	circf = *stp->s_seq == '^';
	if( stp->s_mismatch > 0 ){
		return( mm_step( fm_chk_seq, stp->s_expbuf, stp->s_mismatch,
			&stp->s_n_mismatches ) );
	}else
		return( step( fm_chk_seq, stp->s_expbuf ) );
}

static	void	print_match( FILE *fp, char sid[], int comp,
	int n_descr, STREL_T descr[] )
{
	static	int	first = 1;
	char	name[ 20 ];
	int	d, len, offset;
	STREL_T	*stp;
	char	cstr[ 256 ];

	if( first ){
		first = 0;
		fprintf( fp, "#RM scored\n" );
		fprintf( fp, "#RM descr" );
		if( rm_lctx != NULL ){
			RM_strel_name( rm_lctx, name );
			fprintf( fp, " %s", name );
			if( rm_lctx->s_tag != NULL ){
				mk_cstr( rm_lctx->s_tag, cstr );
				fprintf( fp, "(tag='%s')", cstr );
			}
		}
		for( stp = descr, d = 0; d < n_descr; d++, stp++ ){
			RM_strel_name( stp, name );
			fprintf( fp, " %s", name );
			if( stp->s_tag != NULL ){
				mk_cstr( stp->s_tag, cstr );
				fprintf( fp, "(tag='%s')", cstr );
			}
		}
		if( rm_rctx != NULL ){
			RM_strel_name( rm_rctx, name );
			fprintf( fp, " %s", name );
			if( rm_rctx->s_tag != NULL ){
				mk_cstr( rm_rctx->s_tag, cstr );
				fprintf( fp, "(tag='%s')", cstr );
			}
		}
		fprintf( fp, "\n" );
	}
	for( stp = descr, len = 0, d = 0; d < n_descr; d++, stp++ )
		len += stp->s_matchlen;

	stp = descr; 
	if( comp ){
		offset = fm_slen - stp->s_matchoff;
	}else
		offset = stp->s_matchoff + 1;

	fprintf( fp, ">%s %s\n", sid, fm_sdef );
	fprintf( fp, "%-12s", sid );
	switch( rm_sval->v_type ){
	case T_INT :
		fprintf( fp, " %8d", rm_sval->v_value.v_ival );
		break;
	case T_FLOAT :
		fprintf( fp, " %8.3lf", rm_sval->v_value.v_dval );
		break;
	case T_STRING :
		fprintf( fp, " %8s", rm_sval->v_value.v_pval );
		break;
	default :
		fprintf( fp, " %8.3lf", 0.0 );
		break;
	}
	fprintf( fp, " %d %7d %4d", comp, offset, len );

	if( rm_lctx != NULL ){
		if( rm_lctx->s_matchlen > 0 ){
			fprintf( fp, " %.*s",
				rm_lctx->s_matchlen,
				&fm_sbuf[ rm_lctx->s_matchoff ] );
		}else
			fprintf( fp, " ." );
	}
	for( d = 0; d < n_descr; d++, stp++ ){
		if( stp->s_matchlen > 0 ){
			fprintf( fp, " %.*s",
				stp->s_matchlen, &fm_sbuf[ stp->s_matchoff ] );
		}else
			fprintf( fp, " ." );
	}
	if( rm_rctx != NULL ){
		if( rm_rctx->s_matchlen > 0 ){
			fprintf( fp, " %.*s",
				rm_rctx->s_matchlen,
				&fm_sbuf[ rm_rctx->s_matchoff ] );
		}else
			fprintf( fp, " ." );
	}
	fprintf( fp, "\n" );
}

static	void	mk_cstr( char str[], char cstr[] )
{
	char	*sp, *cp;

	if( str == NULL ){
		*cstr = '\0';
		return;
	}

	for( sp = str, cp = cstr; *sp; sp++ ){
		if( *sp == '"' || *sp == '\\' )
			*cp++ = '\\';
		*cp++ = *sp;
	}
	*cp = '\0';
}
@


1.103
log
@removed unused var length in set_context()
@
text
@d1512 1
a1512 1
	int	offset;
d1520 1
a1520 1
		rm_lctx->s_matchoff =
d1522 1
a1522 1
		rm_lctx->s_matchlen = 
d1524 6
d1535 7
a1541 1
		rm_rctx->s_matchlen = offset - rm_rctx->s_matchoff;
@


1.102
log
@added/modified code to handle new structure element, ctx, for
context.
@
text
@d1512 1
a1512 1
	int	offset, length;
@


1.101
log
@removed dtype, as it is always fastn.
@
text
@d15 4
d64 6
a69 3
static	int	match_phlx( STREL_T *, STREL_T *, int, int, int, int, int *, int * );
static	int	match_triplex( STREL_T *, STREL_T *, int, int, int, int, int * );
static	int	match_4plex( STREL_T *, STREL_T *, int, int, int, int, int, int * );
d80 1
d265 1
a265 1
		if( !chk_sites( rm_n_descr, rm_descr, rm_sites ) ){
d267 2
d1509 26
d1557 1
d1559 2
d1616 8
d1632 8
d1669 8
d1681 8
@


1.100
log
@removed double * score parm from RM_score() as the value is now returned
in the global var rm_sval.
@
text
@a27 1
static	int	fm_dtype;
d82 1
a82 1
	char sid[], int dtype, char sdef[], int comp, int slen, char sbuf[] )
a112 1
	fm_dtype = dtype;
d1596 1
a1596 2
	if( fm_dtype == DT_FASTN )
		fprintf( fp, ">%s %s\n", sid, fm_sdef );
@


1.99
log
@about 1/2 way to converting the fixed type `double score' to a type set
by the score function.  It works in the new fashion but the old return
value &fm_score is still there.
@
text
@a32 1
static	double	fm_score;
d261 1
a261 1
		}else if( RM_score( fm_comp, fm_slen, fm_sbuf, &fm_score ) )
@


1.98
log
@removed older unused verions of match_wchlxX(), X= 0,1.
@
text
@d22 2
d1601 16
a1616 2
	fprintf( fp, "%-12s %8.3lf %d", sid, fm_score, comp );
	fprintf( fp, " %7d %4d", offset, len );
@


1.97
log
@typo resulted in match_wchlx1() being declared twice at the expense of
no decl of match_wchlx()
@
text
@a57 4
static	int	match_wchlx0( STREL_T *, STREL_T *, int, int, int,
	int [], int[], int[]  );
static	int	match_wchlx1( STREL_T *, STREL_T *, int, int, int,
	int[], int[], int[] );
d59 4
a62 7
	int[], int[], int[] );
static	int	match_phlx( STREL_T *, STREL_T *, int, int, int, int,
	int *, int * );
static	int	match_triplex( STREL_T *, STREL_T *, int, int, int, int,
	int * );
static	int	match_4plex( STREL_T *, STREL_T *, int, int, int, int,
	int, int * );
a798 82
int	match_wchlx0( STREL_T *stp, STREL_T *stp3,
	int s5, int s3, int s3lim, int h3[], int hlen[], int n_mpr[] )
{
	int	s;
	int	b5, b3;
	int	mplim, l_n_mpr;
	int	i_lpb, pfrac;

	*n_mpr = 0;
	l_n_mpr = 0;
	mplim = 0;
	pfrac = 0;
	if( stp->s_mispair > 0 ){
		mplim = stp->s_mispair;
	}else if( stp->s_pairfrac < 1.0 ){
		mplim = (1.-stp->s_pairfrac)*MIN(stp->s_maxlen, fm_windowsize);
		pfrac = 1;
	}

	b5 = fm_sbuf[ s5 ];
	b3 = fm_sbuf[ s3 ];
	if( RM_paired( stp->s_pairset, b5, b3 ) ){
		*h3 = s3;
		i_lpb = 0;
	}else if( !( stp->s_attr & SA_5PAIRED ) ){
		*h3 = s3;
		*n_mpr = 1;
		i_lpb = UNDEF;
		l_n_mpr = *n_mpr;
	}else
		return( 0 );

	for( *hlen = 1, s = s3 - 1; s >= s3lim; s-- ){
		b5 = fm_sbuf[ s5 + *hlen ];
		b3 = fm_sbuf[ s3 - *hlen ];
		if( RM_paired( stp->s_pairset, b5, b3 ) ){
			if( pfrac ){
				if(1.*(*hlen-*n_mpr)/(*hlen)>=stp->s_pairfrac){
					i_lpb = *hlen;
					l_n_mpr = *n_mpr;
				}
			}else{
				i_lpb = *hlen;
				l_n_mpr = *n_mpr;
			}
		}else{
			( *n_mpr )++;
			if( *n_mpr > mplim ){
				if( *hlen < stp->s_minlen )
					return( 0 );
				else
					break;
			}
		}
		( *hlen )++;
	}

/*
	if( *hlen != i_lpb + 1 )
		*hlen = i_lpb + 1;
*/
	if( *hlen != i_lpb + 1 ){
		if( stp->s_attr & SA_3PAIRED ){
			*hlen = i_lpb + 1;
			*n_mpr = l_n_mpr;
		}
	}
	if( *hlen < stp->s_minlen || *hlen > stp->s_maxlen )
		return( 0 );

	if( stp->s_seq != NULL ){
		if( !chk_seq( stp, &fm_sbuf[ s5 ], *hlen ) )
			return( 0 );
	}
	if( stp3->s_seq != NULL ){
		if( !chk_seq( stp3, &fm_sbuf[ s3 - *hlen + 1 ], *hlen ) )
			return( 0 );
	}

	return( 1 );
}

a934 81
	return( nh );
}

static	int	match_wchlx1( STREL_T *stp, STREL_T *stp3,
	int s5, int s3, int s3lim, int h3[], int hlen[], int n_mpr[] )
{
	int	nh, hl, mpr, l_bpr;
	int	b5, b3;
	int	mplim; 
	int	pfrac;

	b5 = fm_sbuf[ s5 ];
	b3 = fm_sbuf[ s3 ];
	if( RM_paired( stp->s_pairset, b5, b3 ) ){
		hl = 1;
		mpr = 0;
		l_bpr = 1;
	}else if( !( stp->s_attr & SA_5PAIRED ) ){
		hl = 1;
		mpr = 1;
		l_bpr = 0;
	}else{
		return( 0 );
	}

	if( stp->s_mispair > 0 ){
		mplim = stp->s_mispair;
		pfrac = 0;
	}else if( stp->s_pairfrac < 1.0 ){
		mplim = (1.-stp->s_pairfrac) *
			MIN(stp->s_maxlen, fm_windowsize) + 0.5;
		pfrac = 1;
	}else{
		mplim = 0;
		pfrac = 0;
	}

	for( nh = 0; s3 - hl + 1 >= s3lim; ){
		if( hl >= stp->s_minlen ){
			if( !l_bpr && ( stp->s_attr & SA_3PAIRED ) )
				goto SKIP;

			if( pfrac ){
				if( 1.*( hl - mpr )/hl < stp->s_pairfrac )
					goto SKIP;
			}

			if( stp->s_seq != NULL ){
				if( !chk_seq( stp, &fm_sbuf[ s5 ], hl ) )
					goto SKIP;
			}

			if( stp3->s_seq != NULL ){
				if( chk_seq(stp3, &fm_sbuf[s3-hl+1], hl ) ){
					h3[ nh ] = s3;
					hlen[ nh ] = hl;
					n_mpr[ nh ] = mpr;
					nh++;
				}
			}else{
				h3[ nh ] = s3;
				hlen[ nh ] = hl;
				n_mpr[ nh ] = mpr;
				nh++;
			}
		}
SKIP : ;
		b5 = fm_sbuf[ s5 + hl ];
		b3 = fm_sbuf[ s3 - hl ];
		if( RM_paired( stp->s_pairset, b5, b3 ) )
			l_bpr = 1;
		else{
			mpr++;
			if( mpr > mplim )
				break;
			l_bpr = 0;
		}
		hl++;
		if( hl >= stp->s_maxlen )
			break;
	}
@


1.96
log
@converted all headers from K&R to ANSI.
@
text
@d62 1
a62 1
static	int	match_wchlx1( STREL_T *, STREL_T *, int, int, int,
@


1.95
log
@added new parm, slen to RM_score().  rearranged parms.
@
text
@d38 52
a89 50
static	int	find_motif();
static	int	find_1_motif();
static	int	find_ss();
static	int	find_wchlx();
static	int	find_pknot();
static	int	find_pknot5();
static	int	find_pknot3();
static	int	find_minlen();
static	int	find_maxlen();
static	void	upd_pksearches();
static	int	find_phlx();
static	int	find_triplex();
static	int	find_4plex();
static	int	find_4plex_inner();
static	int	match_wchlx0();
static	int	match_wchlx1();
static	int	match_wchlx();
static	int	match_phlx();
static	int	match_triplex();
static	int	match_4plex();
static	void	mark_ss();
static	void	unmark_ss();
static	void	mark_duplex();
static	void	unmark_duplex();
static	int	chk_wchlx0();
static	int	chk_motif();
static	int	chk_wchlx();
static	int	chk_phlx();
static	int	chk_triplex();
static	int	chk_4plex();
static	int	chk_sites();
static	int	chk_1_site();
static	int	chk_seq();

static	void	print_match();
static	void	mk_cstr();

IDENT_T	*RM_find_id();

int	find_motif_driver( n_searches, searches, sites,
	sid, dtype, sdef, comp, slen, sbuf )
int	n_searches;
SEARCH_T	*searches[];
SITE_T	*sites;
char	sid[];
int	dtype;
char	sdef[];
int	comp;
int	slen;
char	sbuf[];
d147 1
a147 2
static	int	find_motif( srp )
SEARCH_T	*srp;
d191 1
a191 2
static	int	find_1_motif( srp )
SEARCH_T	*srp;
d235 1
a235 2
static	int	find_ss( srp )
SEARCH_T	*srp;
d283 1
a283 2
static	int	find_wchlx( srp )
SEARCH_T	*srp;
d348 1
a348 2
static	int	find_pknot( srp )
SEARCH_T	*srp;
d378 1
a378 2
static	int	find_pknot5( srp )
SEARCH_T	*srp;
d413 1
a413 3
static	int	find_pknot3( srp, s5 )
SEARCH_T	*srp;
int	s5;
d473 1
a473 3
static	int	find_minlen( fd, ld )
int	fd;
int	ld;
d486 1
a486 3
static	int	find_maxlen( fd, ld )
int	fd;
int	ld;
d498 1
a498 5
static	void	upd_pksearches( stp, h5, h3, hlen )
STREL_T	*stp;
int	h5;
int	h3;
int	hlen;
d534 1
a534 2
static	int	find_phlx( srp )
SEARCH_T	*srp;
d594 1
a594 2
static	int	find_triplex( srp )
SEARCH_T	*srp;
d682 1
a682 2
static	int	find_4plex( srp )
SEARCH_T	*srp;
d733 1
a733 4
static	int	find_4plex_inner( srp, s3, hlen )
SEARCH_T	*srp;
int	s3;
int	hlen;
d806 2
a807 9
int	match_wchlx0( stp, stp3, s5, s3, s3lim, h3, hlen, n_mpr )
STREL_T	*stp;
STREL_T	*stp3;
int	s5;
int	s3;
int	s3lim;
int	h3[];
int	hlen[];
int	n_mpr[];
d888 2
a889 9
static	int	match_wchlx( stp, stp3, s5, s3, s3lim, h3, hlen, n_mpr )
STREL_T	*stp;
STREL_T	*stp3;
int	s5;
int	s3;
int	s3lim;
int	h3[];
int	hlen[];
int	n_mpr[];
d1027 2
a1028 9
static	int	match_wchlx1( stp, stp3, s5, s3, s3lim, h3, hlen, n_mpr )
STREL_T	*stp;
STREL_T	*stp3;
int	s5;
int	s3;
int	s3lim;
int	h3[];
int	hlen[];
int	n_mpr[];
d1108 2
a1109 9
static	int	match_phlx( stp, stp3, s5, s3, s5hi, s5lo, hlen, n_mpr )
STREL_T	*stp;
STREL_T	*stp3;
int	s5;
int	s3;
int	s5hi;
int	s5lo;
int	*hlen;
int	*n_mpr;
d1177 2
a1178 8
static	int	match_triplex( stp, stp1, s1, s2, s3, tlen, n_mpr )
STREL_T	*stp;
STREL_T	*stp1;
int	s1;
int	s2;
int	s3;
int	tlen;
int	*n_mpr;
d1228 2
a1229 9
static	int	match_4plex( stp1, stp2, s1, s2, s3, s4, qlen, n_mpr )
STREL_T	*stp1;
STREL_T	*stp2;
int	s1;
int	s2;
int	s3;
int	s4;
int	qlen;
int	*n_mpr;
d1285 1
a1285 4
int	RM_paired( ps, b5, b3 )
PAIRSET_T	*ps;
int	b5;
int	b3;
d1298 1
a1298 5
int	RM_triple( ps, b1, b2, b3 )
PAIRSET_T	*ps;
int	b1;
int	b2;
int	b3;
d1312 1
a1312 6
int	RM_quad( ps, b1, b2, b3, b4 )
PAIRSET_T	*ps;
int	b1;
int	b2;
int	b3;
int	b4;
d1327 1
a1327 4
static	void	mark_ss( stp, s5, slen )
STREL_T	*stp;
int	s5;
int	slen;
d1338 1
a1338 4
static	void	unmark_ss( stp, s5, slen )
STREL_T	*stp;
int	s5;
int	slen;
d1349 2
a1350 6
static	void	mark_duplex( stp5, h5, stp3, h3, hlen )
STREL_T	*stp5;
int	h5;
STREL_T	*stp3;
int	h3;
int	hlen;
d1365 2
a1366 6
static	void	unmark_duplex( stp5, h5, stp3, h3, hlen )
STREL_T	*stp5;
int	h5;
STREL_T	*stp3;
int	h3;
int	hlen;
d1381 1
a1381 4
static	int	chk_wchlx0( srp, s5, s3 )
SEARCH_T	*srp;
int	s5;
int	s3;
d1398 1
a1398 4
static	int	chk_motif( n_descr, descr, sites )
int	n_descr;
STREL_T	descr[];
SITE_T	*sites;
d1434 1
a1434 4
static	int	chk_wchlx( stp, n_descr,descr )
STREL_T	*stp;
int	n_descr;
STREL_T	descr[];
d1482 1
a1482 4
static	int	chk_phlx( stp, n_descr,descr )
STREL_T	*stp;
int	n_descr;
STREL_T	descr[];
d1530 1
a1530 4
static	int	chk_triplex( stp, n_descr,descr )
STREL_T	*stp;
int	n_descr;
STREL_T	descr[];
d1594 1
a1594 4
static	int	chk_4plex( stp, n_descr,descr )
STREL_T	*stp;
int	n_descr;
STREL_T	descr[];
d1670 1
a1670 4
static	int	chk_sites( n_descr, descr, sites )
int	n_descr;
STREL_T	descr[];
SITE_T	*sites;
d1681 1
a1681 4
static	int	chk_1_site( n_descr, descr, sip )
int	n_descr;
STREL_T	descr[];
SITE_T	*sip;
d1719 18
a1736 6
static	void	print_match( fp, sid, comp, n_descr, descr )
FILE	*fp;
char	sid[];
int	comp;
int	n_descr;
STREL_T	descr[];
d1782 1
a1782 3
static	void	mk_cstr( str, cstr )
char	str[];
char	cstr[];
a1796 19
}

static	int	chk_seq( stp, seq, slen )
STREL_T	*stp;
char	seq[];
int	slen;
{
	int	i;
	char	*csp, *sp;

	for( csp = fm_chk_seq, sp = seq, i = 0; i < slen; i++, sp++ )
		*csp++ = ( *sp == 'u' || *sp == 'U' ) ? 't' : *sp;
	*csp = '\0';
	circf = *stp->s_seq == '^';
	if( stp->s_mismatch > 0 ){
		return( mm_step( fm_chk_seq, stp->s_expbuf, stp->s_mismatch,
			&stp->s_n_mismatches ) );
	}else
		return( step( fm_chk_seq, stp->s_expbuf ) );
@


1.94
log
@added parm, fm_comp to RM_score().
@
text
@d268 1
a268 1
		}else if( RM_score( fm_sbuf, fm_comp, &fm_score ) )
@


1.93
log
@added code to match_wchlx() to match 0-len helices.  0-len p-hlx
still not permitted.
@
text
@d268 1
a268 1
		}else if( RM_score( fm_sbuf, &fm_score ) )
@


1.92
log
@changed print_match() to use single quotes for tag istead of
double quotes.
@
text
@d933 24
d965 3
a967 1
	}else{
a968 1
	}
@


1.91
log
@changed float to double.  changed pairfrac test to
if( xxx < stp->s_pairfrac - EPS )
to take into account the vagaries of float division.
@
text
@d1827 1
a1827 1
				fprintf( fp, "(tag=\"%s\")", cstr );
@


1.90
log
@change pfrac calc to round before assigning to mplim.
added tests to match_wchlx() to check last helix as well.
@
text
@d3 1
d10 1
d31 1
a31 1
static	float	fm_score;
d962 1
a962 1
			if( 1.*( hl - mpr )/hl < stp->s_pairfrac )
d1007 2
a1008 2
			if( pfrac ){	/* KLUDGE! */
				if( (float)1.*( hl-mpr )/hl < stp->s_pairfrac )
d1183 1
a1183 1
			if( 1.*(*hlen-*n_mpr)/(*hlen) < stp->s_pairfrac )
d1843 1
a1843 1
	fprintf( fp, "%-12s %8.3f %d", sid, fm_score, comp );
@


1.89
log
@forgot to initialize mplim to 0 if both s_mispair and s_pairfrac don't permit
mispairs.
@
text
@d51 1
d928 1
d947 122
a1068 1
		mplim = (1.-stp->s_pairfrac)*MIN(stp->s_maxlen, fm_windowsize);
a1076 1

d1116 2
a1118 1

d1142 2
a1143 1
		mplim = (1.-stp->s_pairfrac)*MIN(stp->s_maxlen, fm_windowsize);
d1215 1
a1215 1
		mplim = (1.-stp->s_pairfrac)*tlen;
d1273 1
a1273 1
		mplim = (1.-stp1->s_pairfrac)*qlen;
@


1.88
log
@replaced incorrect greedy match_wchlx() with correct match_wchlx() that
returns ALL solutions on the range minlen..maxlen.
@
text
@d947 2
a948 1
	}else
d950 1
@


1.87
log
@converted all calls to match_wchlx() to return the number of solutions
along with usign arrays to hold the h3's, hlen's and n_mpr's.  Surrounded
each inner search with the loop for( h = 0; h < n_h3; h++ ).
Functionality of match_wchlx() is unchanged however.
@
text
@d50 1
d314 1
d823 1
a823 1
int	match_wchlx( stp, stp3, s5, s3, s3lim, h3, hlen, n_mpr )
d910 85
@


1.86
log
@removed defs and calls to find_pknot0().
@
text
@d287 2
a288 1
	int	h3, hlen, n_mpr;
d313 1
a313 1
	if(match_wchlx(stp, stp3, szero, sdollar, s3lim, &h3, &hlen, &n_mpr )){
d315 1
d317 2
a318 2
		if( !chk_wchlx0( srp, szero, h3 ) )
			return( 0 );
d321 7
a327 3
		i_len = h3 - szero - 2 * hlen + 1;
		if( i_len > i_maxl )
			return( 0 );
d329 3
a331 3
		stp->s_n_mispairs = n_mpr;
		stp3->s_n_mispairs = n_mpr;
		mark_duplex( stp, szero, stp3, h3, hlen );
d333 4
a336 4
		i_stp = stp->s_inner;
		i_srp = rm_searches[ i_stp->s_searchno ];
		i_srp->s_zero = szero + hlen;
		i_srp->s_dollar = h3 - hlen;
d338 3
a340 2
		rv = find_motif( i_srp );
		unmark_duplex( stp, szero, stp3, h3, hlen );
d423 3
a425 1
	int	s3lim, h3, hlen, n_mpr;
d458 10
a467 6
		if( match_wchlx( stp5,stp3,s5,s3,s3lim,&h3,&hlen,&n_mpr ) ){
			mark_duplex( stp5, s5, stp3, h3, hlen );
			upd_pksearches( stp5, s5, h3, hlen );
			n_srp = rm_searches[ stp5->s_searchno + 1 ];		
			rv |= find_motif( n_srp );
			unmark_duplex( stp5, s5, stp3, h3, hlen );
d701 2
a702 1
	int	h3, hlen, n_mpr;
d735 6
a740 4
	if(match_wchlx( stp, stp3, szero, sdollar, s3lim, &h3, &hlen, &n_mpr )){
		mark_duplex( stp, szero, stp3, h3, hlen );
		rv = find_4plex_inner( srp, h3, hlen );
		unmark_duplex( stp, szero, stp3, h3, hlen );
d827 3
a829 3
int	*h3;
int	*hlen;
int	*n_mpr;
@


1.85
log
@removed all unused vars as detected by the fermat C-compiler.
@
text
@a39 1
static	int	find_pknot0();
d198 1
a198 1
		if( stp->s_attr & SA_PROPER ){
d200 1
a200 1
		}else{
a201 4
/*
			rv = find_pknot0( srp );
*/
		}
a333 104
	}
	return( rv );
}

static	int	find_pknot0( srp )
SEARCH_T	*srp;
{
	STREL_T	*stp, *stp1, *stp2, *stp3;
	int	szero, sdollar;
	int	s13_lim, s1_dollar;
	int	h1_maxl;
	int	i1_minl, i1_maxl;
	int	h2_minl;
	int	i2_minl, i2_maxl;
	int	i3_maxl;
	int	h13, h1len, n_mpr1;
	int	s2, s2_zero, s20_lim, s23_lim;
	int	h23, h2len, n_mpr2;
	int	i1_len, i2_len, i3_len;
	STREL_T	*i1_stp, *i2_stp, *i3_stp;
	SEARCH_T	*i1_srp, *i2_srp, *i3_srp;
	int	rv;

	szero = srp->s_zero;
	sdollar = srp->s_dollar;

	stp = srp->s_descr;
	stp->s_n_mismatches = 0;
	stp->s_n_mispairs = 0;
	stp1 = stp->s_scopes[ 1 ];
	stp1->s_n_mismatches = 0;
	stp1->s_n_mispairs = 0;
	stp2 = stp->s_scopes[ 2 ];
	stp2->s_n_mismatches = 0;
	stp2->s_n_mispairs = 0;
	stp3 = stp->s_scopes[ 3 ];
	stp3->s_n_mismatches = 0;
	stp3->s_n_mispairs = 0;

	s1_dollar = sdollar - stp2->s_minilen - stp3->s_minlen;

	h1_maxl = stp->s_maxlen;
	i1_minl = stp->s_minilen;
	i1_maxl = stp->s_maxilen;
	i1_stp = stp->s_inner;
	i1_srp = rm_searches[ i1_stp->s_searchno ];

	h2_minl = stp1->s_minlen;
	i2_minl = stp1->s_minilen;
	i2_maxl = stp1->s_maxilen;
	i2_stp = stp1->s_inner;
	i2_srp = rm_searches[ i2_stp->s_searchno ];

	i3_maxl = stp2->s_maxilen;
	i3_stp = stp2->s_inner;
	i3_srp = rm_searches[ i3_stp->s_searchno ];

	s13_lim = s1_dollar - szero + 1;
	s13_lim = ( s13_lim - i1_minl - h2_minl - i2_minl ) / 2;
	s13_lim = MIN( s13_lim, h1_maxl );
	s13_lim = s1_dollar - s13_lim + 1;

	rv = 0;
	if( match_wchlx(stp, stp2, szero, s1_dollar, s13_lim,
		&h13, &h1len, &n_mpr1 ) ){

		mark_duplex( stp, szero, stp2, h13, h1len );

		s2_zero = szero + h1len + stp->s_minilen;
		s20_lim = h13 - h1len - stp1->s_minilen - stp1->s_minlen + 1;
		s23_lim = s1_dollar + stp2->s_minilen + 1;

		for( s2 = s2_zero; s2 <= s20_lim; s2++ ){
			if( match_wchlx( stp1, stp3,
				s2, sdollar, s23_lim, &h23, &h2len, &n_mpr2 ) ){

				i1_len = s2 - szero - h1len;
				if( i1_len > i1_maxl )
					continue;
				i2_len = h13 - h1len - ( s2 + h2len ) + 1;
				if( i2_len > i2_maxl )
					continue;
				i3_len = h23 - h13 - h2len;
				if( i3_len > i3_maxl )
					continue;

				stp->s_n_mispairs = n_mpr1;
				stp1->s_n_mispairs = n_mpr2;
				stp2->s_n_mispairs = n_mpr1;
				stp3->s_n_mispairs = n_mpr2;
				mark_duplex( stp1, s2, stp3, h23, h2len );

				i1_srp->s_zero = szero + h1len;
				i1_srp->s_dollar = s2 - 1;
				i2_srp->s_zero = s2 + h2len;
				i2_srp->s_dollar = h13 - h1len;
				i3_srp->s_zero = h13 + 1;
				i3_srp->s_dollar = h23 - h2len;

				rv |= find_motif( i1_srp );
				unmark_duplex( stp1, s2, stp3, h23, h2len );
			}
		}
		unmark_duplex( stp, szero, stp2, h13, h1len );
@


1.84
log
@rewrote find_pknot() to use the general algorithm.  SLOW,
but perhaps contains redundant code.
@
text
@a70 1
static	void	set_mbuf();
d86 2
a87 3
	int	i, w_winsize, slev;
	int	szero, l_szero;
	int	sdollar, f_sdollar, l_sdollar;
d145 2
a146 2
	STREL_T	*stp, *stp1, *stp3, *n_stp, *o_stp;
	SEARCH_T	*n_srp, *n_srp1;
a148 2
	int	d, fd, ld;
	int	g_minl, g_maxl;
d240 1
a240 1
	int	s, slen, szero, sdollar;
d289 2
a290 2
	int	s3lim, slen, szero, sdollar;
	int	h_minl, h_maxl;
d299 1
a299 1
	slen = sdollar - szero + 1;
a306 1
	h_minl = stp->s_minlen;
d347 1
a347 1
	int	s, slen, szero, sdollar;
d349 1
a349 1
	int	h1_minl, h1_maxl;
d351 1
a351 1
	int	h2_minl, h2_maxl;
d353 1
a353 1
	int	i3_minl, i3_maxl;
d364 1
a364 1
	slen = sdollar - szero + 1;
a379 1
	h1_minl = stp->s_minlen;
a386 1
	h2_maxl = stp1->s_maxlen;
a391 1
	i3_minl = stp2->s_minilen;
d481 1
a481 1
	STREL_T	*stp0, *stp5, *stp3, *stpn;
a492 1
	stp3 = stp5->s_mates[ 0 ];
d518 3
a520 3
	STREL_T	*stp0, *stp5, *stp3, *stpn;
	int	szero, sdollar, slen;
	int	g_minl, g_maxl;
d522 1
a522 1
	int	i_minl, i_maxl;
a526 1
	STREL_T	*i_stp;
a528 1
	szero = srp->s_zero;
a533 1
	stp0 = stp5->s_scopes[ 0 ];
a539 1
	i_maxl = find_maxlen( stp5->s_index + 1, stp3->s_index - 1 );
a541 1
	g_maxl = 2*h_maxl + i_maxl;
d644 1
a644 1
	int	s, s3lim, s5hi, s5lo;
d647 1
a647 1
	int	h, hlen, n_mpr;
d706 1
a706 1
	int	s, s1, s3lim, s5hi, s5lo;
d708 1
a708 1
	int	i_len, i_minl, i_maxl;
d711 1
a711 1
	int	h, hlen, n_mpr;
d793 1
a793 2
	int	s3lim, slen, szero, sdollar;
	int	s1, s1lim, s2, s2lim;
d795 1
a795 1
	int	i_minl, i_maxl, i_len;
d797 1
a797 2
	int	i1_maxl, i2_maxl, i3_maxl;
	int	h, h3, hlen, n_mpr;
d802 1
a802 1
	slen = sdollar - szero + 1;
a818 1
	i1_maxl = stp->s_maxilen;
a819 1
	i2_maxl = stp1->s_maxilen;
a820 1
	i3_maxl = stp2->s_maxilen;
d844 2
a845 4
	int	slen, szero, sdollar;
	int	s, s1, s1lim, s2, s2lim;
	int	h_minl, h_maxl;
	int	i_minl, i_maxl, i_len;
d854 1
a854 2
	sdollar = srp->s_dollar;
	slen = sdollar - szero + 1;
a859 2
	h_minl = stp->s_minlen;
	h_maxl = stp->s_maxlen;
d924 1
a924 1
	int	s, s3_5plim;
d926 1
a926 1
	int	mplim, mpr, l_n_mpr, l_pr;
a944 1
		l_pr = 1;
a948 1
		l_pr = 0;
a958 1
					l_pr = 1;
a962 1
				l_pr = 1;
a966 1
			l_pr = 0;
d1015 1
a1015 1
	int	mplim, mpr, l_pr;
d1089 1
a1089 1
	int	mplim, mpr, l_pr;
d1147 1
a1147 1
	int	mplim, mpr, l_pr;
d1694 1
a1694 1
	char	mbuf[ 256 ], cstr[ 256 ];
a1750 15
}
static	void	set_mbuf( off, len, mbuf )
int	off;
int	len;
char	mbuf[];
{

	if( len <= 20 ){
		strncpy( mbuf, &fm_sbuf[ off ], len );
		mbuf[ len ] = '\0';
	}else{
		sprintf( mbuf, "%.*s...(%d)...%.*s",
			3, &fm_sbuf[ off ], len,
			3, &fm_sbuf[ off + len - 3 ] );
	}
@


1.83
log
@added code to permit helices to begin and/or end with a mispair.
@
text
@d40 1
d42 5
d147 2
a148 2
	STREL_T	*stp;
	SEARCH_T	*n_srp;
d151 2
d156 1
d163 1
a163 1
	}else{
d167 1
d169 1
d183 1
a183 1
	}else	
a197 1

d207 3
d255 1
d271 3
a273 3
		if( !chk_sites( rm_n_descr, rm_descr, rm_sites ) )
			return( 0 );
		if( RM_score( fm_sbuf, &fm_score ) )
d293 1
a293 1
	int	s, s3lim, slen, szero, sdollar;
d296 1
a296 1
	int	h, h3, hlen, n_mpr;
d348 1
a348 1
static	int	find_pknot(  srp )
d455 198
d938 1
a938 1
static	int	match_wchlx( stp, stp3, s5, s3, s3lim, h3, hlen, n_mpr )
d1304 1
a1304 1
	stp->s_matchlen = 0;
d1340 1
a1340 1
	stp5->s_matchlen = 0;
d1342 1
a1342 1
	stp3->s_matchlen = 0;
@


1.82
log
@intermediate stage in allowing mispairs to begin & end helix: converted
s_proper into s_attr & SA_PROPER
@
text
@d738 1
a738 1
	int	mplim, mpr, l_pr;
d741 4
a744 13
	b5 = fm_sbuf[ s5 ];
	b3 = fm_sbuf[ s3 ];

	if( !RM_paired( stp->s_pairset, b5, b3 ) )
		return( 0 );

	*h3 = s3;	/* index of 5' base of h3	*/
	i_lpb = 0;	/* index of last paired base	*/
	l_pr = 1;	/* last position is paired	*/
	*n_mpr = 0;	/* number of mispairs		*/
	mplim = 0;	/* max. number of mispairs	*/
	pfrac = 0;	/* check against pfrac		*/ 

d751 16
a766 20
/*
	for( *hlen = 1, s = s3 - 1; s >= s3lim; s-- ){
		b5 = fm_sbuf[ s5 + *hlen ];
		b3 = fm_sbuf[ s3 - *hlen ];
		if( RM_paired( stp->s_pairset, b5, b3 ) ){
			l_pr = 1;
			i_lpb = *hlen;
		}else{
			l_pr = 0;
			mpr++;
			if( mpr > mplim ){
				if( *hlen < stp->s_minlen )
					return( 0 );
				else
					break;
			}
		}
		( *hlen )++;
	}
*/
d775 1
d780 1
d794 3
a796 1
	if( *hlen != i_lpb + 1 )	/* must end on a pair! */
d798 7
a834 1
	b3 = fm_sbuf[ s3 ];
d844 1
d847 9
a855 1
		if( !RM_paired( stp->s_pairset, b5, b3 ) )
a856 3
		*hlen = 1;
		*n_mpr = 0;
		l_pr = 1;
d871 4
a874 2
		if( !l_pr )	/* must end on a pair	*/
			return( 0 );
a907 3
	b1 = fm_sbuf[ s1 ];
	b2 = fm_sbuf[ s2 ];
	b3 = fm_sbuf[ s3 - tlen + 1 ];
d914 10
a923 2

	if( !RM_triple( stp->s_pairset, b1, b2, b3 ) )
a924 2
	else
		l_pr = 1;
d926 1
a926 1
	for( *n_mpr = 0, t = 1; t < tlen; t++ ){
d939 4
a942 2
	if( !l_pr )
		return( 0 );
a965 4
	b1 = fm_sbuf[ s1 + qlen - 1 ];
	b2 = fm_sbuf[ s2 ];
	b3 = fm_sbuf[ s3 ];
	b4 = fm_sbuf[ s4 - qlen + 1 ];
d972 11
a982 1
	if( !RM_quad( stp1->s_pairset, b1, b2, b3, b4 ) )
a983 2
	else
		l_pr = 1;
d998 4
a1001 3

	if( !l_pr )
		return( 0 );
@


1.81
log
@modified RM_score() to return the score value and modified print_match()
to print it.
@
text
@d193 1
a193 1
		if( stp->s_proper ){
@


1.80
log
@acquire and save in the descriptors the # of mismatches and mispairs;
Renamed paired(), triple() and quad() to RM_paired(), RM_triple() and
RM_quad() as they are now also used by the scoring section to evaluate
the builtin fnxn paired().
@
text
@d29 1
d259 1
a259 1
		if( RM_score( fm_sbuf ) )
d1500 1
d1523 1
a1523 1
	fprintf( fp, "%-12s %d", sid, comp );
@


1.79
log
@added code to implement pairfrac= option for h*, p*, t* and q*
elements.  This makes it easier to write varying length helix
with mispairs withouth being force to set mispair high enough
to deal with the longest length and as a result getting really
bad helices for shorted lengths.
@
text
@a47 3
static	int	paired();
static	int	triple();
static	int	quad();
d236 2
d281 1
a281 1
	int	h, h3, hlen;
d290 2
d293 2
d307 1
a307 1
	if( match_wchlx( stp, stp3, szero, sdollar, s3lim, &h3, &hlen ) ){
d318 2
d344 1
a344 1
	int	h13, h1len;
d346 1
a346 1
	int	h23, h2len;
d356 2
a357 1

d359 2
d362 2
d365 2
d395 2
a396 1
	if( match_wchlx( stp, stp2, szero, s1_dollar, s13_lim, &h13, &h1len ) ){
d405 2
a406 2
			if(match_wchlx(stp1,stp3,
				s2,sdollar,s23_lim,&h23,&h2len)){
d418 4
d448 1
a448 1
	int	h, hlen;
d456 2
d459 3
d480 1
a480 1
	if( match_phlx( stp, stp3, szero, sdollar, s5hi, s5lo, &hlen ) ){
d486 2
d512 1
a512 1
	int	h, hlen;
d520 2
d523 2
d526 2
d552 1
a552 1
	if( match_phlx( stp, stp2, szero, sdollar, s5hi, s5lo, &hlen ) ){
d561 2
a562 1
			if(match_triplex( stp, stp1, szero, s, sdollar, hlen )){
d571 3
d600 1
a600 1
	int	h, h3, hlen;
d607 2
d610 2
d613 2
d616 2
d636 1
a636 1
	if( match_wchlx( stp, stp3, szero, sdollar, s3lim, &h3, &hlen ) ){
d656 1
a656 1
	int	i1_len, i2_len, i3_len;
d692 1
a692 1
				szero, s1, s2, s3, hlen ) ){
d704 4
d725 1
a725 1
static	int	match_wchlx( stp, stp3, s5, s3, s3lim, h3, hlen )
d733 1
d743 1
a743 1
	if( !paired( stp->s_pairset, b5, b3 ) )
d749 1
a749 1
	mpr = 0;	/* number of mispairs		*/
d763 1
a763 1
		if( paired( stp->s_pairset, b5, b3 ) ){
d782 1
a782 1
		if( paired( stp->s_pairset, b5, b3 ) ){
d784 1
a784 1
				if(1.*(*hlen-mpr)/(*hlen) >= stp->s_pairfrac){
d794 2
a795 2
			mpr++;
			if( mpr > mplim ){
d821 1
a821 1
static	int	match_phlx( stp, stp3, s5, s3, s5hi, s5lo, hlen )
d829 1
d848 1
a848 1
		if( !paired( stp->s_pairset, b5, b3 ) )
d851 1
a851 1
		mpr = 0;
d856 1
a856 1
			if( paired( stp->s_pairset, b5, b3 ) ){
d860 2
a861 5
				mpr++;
/*
				if( mpr > stp->s_mispair ){
*/
				if( mpr > mplim ){
d872 1
a872 1
			if( 1.*(*hlen-mpr)/(*hlen) < stp->s_pairfrac )
d889 1
a889 1
static	int	match_triplex( stp, stp1, s1, s2, s3, tlen )
d896 1
d912 1
a912 1
	if( !triple( stp->s_pairset, b1, b2, b3 ) )
d917 1
a917 1
	for( mpr = 0, t = 1; t < tlen; t++ ){
d921 1
a921 1
		if( !triple( stp->s_pairset, b1, b2, b3 ) ){
d923 2
a924 5
			mpr++;
/*
			if( mpr > stp->s_mispair )
*/
			if( mpr > mplim )
d941 1
a941 1
static	int	match_4plex( stp1, stp2, s1, s2, s3, s4, qlen )
d949 1
d965 1
a965 1
	if( !quad( stp1->s_pairset, b1, b2, b3, b4 ) )
d970 1
a970 1
	for( mpr = 0, q = 1; q < qlen; q++ ){
d975 1
a975 1
		if( !quad( stp1->s_pairset, b1, b2, b3, b4 ) ){
d977 2
a978 5
			mpr++;
/*
			if( mpr > stp1->s_mispair )
*/
			if( mpr > mplim )
d1000 1
a1000 1
static	int	paired( ps, b5, b3 )
d1016 1
a1016 1
static	int	triple( ps, b1, b2, b3 )
d1034 1
a1034 1
static	int	quad( ps, b1, b2, b3, b4 )
d1139 1
a1139 1
	return( !paired( stp->s_pairset, b5, b3 ) );
d1210 1
a1210 1
				if( paired( stp->s_pairset, b5, b3 ) )
d1225 1
a1225 1
		if( paired( stp->s_pairset, b5, b3 ) )
d1260 1
a1260 1
			if( paired( stp->s_pairset, b5, b3 ) )
d1275 1
a1275 1
			if( paired( stp->s_pairset, b5, b3 ) )
d1322 1
a1322 1
			if( triple( stp->s_pairset, b1, b2, b3 ) )
d1342 1
a1342 1
			if( triple( stp->s_pairset, b1, b2, b3 ) )
d1398 1
a1398 1
				if( quad( stp->s_pairset, b1, b2, b3, b4 ) )
d1422 1
a1422 1
		if( quad( stp->s_pairset, b1, b2, b3, b4 ) )
d1475 1
a1475 1
		rv = paired( sip->s_pairset, b[ 0 ], b[ 1 ] );
d1477 1
a1477 1
		rv = triple( sip->s_pairset, b[ 0 ], b[ 1 ], b[ 2 ] );
d1479 1
a1479 1
		rv = quad( sip->s_pairset, b[ 0 ], b[ 1 ], b[ 2 ], b[ 3 ] );
d1581 2
a1582 1
		return( mm_step( fm_chk_seq, stp->s_expbuf, stp->s_mismatch ) );
@


1.78
log
@about to start adding pairfrac=
@
text
@d690 2
a691 3
	int	mpr, l_pr;
	int	mpcnt[ 100 ];
	int	i_lpb;
d699 14
a712 5
	*h3 = s3;
	mpcnt[ 0 ] = 0;
	i_lpb = 0;
	l_pr = 1;
	mpr = 0;
a718 1
			mpcnt[ *hlen ] = mpr;
d722 27
a748 2
			mpcnt[ *hlen ] = mpr;
			if( mpr > stp->s_mispair ){
d784 3
a786 2
	int	b50, b5, b3;
	int	mpr, l_pr;
a787 1
	b50 = fm_sbuf[ s5 ];
d789 8
a809 1
				( *hlen )++;
d813 1
d815 2
a818 1
				( *hlen )++;
d820 1
d826 4
d854 1
a854 1
	int	mpr, l_pr;
d859 6
d878 1
d880 2
d909 1
a909 1
	int	mpr, l_pr;
d915 5
d934 1
d936 2
@


1.77
log
@changed refs to errormsg() to RM_errormsg().
@
text
@a247 11
/*
		strncpy( fm_chk_seq, &fm_sbuf[ szero ], slen );
		fm_chk_seq[ slen ] = '\0';
		circf = *stp->s_seq == '^';
		if( stp->s_mismatch > 0 ){
			if( !mm_step( fm_chk_seq,
				stp->s_expbuf, stp->s_mismatch ) )
				return( 0 );
		}else if( !step( fm_chk_seq, stp->s_expbuf ) )
			return( 0 );
*/
a704 20
/*
	for( bpcnt = 1, *hlen = 1, s = s3 - 1; s >= s3lim; s--, (*hlen)++ ){

		b5 = fm_sbuf[ s5 + *hlen ];
		b3 = fm_sbuf[ s3 - *hlen ];
		if( paired( stp->s_pairset, b5, b3 ) ){
			bpcnt++;
		}else{
			mpr++;
			if( mpr > stp->s_mispair ){
				if( *hlen < stp->s_minlen )
					return( 0 );
				else
					break;
			}
		}
	}
	if( bpcnt < stp->s_minlen || bpcnt > stp->s_maxlen )
		return( 0 );
*/
a705 1

a732 11
/*
		strncpy( fm_chk_seq,  &fm_sbuf[ s5 ], *hlen );
		fm_chk_seq[ *hlen ] = '\0';
		circf = *stp->s_seq == '^';
		if( stp->s_mismatch > 0 ){
			if( !mm_step( fm_chk_seq,
				stp->s_expbuf, stp->s_mismatch ) )
				return( 0 );
		}else if( !step( fm_chk_seq, stp->s_expbuf ) )
			return( 0 );
*/
a736 11
/*
		strncpy( fm_chk_seq,  &fm_sbuf[ s3 - *hlen + 1 ], *hlen );
		fm_chk_seq[ *hlen ] = '\0';
		circf = *stp3->s_seq == '^';
		if( stp3->s_mismatch > 0 ){
			if( !mm_step( fm_chk_seq,
				stp3->s_expbuf, stp3->s_mismatch ) )
				return( 0 );
		}else if( !step( fm_chk_seq, stp3->s_expbuf ) )
			return( 0 );
*/
a764 15
/*
		for( s1 = s - 1; s1 >= s5; s1--, (*hlen)++ ){
			b5 = fm_sbuf[ s1 ];
			b3 = fm_sbuf[ s3 - bpcnt ];
			if( paired( stp->s_pairset, b5, b3 ) ){
				bpcnt++;
			}else{
				mpr++;
				if( mpr > stp->s_mispair )
					return( 0 );
			}
		}
		if( bpcnt < stp->s_minlen || bpcnt > stp->s_maxlen )
			return( 0 );
*/
a787 11
/*
			strncpy( fm_chk_seq, &fm_sbuf[ s5 ], *hlen );
			fm_chk_seq[ *hlen ] = '\0'; 
			circf = *stp->s_seq == '^';
			if( stp->s_mismatch > 0 ){
				if( !mm_step( fm_chk_seq,
					stp->s_expbuf, stp->s_mismatch ) )
					return( 0 );
			} else if( !step( fm_chk_seq, stp->s_expbuf ) )
				return( 0 );
*/
a791 11
/*
			strncpy( fm_chk_seq, &fm_sbuf[ s3-*hlen+1 ], *hlen );
			fm_chk_seq[ *hlen ] = '\0'; 
			circf = *stp3->s_seq == '^';
			if( stp3->s_mismatch > 0 ){
				if( !mm_step( fm_chk_seq,
					stp3->s_expbuf, stp3->s_mismatch ) )
					return( 0 );
			}else if( !step( fm_chk_seq, stp3->s_expbuf ) )
				return( 0 );
*/
a837 11
/*
		strncpy( fm_chk_seq, &fm_sbuf[ s2 - tlen + 1 ], tlen );
		fm_chk_seq[ tlen ] = '\0';
		circf = *stp1->s_seq == '^';
		if( stp1->s_mismatch > 0 ){
			if( !mm_step( fm_chk_seq,
				stp1->s_expbuf, stp1->s_mismatch ) )
				return( 0 );
		}else if( !step( fm_chk_seq, stp1->s_expbuf ) )
			return( 0 );
*/
a885 11
/*
		strncpy( fm_chk_seq, &fm_sbuf[ s2 ], qlen );
		fm_chk_seq[ qlen ] = '\0';
		circf = *stp1->s_seq == '^';
		if( stp1->s_mismatch > 0 ){
			if( !mm_step( fm_chk_seq,
				stp1->s_expbuf, stp1->s_mismatch ) )
				return( 0 );
		}else if( !step( fm_chk_seq, stp1->s_expbuf ) )
			return( 0 );
*/
a890 11
/*
		strncpy( fm_chk_seq, &fm_sbuf[ s3 - qlen + 1 ], qlen );
		fm_chk_seq[ qlen ] = '\0';
		circf = *stp2->s_seq == '^';
		if( stp2->s_mismatch > 0 ){
			if( !mm_step( fm_chk_seq,
				stp2->s_expbuf, stp2->s_mismatch ) )
				return( 0 );
		}else if( !step( fm_chk_seq, stp2->s_expbuf ) )
			return( 0 );
*/
a904 3
/*
	bpmatp = stp->s_pairset->ps_mat[ 0 ];
*/
a921 3
/*
	btmatp = stp->s_pairset->ps_mat[ 1 ];
*/
a940 3
/*
	bqmatp = stp->s_pairset->ps_mat[ 1 ];
*/
a1471 4
/*
	strncpy( fm_chk_seq, seq, slen );
	fm_chk_seq[ slen ] = '\0';
*/
@


1.76
log
@changed name of SC_run() to RM_score()
@
text
@d93 1
a93 1
			errormsg( 1,
d97 1
a97 1
				errormsg( 1,
d103 1
a103 1
			errormsg( 1,
d108 1
a108 1
			errormsg( 1,
d222 1
a222 1
		errormsg( 1, fm_emsg );
@


1.75
log
@pass the seq buf to SC_run().
@
text
@d270 1
a270 1
		if( SC_run( fm_sbuf ) )
@


1.74
log
@incorrectly transferred offset of h3 matching seq to chk_seq() in
match_wchlx().
@
text
@d270 1
a270 1
		if( SC_run() )
@


1.73
log
@change name of find_id() to RM_find_id().
@
text
@d778 1
a778 1
		if( !chk_seq( stp3, &fm_sbuf[ s3 ], *hlen ) )
@


1.72
log
@commented out call to chk_wchlx0() in find_wchlx() as extension towards
the outside is to be permitted.
@
text
@d69 1
a69 1
IDENT_T	*find_id();
d91 1
a91 1
		ip = find_id( "windowsize" );
d270 3
a272 1
		print_match( stdout, fm_sid, fm_comp, rm_n_descr, rm_descr );
@


1.71
log
@replaced code that checked seq= with chk_seq() that converts any u's in
the *data* into t's so that rna data works as well as dna data.
moved chk_sites() from chk_motif() which is not called as it was too
strict to precede so chk_sites() is always called.
@
text
@d315 1
d318 1
@


1.70
log
@fixed `off by 1' error in computing the length of the i2 region
in find_triplex().
@
text
@d63 1
d246 3
d258 1
d268 2
d759 3
d771 1
d774 3
d786 1
d851 3
d863 1
d866 3
d878 1
d923 3
d935 1
d982 3
d994 1
d998 3
d1010 1
d1591 22
@


1.69
log
@add code to print_match() that checks fm_dtype and for DT_FASTN
prints the def line before printing the seq info.
@
text
@d536 1
a536 1
				i2_len = sdollar - hlen - s + 1;
@


1.68
log
@return sdef from FN_fgetseq().  Modified the output of print_match()
to facilitate printing the definition should Isis really want to do
this.
@
text
@d1509 2
@


1.67
log
@changed the name of locus to seqid to reflect the fact that
it may not just contain the locus name, but also the ident
of the fastn record.
@
text
@d23 3
a25 2
static	char	*fm_seqid;
static	int	fm_comp;
d71 1
a71 1
	seqid, comp, slen, sbuf )
d75 3
a77 1
char	seqid[];
d111 3
a113 1
	fm_seqid = seqid;
d263 1
a263 1
		print_match( stdout, fm_seqid, fm_comp, rm_n_descr, rm_descr );
d267 1
a267 1
			print_match( stdout, fm_seqid, fm_comp,
d1474 1
a1474 1
static	void	print_match( fp, seqid, comp, n_descr, descr )
d1476 1
a1476 1
char	seqid[];
a1502 2
	fprintf( fp, "%-12s %d", seqid, comp );
/*
d1504 1
a1504 3
	set_mbuf( stp->s_matchoff, stp->s_matchlen, mbuf );

	if( fm_comp ){
d1509 1
a1509 7
	fprintf( fp, " %7d %4d %s", offset, len, mbuf );
*/
	stp = descr; 
	if( fm_comp ){
		offset = fm_slen - stp->s_matchoff;
	}else
		offset = stp->s_matchoff + 1;
a1513 4
/*
			set_mbuf( stp->s_matchoff, stp->s_matchlen, mbuf );
			fprintf( fp, " %s", mbuf );
*/
@


1.66
log
@modified to use mm_step() if s_mismatch > 0 and step()
otherwise.
@
text
@d23 1
a23 1
static	char	*fm_locus;
d70 1
a70 1
	locus, comp, slen, sbuf )
d74 1
a74 1
char	locus[];
d108 1
a108 1
	fm_locus = locus;
d258 1
a258 1
		print_match( stdout, fm_locus, fm_comp, rm_n_descr, rm_descr );
d262 1
a262 1
			print_match( stdout, fm_locus, fm_comp,
d1469 1
a1469 1
static	void	print_match( fp, locus, comp, n_descr, descr )
d1471 1
a1471 1
char	locus[];
d1498 1
a1498 1
	fprintf( fp, "%-12s %d", locus, comp );
@


1.65
log
@set circf to reflect if an RE begins with ^, as this is not saved by
the expbuf used to find RE's.
@
text
@d243 5
a247 1
		if( !step( fm_chk_seq, stp->s_expbuf ) )
d750 5
a754 1
		if( !step( fm_chk_seq, stp->s_expbuf ) )
d761 5
a765 1
		if( !step( fm_chk_seq, stp3->s_expbuf ) )
d834 5
a838 1
			if( !step( fm_chk_seq, stp->s_expbuf ) )
d845 5
a849 1
			if( !step( fm_chk_seq, stp3->s_expbuf ) )
d898 5
a902 1
		if( !step( fm_chk_seq, stp1->s_expbuf ) )
d953 5
a957 1
		if( !step( fm_chk_seq, stp1->s_expbuf ) )
d965 5
a969 1
		if( !step( fm_chk_seq, stp2->s_expbuf ) )
@


1.64
log
@added code to print any user given tags in the #RM descr line.
Also changed this line from #RM fmt.
Finally print the entire selected string.
@
text
@d20 2
d242 1
d745 1
d752 1
d821 1
d828 1
d877 1
d928 1
d936 1
@


1.63
log
@fixed bug that switched order of bmatp[ 0 ], the reduced
matrix and bmatp[1] the full (3-plex, 4-plex) matrix.
Also added in mispairing.
@
text
@d62 1
a965 3
/*
	btmatp = ps->ps_mat[ 0 ];
*/
a987 3
/*
	bqmatp = ps->ps_mat[ 0 ];
*/
d1438 1
a1438 1
	char	mbuf[ 256 ];
d1442 1
a1442 1
		fprintf( fp, "#RM fmt" );
d1446 4
d1457 1
d1467 7
d1475 1
a1475 1
	for( ++stp, d = 1; d < n_descr; d++, stp++ ){
d1477 1
d1480 3
d1489 18
@


1.62
log
@commented out code that checks for potential extension of
the various helical elements, as rnamot1 does not disqualify
a sequence when this happens so we can't either.
@
text
@d677 3
a679 1
	int	bpcnt, mpr;
d688 3
a690 2
	bpcnt = 1;
	*hlen = 1;
d692 1
d711 26
d765 1
a765 1
	int	bpcnt, mpr;
a773 1
		bpcnt = 1;
d776 2
d791 20
d839 1
a839 1
	int	bpcnt, mpr;
d847 4
a850 4

	bpcnt = 1;
	mpr = 0;
	for( t = 1; t < tlen; t++ ){
d855 1
d859 2
a860 1
		}
d863 3
d887 1
a887 1
	int	bpcnt, mpr;
d896 2
d899 1
a899 3
	bpcnt = 1;
	mpr = 0;
	for( q = 1; q < qlen; q++ ){
d905 1
d909 2
a910 1
		}
d913 3
d965 1
d967 2
d990 1
d992 2
d1427 1
a1427 1
		rv = quad( sip->s_pairset, b[ 0 ], b[ 1 ], b[ 2 ], b[ 4 ] );
@


1.61
log
@added code to print_match() to precede found strings with a line
beginning #RM fmt dn1 dn2 ... dnN
where the dni are the strel names (h5, ss, etc)
@
text
@d249 3
d253 1
a255 1
			rv = 1;
d258 1
@


1.60
log
@sites working!
remaining stuff - IUPAC translation; fix bug in mispair=X, X!=0, do
something with mismatch=X (probably move it to scoring); add pairfrac=X.
@
text
@d1368 2
d1374 9
@


1.59
log
@need to changed paired(), triple() and quad() to take pointer to a pairset
rather than a pointer to descriptor.
@
text
@d678 1
a678 1
	if( !paired( stp, b5, b3 ) )
d689 1
a689 1
		if( paired( stp, b5, b3 ) ){
d738 1
a738 1
		if( !paired( stp, b5, b3 ) )
d746 1
a746 1
			if( paired( stp, b5, b3 ) ){
d790 1
a790 1
	if( !triple( stp, b1, b2, b3 ) )
d799 1
a799 1
		if( !triple( stp, b1, b2, b3 ) ){
d834 1
a834 1
	if( !quad( stp1, b1, b2, b3, b4 ) )
d844 1
a844 1
		if( !quad( stp1, b1, b2, b3, b4 ) ){
d868 2
a869 2
static	int	paired( stp, b5, b3 )
STREL_T	*stp;
d877 1
d879 2
d887 2
a888 2
static	int	triple( stp, b1, b2, b3 )
STREL_T	*stp;
d897 1
d899 2
d908 2
a909 2
static	int	quad( stp, b1, b2, b3, b4 )
STREL_T	*stp;
d919 1
d921 2
d1016 1
a1016 1
	return( !paired( stp, b5, b3 ) );
d1087 1
a1087 1
				if( paired( stp, b5, b3 ) )
d1102 1
a1102 1
		if( paired( stp, b5, b3 ) )
d1137 1
a1137 1
			if( paired( stp, b5, b3 ) )
d1152 1
a1152 1
			if( paired( stp, b5, b3 ) )
d1199 1
a1199 1
			if( triple( stp, b1, b2, b3 ) )
d1219 1
a1219 1
			if( triple( stp, b1, b2, b3 ) )
d1275 1
a1275 1
				if( quad( stp, b1, b2, b3, b4 ) )
d1299 1
a1299 1
		if( quad( stp, b1, b2, b3, b4 ) )
a1332 2
fprintf( stderr, "c1s: site has %d pos\n", sip->s_n_pos );

a1348 5

fprintf( stderr, "c1s: pos[ %2d] = %4d:%d:%4d, o,l, s = %4d, %4d, %4d, '%c'\n",
	p, pp->p_dindex, ap->a_l2r, ap->a_offset,
	stp->s_matchoff, stp->s_matchlen, s[ p ], b[ p ] );

a1350 4
fprintf( stderr, "c1s: pairset  = " );
RM_dump_pairmat( stderr, stp->s_pairset );
fprintf( stderr, "\n" );

d1352 1
a1352 2
		rv = paired( stp, b[ 0 ], b[ 1 ] );
fprintf( stderr, "c1s.2: rv = %d\n", rv );
d1354 1
a1354 2
		rv = triple( stp, b[ 0 ], b[ 1 ], b[ 2 ] );
fprintf( stderr, "c1s.3: rv = %d\n", rv );
d1356 1
a1356 2
		rv = quad( stp, b[ 0 ], b[ 1 ], b[ 2 ], b[ 4 ] );
fprintf( stderr, "c1s.4: rv = %d\n", rv );
@


1.58
log
@small reordering of local variables of the various find_x() functions to
have (as much as possible) a common ordering.
@
text
@d15 1
d58 2
d81 1
d114 1
a114 1
	for( fm_szero = 0; fm_szero < l_szero; fm_szero++ ){
d119 1
a119 1
		find_motif( srp );
d126 1
a126 1
		find_motif( srp );
d128 1
a128 2

	return( 0 );
d249 1
a249 1
		if( chk_motif( rm_n_descr, rm_descr ) ){
d1010 1
a1010 1
static	int	chk_motif( n_descr, descr )
d1013 1
d1043 4
a1046 1
	return( 1 );
d1297 69
a1414 1

@


1.57
log
@all done, really! Forgot to fixed find_pknot().  But fixed now.
@
text
@d220 3
a222 1
	STREL_T	*stp, *n_stp;
a223 1
	int	s, slen, szero, sdollar;
d260 1
a260 1
	STREL_T	*stp, *stp3, *i_stp, *n_stp;
d265 2
a266 1
	SEARCH_T	*i_srp, *n_srp;
d469 1
a470 1
	SEARCH_T	*i1_srp, *i2_srp;
a587 1
	STREL_T	*i1_stp, *i2_stp, *i3_stp;
d595 1
@


1.56
log
@all fixed.
@
text
@d283 1
d302 2
a303 2
	}else
		return( 0 );
d323 1
d360 1
d374 2
a375 4
				if( i1_len > i1_maxl ){
					unmark_duplex(stp,szero,stp2,h13,h1len);
					return( 0 );
				}
d377 2
a378 4
				if( i2_len > i2_maxl ){
					unmark_duplex(stp,szero,stp2,h13,h1len);
					return( 0 );
				}
d380 2
a381 4
				if( i3_len > i3_maxl ){
					unmark_duplex(stp,szero,stp2,h13,h1len);
					return( 0 );
				}
d392 2
a393 7
				if( find_motif( i1_srp ) ){
					return( 1 );
				}else{
					unmark_duplex(stp,szero,stp2,h13,h1len);
					unmark_duplex(stp1,s2,stp3,h23,h2len );
					return( 0 );
				}
d396 1
d398 1
a398 1
	return( 0 );
@


1.55
log
@fixed ss, wchlx, phlx & triplex.  Still need to do 4-plex.
@
text
@d265 1
d299 1
a299 13
/*
		if( find_motif( i_srp ) ){
			return( 1 );
		}else{
			unmark_duplex( stp, szero, stp3, h3, hlen );
			return( 0 );
		}
*/
		if( find_motif( i_srp ) ){
			return( 1 );
		}else{
			return( 0 );
		}
d418 1
d442 1
d456 4
a459 8
		if( find_motif( i_srp ) ){
			return( 1 );
		}else{
			unmark_duplex( stp, szero, stp3, sdollar, hlen );
			return( 0 );
		}
	}else
		return( 0 );
d552 1
d578 1
d580 5
a584 6
		if( find_4plex_inner( srp, h3, hlen ) )
			return( 1 );
		else
			return( 0 );
	}else
		return( 0 );
d602 1
d629 1
d639 1
a639 1
					return( 0 );
d642 1
a642 1
					return( 0 );
d645 1
a645 1
					return( 0 );
a646 1
				mark_duplex( stp, szero, stp3, s3, hlen );
d656 2
a657 8
				if( find_motif( i1_srp ) )
					return( 1 );
				else{
					unmark_duplex( stp, szero,
						stp3, s3, hlen );
					unmark_duplex( stp1, s1,
						stp2, s2, hlen );
				}
d661 1
a661 1
	return( 0 );
@


1.54
log
@all there but sites!
@
text
@d47 2
d153 1
a155 1

a158 2
			}else{

d160 1
a160 2

			rv = find_1_motif( srp );
d206 1
d223 1
d239 1
a239 5
	for( s = 0; s < slen; s++ ) 
		fm_window[ szero + s - fm_szero ] = stp->s_index;
	stp->s_matchoff = szero;
	stp->s_matchlen = slen;

d243 1
a243 7
		if( find_motif( n_srp ) ){
			return( 1 );
		}else{
			for( s = 0; s < slen; s++ ) 
				fm_window[ szero + s - fm_szero ] = UNDEF;
			return( 0 );
		}
d245 1
a245 1
		if( chk_motif( rm_n_descr, rm_descr ) )
d248 3
d252 2
a253 2

	return( 1 );
d298 1
d305 7
d487 1
d519 1
d526 2
d533 1
a533 1
					return( 0 );
d536 1
a536 1
					return( 0 );
d538 1
a538 5
				mark_duplex( stp, szero, stp2, sdollar, hlen );
				stp1->s_matchoff = s - hlen + 1;
				stp1->s_matchlen = hlen;
				for( s1 = 0; s1 < hlen; s1++ )
					fm_window[s-s1-fm_szero]=stp1->s_index;
d545 2
a546 10
				if( find_motif( i1_srp ) ){
					return( 1 );
				}else{
					unmark_duplex( stp, szero,
						stp2, sdollar, hlen);
					stp1->s_matchoff = UNDEF;
					stp1->s_matchlen = 0;
					for( s1 = 0; s1 < hlen; s1++ )
						fm_window[s-s1-fm_szero]=UNDEF;
				}
d549 3
a551 2
	}else
		return( 0 );
d941 28
d1004 2
a1005 2
		fm_window[ h5+h-fm_szero ] = stp5->s_index;
		fm_window[ h3-h-fm_szero ] = stp5->s_index;
@


1.53
log
@triples done.
@
text
@d39 1
d43 1
d46 1
d54 1
a552 1

d562 16
d579 105
d840 52
d926 20
d1030 2
d1142 1
d1205 79
@


1.52
log
@find_triplex() is in although not checked in chk_motif.
@
text
@d50 1
d830 2
a911 18
/*
	if( h5_5 > 0 ){
		if( h3_3 < fm_slen - 1 ){
			h5 = h5_5 - 1;
			h3 = h3_3 + 1;
			d5 = fm_window[ h5 - fm_szero ];
			d3 = fm_window[ h3 - fm_szero ];
			stpd5 = &descr[ d5 ];
			stpd3 = &descr[ d3 ];
			if( stpd5->s_type==SYM_SS && stpd3->s_type==SYM_SS ){
				b5 = fm_sbuf[ h5 ];
				b3 = fm_sbuf[ h3 ];
				if( paired( stp, b5, b3 ) )
					return( 0 );
			}
		}
	}
*/
d938 66
@


1.51
log
@temp stopping point on the way to triples & quads.  Changing
match_wchlx() and match_phlx() to include the stp of the 3' part.
@
text
@d41 1
d43 1
d271 1
d283 1
a283 1
	if( match_wchlx( stp, szero, sdollar, s3lim, &h3, &hlen ) ){
a291 1
		stp3 = stp->s_mates[ 0 ];
d362 1
a362 1
	if( match_wchlx( stp, szero, s1_dollar, s13_lim, &h13, &h1len ) ){
d371 2
a372 1
			if(match_wchlx(stp1,s2,sdollar,s23_lim,&h23,&h2len)){
d427 1
d445 1
a445 1
	if( match_phlx( stp, szero, sdollar, s5hi, s5lo, &hlen ) ){
a450 1
		stp3 = stp->s_mates[ 0 ];
d471 4
a474 3
	STREL_T	*stp, *stp3, *i_stp;
	int	ilen, slen, szero, sdollar;
	int	s, s3lim, s5hi, s5lo;
d476 3
a478 1
	int	i_minl, i_maxl, i_len;
d480 1
a480 1
	SEARCH_T	*i_srp;
d486 2
d491 8
a498 2
	i_minl = stp->s_minilen;
	i_maxl = stp->s_maxilen;
d500 1
a500 1
	s5hi = MIN( ( slen - i_minl ) / 2, h_maxl );
d503 3
a505 3
	ilen = slen - 2 * h_minl;
	ilen = MIN( ilen, i_maxl );
	s5lo = slen - ilen;
d511 1
a511 5
	if( match_phlx( stp, szero, sdollar, s5hi, s5lo, &hlen ) ){

fprintf( stderr, "ft: %-12s %4d %4d, %4d: %.*s %.*s\n",
	fm_locus, szero, sdollar - hlen + 1, hlen,
	hlen, &fm_sbuf[ szero ], hlen, &fm_sbuf[ sdollar - hlen + 1 ] );
a512 1
/*
d514 1
a514 1
		if( i_len > i_maxl  )
d517 20
a536 2
		stp3 = stp->s_mates[ 0 ];
		mark_duplex( stp, szero, stp3, sdollar, hlen );
d538 10
a547 4
		i_stp = stp->s_inner;
		i_srp = rm_searches[ i_stp->s_searchno ];
		i_srp->s_zero = szero + hlen;
		i_srp->s_dollar = sdollar - hlen;
d549 1
a549 5
		if( find_motif( i_srp ) ){
			return( 1 );
		}else{
			unmark_duplex( stp, szero, stp3, sdollar, hlen );
			return( 0 );
a550 2
*/

d561 1
a561 1
static	int	match_wchlx( stp, s5, s3, s3lim, h3, hlen )
d563 1
a569 1
	STREL_T	*stp3;
a573 1
	stp3 = stp->s_scopes[ 1 ];
d608 2
a609 1
	}else if( stp3->s_seq != NULL ){
d619 1
a619 1
static	int	match_phlx( stp, s5, s3, s5hi, s5lo, hlen )
d621 1
d628 1
a628 2
	STREL_T	*stp3;
	int	prd, s, s1;
d635 1
a635 1
	for( prd = 0, s = s5hi; s >= s5lo; s-- ){
d653 15
d673 42
d728 18
@


1.50
log
@can find p-helices now.
@
text
@d37 2
d187 1
a187 2
		rm_emsg_lineno = stp->s_lineno;
		errormsg( 1, "triple helix finder not implemented." );
d190 1
a190 2
		rm_emsg_lineno = stp->s_lineno;
		errormsg( 1, "quad helix finder not implemented." );
d465 69
a605 1
	stp3 = stp->s_scopes[ 1 ];
@


1.49
log
@print index of last base of complement.
@
text
@d8 1
d36 3
a38 1
static	int	match_helix();
d40 2
a41 2
static	void	mark_helix();
static	void	unmark_helix();
d45 1
d182 1
a182 2
		rm_emsg_lineno = stp->s_lineno;
		errormsg( 1, "parallel helix finder not implemented." );
d280 1
a280 1
	if( match_helix( stp, szero, sdollar, s3lim, &h3, &hlen ) ){
d290 1
a290 1
		mark_helix( stp, szero, stp3, h3, hlen );
d300 1
a300 1
			unmark_helix( stp, szero, stp3, h3, hlen );
d360 1
a360 1
	if( match_helix( stp, szero, s1_dollar, s13_lim, &h13, &h1len ) ){
d362 1
a362 1
		mark_helix( stp, szero, stp2, h13, h1len );
d369 1
a369 1
			if(match_helix(stp1,s2,sdollar,s23_lim,&h23,&h2len)){
d373 1
a373 1
					unmark_helix(stp,szero,stp2,h13,h1len);
d378 1
a378 1
					unmark_helix(stp,szero,stp2,h13,h1len);
d383 1
a383 1
					unmark_helix(stp,szero,stp2,h13,h1len);
d387 1
a387 1
				mark_helix( stp1, s2, stp3, h23, h2len );
d399 2
a400 2
					unmark_helix(stp,szero,stp2,h13,h1len);
					unmark_helix(stp1,s2,stp3,h23,h2len );
d408 58
a465 1
static	int	match_helix( stp, s5, s3, s3lim, h3, hlen )
d523 40
d572 1
a572 1
	bpmatp = stp->s_pairset->ps_mat;
d579 1
a579 1
static	void	mark_helix( stp5, h5, stp3, h3, hlen )
d599 1
a599 1
static	void	unmark_helix( stp5, h5, stp3, h3, hlen )
d655 2
d717 70
a808 3
/*
		offset = fm_slen - stp->s_matchoff - len + 1;
*/
a812 3
/*
	fprintf( fp, " %7d %4d %s", stp->s_matchoff + 1, len, mbuf );
*/
@


1.48
log
@aded parm comp to find_motif_driver() which is store in static global
var fm_comp so that it can be used by print_match() to indicate the result
was found on the complement site.
@
text
@d625 1
a625 1
	int	d, len;
d635 10
d646 2
@


1.47
log
@modified print_match() to use %7d for offset vs %4d.
added ext. ref to rm_comp so print_match can know if the match is on the
actual strand (rm_comp = 0) or the complement strand (rm_comp = 1).
@
text
@a14 1
extern	int	rm_comp;
d21 1
d48 2
a49 1
int	find_motif_driver( n_searches, searches, sites, locus, slen, sbuf )
d54 1
d87 1
d245 1
a245 1
			print_match( stdout, fm_locus, rm_comp,
@


1.46
log
@fixed numerous `off by 1' errors in find_pknot() that kept it from
finding pknots with short interiors.
@
text
@d15 1
d242 1
a242 1
			print_match( stdout, fm_locus, fm_comp,
d632 1
a632 1
	fprintf( fp, " %4d %4d %s", stp->s_matchoff + 1, len, mbuf );
@


1.45
log
@found and fixed some problems with computing the available length of
the interiors of the pknot.  Still some problems with region 2. in that
that the minlen must be <1 than it should be ?
@
text
@d358 2
a359 2
		s20_lim = h13 - h1len - stp1->s_minilen - stp1->s_minlen;
		s23_lim = s1_dollar + stp2->s_minilen;
d398 2
a399 2
	}else
		return( 0 );
@


1.44
log
@change access to fm_window to subtrace fm_szero from the index to insure
that the window moves with the 1st base of the examined string.
@
text
@d364 1
a364 1
				i1_len = s2 - szero - h1len + 1;
d369 1
a369 1
				i2_len = h13 - s2 - h1len - h2len + 1;
d374 2
a375 2
				i3_len = h23 - h13 - h2len + 1;
				if( i3_len > i2_maxl ){
@


1.43
log
@fixed incorrect term condition in find_ss() that was 1) not checking
against minlen and incorrectly checking against maxlen.
@
text
@d26 1
d91 5
a95 5
	for( szero = 0; szero < l_szero; szero++ ){
		srp->s_zero = szero;
		srp->s_dollar = szero + w_winsize - 1;
		fm_window[ srp->s_zero - 1 ] = UNDEF;
		fm_window[ srp->s_dollar + 1 ] = UNDEF;
d101 2
a102 2
	for( ; szero <= l_szero; szero++ ){
		srp->s_zero = szero;
d225 1
a225 1
		fm_window[ szero + s ] = stp->s_index;
d236 1
a236 1
				fm_window[ szero + s ] = UNDEF;
d490 2
a491 2
		fm_window[ h5+h ] = stp5->s_index;
		fm_window[ h3-h ] = stp5->s_index;
d510 2
a511 2
		fm_window[ h5+h ] = UNDEF;
		fm_window[ h3-h ] = UNDEF;
a512 1

d586 2
a587 2
			d5 = fm_window[ h5 ];
			d3 = fm_window[ h3 ];
d601 2
a602 2
	d5 = fm_window[ h5 ];
	d3 = fm_window[ h3 ];
@


1.42
log
@working pseudoknot code!
@
text
@d213 2
a214 5
	n_stp = srp->s_forward;
	if( n_stp == NULL ){
		if( slen > stp->s_maxlen )
			return( 0 );
	}
@


1.41
log
@fixed incorrect helix marker.  collect helix marking lines into
a single location as preparation for converting them into a function
that can be used in find_pknot() as well as find_wchlx().
@
text
@d35 2
d285 1
a285 9
		stp->s_matchoff = szero;
		stp->s_matchlen = hlen;
		stp3->s_matchoff = h3 - hlen + 1;
		stp3->s_matchlen = hlen;

		for( h = 0; h < hlen; h++ ){
			fm_window[ szero+h ] = stp->s_index;
			fm_window[ h3-h ] = stp->s_index;
		}
d295 1
a295 4
			for( h = 0; h < hlen; h++ ){
				fm_window[ szero+h ] = UNDEF;
				fm_window[ h3-h ] = UNDEF;
			}
d312 1
d316 3
d335 2
d342 7
d357 2
d366 15
a380 4
fprintf( stderr, "fpk: h1: h5:h3 = %4d:%4d, len = %4d\n",
	szero, h13, h1len );
fprintf( stderr, "fpk: h2: h5:h3 = %4d:%4d, len = %4d\n",
	s2, h23, h2len );
d382 16
d400 2
a401 4

	}

	return( 0 );
d475 41
@


1.40
log
@fixed match_helix() to check that the found helix meets the min & max
len spec of the strel.
@
text
@d278 5
a284 1
		stp3 = stp->s_mates[ 0 ];
a287 4
		i_len = h3 - szero - 2 * hlen + 1;
		if( i_len > i_maxl )
			return( 0 );

d290 1
a290 1
			fm_window[ sdollar-h ] = stp->s_index;
d303 1
a303 1
				fm_window[ sdollar-h ] = UNDEF;
@


1.39
log
@1st working, but still imcomplete find_pknot()!
@
text
@d412 2
@


1.38
log
@reformatted 1 line.
@
text
@d167 1
a167 4
/*
			rv = find_pknot(  slev, n_searches, searches,
				szero, sdollar );
*/
d311 2
a312 6
static	int	find_pknot(  slev, n_searches, searches, szero, sdollar )
int	slev;
int	n_searches;
SEARCH_T	*searches[];
int	szero;
int	sdollar;
d314 15
d330 41
d388 1
@


1.37
log
@modified print_match() to print only the leading/trailing 3 bases of
a `long' match to a field.  This needs to be parameterized but its a start.
@
text
@d248 1
a248 1
		return( 1 );
@


1.36
log
@added code to check that no helices can be extended into regions
marked ss either of their sides.
@
text
@d40 1
d502 1
d509 2
a510 2
	fprintf( fp, " %4d %4d %.*s", stp->s_matchoff + 1, len,
		stp->s_matchlen, &fm_sbuf[ stp->s_matchoff ] );
d513 4
a516 4
		if( stp->s_matchlen > 0 )
			fprintf( fp, " %.*s", stp->s_matchlen,
				&fm_sbuf[ stp->s_matchoff ] );
		else
d520 17
@


1.35
log
@was not checking if remaining seq was longer than maxlen of last
search element.  Now returns false as soon as this is detected.
@
text
@d35 3
d242 3
a244 2
		print_match( stdout, fm_locus, fm_comp,
			rm_n_descr, rm_descr );
d277 3
d393 99
d499 1
a499 1
	int	d;
d502 3
d507 1
a507 1
	fprintf( fp, " %4d %.*s", stp->s_matchoff + 1,
@


1.34
log
@fixed print_match() to print a . for 0 length matches.
@
text
@d210 5
@


1.33
log
@write solutions to stdout, not stderr.
@
text
@d397 5
a401 2
		fprintf( fp, " %.*s", stp->s_matchlen,
			&fm_sbuf[ stp->s_matchoff ] );
@


1.32
log
@actual semiworking verion! Does recursion.
@
text
@d234 1
a234 1
		print_match( stderr, fm_locus, fm_comp,
@


1.31
log
@took recursive step. It IS in fact going to work!!!
@
text
@d10 2
d20 1
d36 2
a75 2
fprintf( stderr, "fmd   : locus = %s, slen = %d\n", locus, slen );

a125 3
fprintf( stderr, "fm    : descr = %2d, str = 0, %4d:%4d, %4d\n",
	stp->s_index, srp->s_zero, srp->s_dollar, fm_slen - 1 );

a134 2
fprintf( stderr, "fm    : descr = %2d, next = (None)\n", stp->s_index );

a154 3
fprintf( stderr, "fm1   : descr = %2d, str = 0, %4d:%4d, %4d\n",
	stp->s_index, srp->s_zero, srp->s_dollar, fm_slen - 1 );

a210 3
fprintf( stderr, "fss   : descr = %2d, str = 0, %4d:%4d, %4d\n",
	stp->s_index, srp->s_zero, srp->s_dollar, fm_slen - 1 );

d220 2
a221 2

fprintf( stderr, "fss   : %4d %.*s\n", szero, slen, &fm_sbuf[ szero ] );
d226 1
a226 1
		if( find_motif( n_srp ) )
d228 1
a228 1
		else{
d233 5
a237 1
	}else
d244 1
a244 1
	STREL_T	*stp, *i_stp, *n_stp;
a255 3
fprintf( stderr, "fwchlx: descr = %2d, str = 0, %4d:%4d, %4d\n",
	stp->s_index, srp->s_zero, srp->s_dollar, fm_slen - 1 );

d268 5
a272 3
fprintf( stderr, "fwchlx: %4d %.*s %4d %.*s ?\n",
	szero, hlen, &fm_sbuf[ szero ],
	h3 - hlen + 1, hlen, &fm_sbuf[ h3 - hlen + 1 ] ); 
a287 3
fprintf( stderr, "fwchlx: inner = %4d %4d, i_len = %4d\n",
	szero + hlen, h3 - hlen, i_len );

d289 1
a289 5

fprintf( stderr, "fwchlx: %4d %.*s %4d %.*s\n",
	szero, hlen, &fm_sbuf[ szero ],
	h3 - hlen + 1, hlen, &fm_sbuf[ h3 - hlen + 1 ] ); 

a296 1

d379 22
@


1.30
log
@5th step on the way to the recursion.
@
text
@d14 2
d84 2
d102 4
a105 1
	int	sdollar, f_sdollar, l_sdollar; 
d107 11
a117 5
	f_sdollar = srp->s_dollar;
	l_sdollar = srp->s_zero + rm_dminlen - 1;
	for( sdollar = f_sdollar; sdollar >= l_sdollar; sdollar-- ){
		srp->s_dollar = sdollar;
		find_1_motif( srp );
d119 28
d153 1
a156 1
/*
a158 1
*/
d162 1
a162 1
		find_ss( srp );
d166 1
a166 1
			find_wchlx( srp );
d169 1
a169 1
			find_pknot(  slev, n_searches, searches,
d200 2
d205 1
a205 1
SEARCH_T	srp;
d207 21
a227 1
	int	szero, sdollar;
d229 14
d252 1
a252 1
	int	h3, hlen;
d260 3
d275 4
d283 15
d302 7
a308 2
fprintf( stderr, "fwchlx: inner = %4d %4d, i_len = %4d; next = %4d, %4d\n",
	szero + hlen + 1, h3 - hlen + 1, i_len, h3 + 1, sdollar );
d310 2
a311 1
	}
a335 4
/*
fprintf( stderr, "mhlx  : s5 = %4d, s3 = %4d, s3lim = %4d\n", s5, s3, s3lim ); 
*/

a341 4
/*
fprintf( stderr, "mhlx.1: s5 = %4d, s3 = %4d, h.start\n", s5, s3 );
*/

d347 1
a347 3
/*
fprintf( stderr, "mhlx.2: s = %4d\n", s );
*/
@


1.29
log
@4th step on the way to the recursion.
@
text
@d80 3
a82 10
		f_sdollar = szero + w_winsize - 1;
		l_sdollar = szero + rm_dminlen - 1;
		for( sdollar = f_sdollar; sdollar >= l_sdollar; sdollar-- ){
/*
fprintf( stderr, "fm.1  : szero = %4d, sdollar = %4d\n", szero, sdollar );
*/
			srp->s_zero = szero;
			srp->s_dollar = sdollar;
			find_1_motif( srp );
		}
d86 1
a86 1
	f_sdollar = slen - 1;
d88 2
a89 9
		l_sdollar = szero + rm_dminlen - 1;
		for( sdollar = f_sdollar; sdollar >= l_sdollar; sdollar-- ){
/*
fprintf( stderr, "fm.2  : szero = %4d, sdollar = %4d\n", szero, sdollar );
*/
			srp->s_zero = szero;
			srp->s_dollar = sdollar;
			find_1_motif( srp );
		}
d98 1
d100 6
d122 1
a122 3
/*
		find_ss( slev, n_searches, searches, szero, sdollar );
*/
d162 2
a163 6
static	int	find_ss( slev, n_searches, searches, szero, sdollar )
int	slev;
int	n_searches;
SEARCH_T	*searches[];
int	szero;
int	sdollar;
d165 1
d172 1
a172 1
	STREL_T	*stp;
d175 1
a175 1
	int	i_minl;
d177 1
a183 5
/*
fprintf( stderr, "fwchlx: descr = %2d, str = 0, %4d:%4d, %4d\n",
	stp->s_index, szero, sdollar, fm_slen - 1 );
*/

d187 1
a188 4
/*
	s3lim = ( i_minl + 2 * h_minl );
	s3lim = szero + s3lim - 1;
*/
d194 1
a194 3
/*
fprintf( stderr, "fwchlx: s3lim = %4d\n", s3lim );
*/
d196 3
a198 1
	if( match_helix( stp, szero, sdollar, s3lim, &h3, &hlen ) ){
d201 2
a202 2
	szero+1, hlen, &fm_sbuf[ szero ],
	h3 - hlen + 2, hlen, &fm_sbuf[ h3 - hlen + 1 ] ); 
d204 2
a205 2
fprintf( stderr, "fwchlx: inner = %4d %4d; next = %4d, %4d\n",
	szero + hlen + 1, h3 - hlen + 1, h3 + 1, sdollar );
@


1.28
log
@3rd step on way to the recursion.
@
text
@d24 1
d82 8
a89 6
fprintf( stderr, "fmd.1 : szero = %4d, sdollar = %4d:%4d\n",
	szero, f_sdollar, l_sdollar );
		sdollar = szero + w_winsize - 1;
		srp->s_zero = szero;
		srp->s_dollar = sdollar;
		find_motif( srp );
a93 1
	sdollar = slen - 1;
d96 8
a103 5
fprintf( stderr, "fmd.2 : szero = %4d, sdollar = %4d:%4d\n",
	szero, f_sdollar, l_sdollar );
		srp->s_zero = szero;
		srp->s_dollar = sdollar;
		find_motif( srp );
d112 6
d122 2
a123 1
fprintf( stderr, "fm    : descr = %2d, str = 0, %4d:%4d, %4d\n",
d125 1
d195 1
d198 1
d204 1
d207 9
d217 1
a217 2
	for( s = sdollar; s >= s3lim; s-- ){
		if( match_helix( stp, szero, s, s3lim, &h3, &hlen ) ){
a225 1
		}
d251 4
d261 4
a265 3
	s3_5plim = s3lim - stp->s_minlen + 1;
	s3_5plim = MAX( s3_5plim, s3 - stp->s_maxlen + 1 );

d269 4
a272 1
	for( bpcnt = 1, *hlen = 1, s = s3 - 1; s >= s3_5plim; s--, (*hlen)++ ){
@


1.27
log
@2d tricky step on the way to the recursion.
@
text
@d40 3
a42 1
	int	i, w_winsize, slev, szero, sdollar;
d77 6
a82 1
	for( szero = 0; szero < slen - w_winsize; szero++ ){
d89 2
d92 4
a95 1
	for( ; szero <= slen - rm_dminlen; szero++ ){
@


1.26
log
@trick stage on the road to the 1st recursion.
@
text
@d74 1
a74 2
	slev = 0;
	srp = searches[ slev ];
d79 1
a79 1
		find_motif( slev, n_searches, searches, szero, sdollar );
d86 1
a86 1
		find_motif( 0, n_searches, searches, szero, sdollar );
d92 2
a93 5
static	int	find_motif( slev, n_searches, searches, szero, sdollar )
int	szero;
int	n_searches;
SEARCH_T	*searches[];
int	sdollar;
a94 1
	SEARCH_T	*srp;
a96 1
	srp = searches[ slev ];
d99 2
a100 2
fprintf( stderr, "fm    : slev = %d, str = 0, %4d:%4d, %4d\n",
	slev, szero, sdollar, fm_slen - 1 );
d104 1
d106 1
d110 1
a110 2
			find_wchlx( slev, n_searches, searches,
				szero, sdollar );
d112 1
d115 1
d156 2
a157 6
static	int	find_wchlx( slev, n_searches, searches, szero, sdollar )
int	slev;
int	n_searches;
SEARCH_T	*searches[];
int	szero;
int	sdollar;
a158 1
	SEARCH_T	*srp;
d160 1
a160 1
	int	s, s3lim, slen;
d165 7
a171 2
fprintf( stderr, "fwchlx: slev = %d, str = 0, %4d:%4d, %4d\n",
	slev, szero, sdollar, fm_slen - 1 );
a172 3
	srp = searches[ slev ];
	stp = srp->s_descr;
	slen = sdollar - szero + 1;
@


1.25
log
@extended find_wchlx() to check for compliance with specified sequence
@
text
@d66 1
a66 1
fprintf( stderr, "fmd: locus = %s, slen = %d\n", locus, slen );
d105 1
a105 2
/*
fprintf( stderr, "fm: slev = %d, str = 0, %4d:%4d, %4d\n",
a106 1
*/
d173 3
d189 1
a189 1
fprintf( stderr, "fwch: %4d %.*s %4d %.*s\n",
d192 3
@


1.24
log
@removed some debug, started working on the 1st recursion.
@
text
@d18 2
a19 1
static	int	*fm_window;
d21 1
d44 1
a44 1
	if( fm_window == NULL ){
d55 2
a56 2
		fm_window = ( int * )malloc( fm_windowsize * sizeof( int ) );
		if( fm_window == NULL )
d58 6
a63 1
				"find_motif_driver: can't allocate fm_window.");
d213 1
d218 1
d239 1
a239 1
				if( *hlen < stp->s_minlen ){
d241 1
a241 1
				}else
d246 13
@


1.23
log
@actually finds helices.  Doesn't find motif's yet, but very close!
@
text
@d166 1
a166 4

/*
fprintf( stderr, "fwch:\n" );
*/
a174 7
/*
fprintf( stderr, "fwch: szero  = %4d, sdollar = %4d\n", szero, sdollar );
fprintf( stderr, "fwch: slen   = %4d\n", slen );
fprintf( stderr, "fwch: h_minl = %4d, h_maxl  = %4d\n", h_minl, h_maxl );
fprintf( stderr, "fwch: i_minl = %4d\n", i_minl );
*/

d176 1
d178 2
a179 3
/*
fprintf( stderr, "fwch: s3lim = ( i_minl + 2 * h_minl ) = %d\n", s3lim );
*/
d181 3
a183 5
	s3lim = szero + s3lim - 1;

/*
fprintf( stderr, "fwch: s3lim = szero + s3lim - 1 = %d\n", s3lim );
*/
a184 2
	for( s = sdollar; s >= s3lim; s-- ){
		if( match_helix( stp, szero, s, s3lim ) ){
d198 1
a198 1
static	int	match_helix( stp, s5, s3, s3lim )
d203 2
d208 1
a208 1
	int	bpcnt, hlen, mpr;
d215 1
a218 7
/*
fprintf( stderr, "mhlx: s3_5plim = %4d\n", s3_5plim );
fprintf( stderr,
	"mhlx.1: s5 = %4d, s3 = %4d, s3lim =    %3d, b5 = %c, b3 = %c\n",
	s5, s3, s3lim, b5, b3 );
*/

d220 1
a220 1
	hlen = 1;
d222 3
a224 9
	for( bpcnt = 1, hlen = 1, s = s3 - 1; s >= s3_5plim; s--, hlen++ ){
		b5 = fm_sbuf[ s5 + hlen ];
		b3 = fm_sbuf[ s3 - hlen ];
/*
fprintf( stderr,
	"mhlx.2: s5 = %4d, s3 = %4d, s3_5plim = %3d, b5 = %c, b3 = %c\n",
	s5 + hlen, s3 - hlen, s3_5plim, b5, b3 );
*/

d230 1
a230 7
				if( hlen < stp->s_minlen ){

/*
fprintf( stderr, "mhlx.3: #mpr = %4d, > stp->s_mispair (%4d)\n",
	mpr, stp->s_mispair );
*/

a236 8

fprintf( stderr, "mhlx.4: hlx!\n" );
for( s = 0; s < hlen; s++ ){ 
	b5 = fm_sbuf[ s5 + s ];
	b3 = fm_sbuf[ s3 - s ];
	fprintf( stderr, " %4d-%4d: %c-%c\n", s5+s, s3-s, b5, b3 );
}

@


1.22
log
@first actual search! very tentative and doesn't work, buts its something.
@
text
@d6 3
d16 1
a16 1
static	char	fm_slen;
d25 1
d98 1
d101 1
a101 2

	return(1);
a160 2
	int	s, s3lim;
	int	b5, b3;
d163 7
d173 23
a196 1
	b5 = fm_sbuf[ szero ];
d198 1
a198 2
		b3 = fm_sbuf[ s ];
		if( paired( stp, b5, b3 ) ){
d212 65
a290 1
fprintf( stderr, "paired: b5 = %c, b3 = %c, %d\n", b5, b3, rv );
@


1.21
log
@renamed parms & locals s_caret & s_dollar to szero & sdollar.
@
text
@d9 1
d22 1
d34 1
a34 1
	int	i, w_winsize, szero, sdollar;
d36 1
d63 2
d67 3
a69 1
		find_motif( 0, n_searches, searches, szero, sdollar, slen );
d74 3
a76 1
		find_motif( 0, n_searches, searches, szero, sdollar, slen );
d82 1
a82 1
static	int	find_motif( slev, n_searches, searches, szero, sdollar, slen )
a86 1
int	slen;
d95 1
a95 1
	slev, szero, sdollar, slen - 1 );
d101 1
a101 1
		find_ss( slev, n_searches, searches, szero, sdollar, slen );
d106 1
a106 1
				szero, sdollar, slen );
d109 1
a109 1
				szero, sdollar, slen );
d140 1
a140 1
static	int	find_ss( slev, n_searches, searches, szero, sdollar, slen )
a145 1
int	slen;
d150 1
a150 1
static	int	find_wchlx( slev, n_searches, searches, szero, sdollar, slen )
a155 1
int	slen;
d157 4
d162 9
d173 1
a173 1
static	int	find_pknot(  slev, n_searches, searches, szero, sdollar, slen )
a178 1
int	slen;
d181 17
@


1.20
log
@more.
@
text
@d32 1
a32 1
	int	i, w_winsize, s_caret, s_dollar;
d60 3
a62 3
	for( s_caret = 0; s_caret < slen - w_winsize; s_caret++ ){
		s_dollar = s_caret + w_winsize - 1;
		find_motif( 0, n_searches, searches, s_caret, s_dollar, slen );
d65 3
a67 3
	s_dollar = slen - 1;
	for( ; s_caret <= slen - rm_dminlen; s_caret++ ){
		find_motif( 0, n_searches, searches, s_caret, s_dollar, slen );
d73 2
a74 3
static	int	find_motif( slev, n_searches, searches,
	s_caret, s_dollar, slen )
int	s_caret;
d77 1
a77 1
int	s_dollar;
d87 1
a87 1
	slev, s_caret, s_dollar, slen - 1 );
d93 1
a93 1
		find_ss( slev, n_searches, searches, s_caret, s_dollar, slen );
d98 1
a98 1
				s_caret, s_dollar, slen );
d101 1
a101 1
				s_caret, s_dollar, slen );
d132 1
a132 1
static	int	find_ss( slev, n_searches, searches, s_caret, s_dollar, slen )
d136 2
a137 2
int	s_caret;
int	s_dollar;
d143 1
a143 2
static	int	find_wchlx( slev, n_searches, searches,
	s_caret, s_dollar, slen )
d147 2
a148 2
int	s_caret;
int	s_dollar;
d154 1
a154 2
static	int	find_pknot(  slev, n_searches, searches,
	s_caret, s_dollar, slen )
d158 2
a159 2
int	s_caret;
int	s_dollar;
@


1.19
log
@correct the window algorithm to use a working window size of
	min(windowsize,rm_dmaxlen)
for the prefix of the sequence, when this working window size is < than
the length of the sequence.
@
text
@d24 3
a26 3
int	find_motif_driver( n_descr, descr, sites, locus, slen, sbuf )
int	n_descr;
STREL_T descr[];
d32 1
a32 1
	int	i, w_winsize, s_zero, s_dollar;
d60 3
a62 6
	for( s_zero = 0; s_zero < slen - w_winsize; s_zero++ ){
		s_dollar = s_zero + w_winsize - 1;
fprintf( stderr, "srch.1: 0, %4d:%4d, %4d\n", s_zero, s_dollar, slen - 1 );
/*
		find_motif( 0, descr, i, i + rm_dmaxlen - 1 );
*/
d66 2
a67 5
	for( ; s_zero <= slen - rm_dminlen; s_zero++ ){
fprintf( stderr, "srch.2: 0, %4d:%4d, %4d\n", s_zero, s_dollar, slen - 1);
/*
		find_motif( 0, descr, i, i + rm_dmaxlen - 1 );
*/
d73 5
a77 4
static	int	find_motif( d, descr, s_zero, s_dollar )
int	d;
STREL_T	descr[];
int	s_zero;
d79 1
d81 1
d84 8
a91 1
	stp = &descr[ d ];
d94 1
a94 1
		find_ss( d, descr, s_zero, s_dollar );
d97 7
a103 4
		if( stp->s_proper )
			find_wchlx( d, descr, s_zero, s_dollar );
		else
			find_pknot( d, descr, s_zero, s_dollar );
d133 5
a137 4
static	int	find_ss( d, descr, s_zero, s_dollar )
int	d;
STREL_T	descr[];
int	s_zero;
d139 1
d144 6
a149 4
static	int	find_wchlx( d, descr, s_zero, s_dollar )
int	d;
STREL_T	descr[];
int	s_zero;
d151 1
d156 6
a161 4
static	int	find_pknot( d, descr, s_zero, s_dollar )
int	d;
STREL_T	descr[];
int	s_zero;
d163 1
@


1.18
log
@began computing the actual search locations, including the window.
@
text
@d32 1
a32 1
	int	i, s_zero, s_dollar;
d58 5
a62 3
	for( s_zero = 0; s_zero < slen - fm_windowsize; s_zero++ ){
		s_dollar = s_zero + fm_windowsize - 1;
fprintf( stderr, "srch.1: %4d:%4d\n", s_zero, s_dollar );
d69 2
a70 2
	for( i = 0; i <= slen - rm_dminlen; i++, s_zero++ ){
fprintf( stderr, "srch.2: %4d:%4d\n", s_zero, s_dollar );
@


1.17
log
@actually writing the search code!
@
text
@d14 2
d22 2
d32 8
a39 1
	int	i;
d41 11
d58 12
a69 1
	for( i = 0; i < slen - rm_dminlen; i++ ){
d71 1
@


1.16
log
@back to skeleton, but this time all compile time ops are in compile.c!
@
text
@d6 15
a20 1
int	find_motif( n_descr, descr, sites, locus, slen, sbuf )
d28 1
a28 2
	char	prefix[ 100 ];
	int	tminlen, tmaxlen;
d30 85
a114 1
	fprintf( stderr, "locus = %s, slen = %d\n", locus, slen );
@


1.15
log
@removed find_limits() and associated funcs and put them in compile
@
text
@a5 5
static	void	print_limits();
static	void	print_1_limit();
static	void	mk_prefix();
static	void	mk_strel_name();

a16 4
	fprintf( stderr,
	"descr minl  maxl  mngl  mxgl  mnil  mxil start  stop  descr\n" );
	strcpy( prefix, "+" );
	print_limits( stderr, 0, prefix, 0, descr );
a17 183
}

static	void	print_limits( fp, lev, prefix, fd, descr )
FILE	*fp;
int	lev;
char	prefix[];
int	fd;
STREL_T	descr[];
{
	int	d, nd, s;
	STREL_T	*stp, *stp1, *stp2;
	char	prefix1[ 100 ], prefix2[ 100 ];;

	for( d = fd; ; d = nd ){
		stp = &descr[ d ];
		print_1_limit( fp, prefix, stp );
		mk_prefix( stp, prefix, prefix1 ); 
		for( s = 1; s < stp->s_n_scopes; s++ ){
			stp1 = stp->s_scopes[ s - 1 ];
			stp2 = stp->s_scopes[ s ];
			print_limits( fp, lev+2, prefix1, 
				stp1->s_index+1, descr );
			mk_prefix( stp2, prefix, prefix2 ); 
			print_1_limit( fp, prefix2, stp2 );
		}
		stp1 = stp->s_next;
		if( stp1 == NULL )
			return;
		else
			nd = stp1->s_index;
	} 
}

static	void	print_1_limit( fp, prefix, stp )
FILE	*fp;
char	prefix[];
STREL_T	*stp;
{
	int	start, stop, l2r;
	char	name[ 20 ], tstr[ 20 ];
	char	*bp, buf[ 200 ];

	bp = buf;
	sprintf( bp, "%4d", stp->s_index );
	bp += strlen( bp );

	sprintf( bp, " %5d", stp->s_minlen );
	bp += strlen( bp );

	if( stp->s_maxlen == UNBOUNDED )
		sprintf( bp, " UNBND" );
	else
		sprintf( bp, " %5d", stp->s_maxlen );
	bp += strlen( bp );

	if( stp->s_minglen == UNDEF )
		sprintf( bp, " UNDEF" );
	else
		sprintf( bp, " %5d", stp->s_minglen );
	bp += strlen( bp );

	if( stp->s_maxglen == UNBOUNDED )
		sprintf( bp, " UNBND" );
	else if( stp->s_maxglen == UNDEF )
		sprintf( bp, " UNDEF" );
	else
		sprintf( bp, " %5d", stp->s_maxglen );
	bp += strlen( bp );

	if( stp->s_minilen == UNDEF )
		sprintf( bp, " UNDEF" );
	else
		sprintf( bp, " %5d", stp->s_minilen );
	bp += strlen( bp );

	if( stp->s_maxilen == UNBOUNDED )
		sprintf( bp, " UNBND" );
	else if( stp->s_maxilen == UNDEF )
		sprintf( bp, " UNDEF" );
	else
		sprintf( bp, " %5d", stp->s_maxilen );
	bp += strlen( bp );

	sprintf( tstr, "%s%d", !stp->s_start.a_l2r ? "$-" : "",
		stp->s_start.a_offset );
	sprintf( bp, " %5s", tstr );
	bp += strlen( bp );

	sprintf( tstr, "%s%d", !stp->s_stop.a_l2r ? "$-" : "",
		stp->s_stop.a_offset );
	sprintf( bp, " %5s", tstr );
	bp += strlen( bp );

	mk_strel_name( stp, name );
	sprintf( bp, "  %s%s", prefix, name );
	bp += strlen( bp );

	if( stp->s_scope == 0 ){
		sprintf( bp, "+--+" );
		bp += strlen( bp );
	}
	sprintf( bp, "\n" );
	bp += strlen( bp );

	fputs( buf, fp );
}

static	void	mk_prefix( stp, prefix, prefix1 )
STREL_T	*stp;
char	prefix[];
char	prefix1[];
{
	char	*pp, *pp1;
	int	plen;
	STREL_T	*stp0;
	int	inner, next, first;

	strcpy( prefix1, prefix );
	plen = strlen( prefix1 );
	pp = &prefix1[ plen - 1 ];

	inner = stp->s_inner != NULL;
	if( inner )
		first = stp->s_scope == 0;
	else
		first = 0;
	next = stp->s_next != NULL;
	if( next )
		*pp = '|';
	else if( *pp != '|' )
		*pp = ' ';
	if( first )
		strcat( prefix1, "  |" );
	strcat( prefix1, "  +" );
}

static	void	mk_strel_name( stp, name )
STREL_T	*stp;
char	name[];
{

	switch( stp->s_type ){
	case SYM_SS :
		strcpy( name, "ss" );
		break;

	case SYM_H5 :
		strcpy( name, "h5" );
		break;
	case SYM_H3 :
		strcpy( name, "h3" );
		break;

	case SYM_P5 :
		strcpy( name, "p5" );
		break;
	case SYM_P3 :
		strcpy( name, "p3" );
		break;

	case SYM_T1 :
		strcpy( name, "t1" );
		break;
	case SYM_T2 :
		strcpy( name, "t2" );
		break;
	case SYM_T3 :
		strcpy( name, "t3" );
		break;

	case SYM_Q1 :
		strcpy( name, "q1" );
		break;
	case SYM_Q2 :
		strcpy( name, "q2" );
		break;
	case SYM_Q3 :
		strcpy( name, "q3" );
		break;
	case SYM_Q4 :
		strcpy( name, "q4" );
		break;
	}
@


1.14
log
@removed lev parm from find_limits() as it was an unused relic of the
print_limits() from which it was derived.
@
text
@a5 3
#define	RM_R2L(st)	\
	((st)==SYM_P3||(st)==SYM_H3||(st)==SYM_T2||(st)==SYM_Q2||(st)==SYM_Q4)

a9 8
static	void	find_limits();
static	void	find_1_limit();
static	void	find_start();
static	void	find_stop();
static	int	closes_unbnd();
static	int	min_prefixlen();
static	int	max_prefixlen();
static	int	min_suffixlen();
a21 1
	find_limits( 0, descr );
a209 187
}

static	void	find_limits( fd, descr )
int	fd;
STREL_T	descr[];
{
	int	d, nd, s;
	STREL_T	*stp, *stp1, *stp2;

	for( d = fd; ; d = nd ){
		stp = &descr[ d ];
		find_1_limit( stp, descr );
		for( s = 1; s < stp->s_n_scopes; s++ ){
			stp1 = stp->s_scopes[ s - 1 ];
			stp2 = stp->s_scopes[ s ];
			find_limits( stp1->s_index+1, descr );
			find_1_limit( stp2, descr );
		}
		stp1 = stp->s_next;
		if( stp1 == NULL )
			return;
		else
			nd = stp1->s_index;
	} 
}

static	void	find_1_limit( stp, descr )
STREL_T	*stp;
STREL_T	descr[];
{
	int	start, stop, l2r;
	char	name[ 20 ], tstr[ 20 ];
	char	*bp, buf[ 200 ];

	find_start( stp, descr );
	find_stop( stp, descr );
}

static	void	find_start( stp, descr )
STREL_T	*stp;
STREL_T	descr[];
{
	int	start;

	if( stp->s_scope == UNDEF ){	/* ss	*/
/*
		*l2r = 1; 
		start = 0;
*/
		stp->s_start.a_l2r = 1;
		stp->s_start.a_offset = 0;
	}else if( stp->s_scope == 0 ){	/* start a group	*/
/*
		*l2r = 1; 
		start = 0;
*/
		stp->s_start.a_l2r = 1;
		stp->s_start.a_offset = 0;
	}else{
		if( RM_R2L( stp->s_type ) ){
			if( closes_unbnd( stp, descr ) ){
/*
				start = min_suffixlen( stp, descr );
				*l2r = 0;
*/
				stp->s_start.a_offset =
					min_suffixlen( stp, descr );
				stp->s_start.a_l2r = 0;
			}else{
/*
				start = max_prefixlen( stp, descr );
				start += stp->s_maxlen - 1;
				*l2r = 1;
*/
				stp->s_start.a_offset =
					max_prefixlen( stp, descr );
				stp->s_start.a_offset += stp->s_maxlen - 1;
				stp->s_start.a_l2r = 1;
			}
		}else{
/*
			start = min_prefixlen( stp, descr );
			*l2r = 1;
*/
			stp->s_start.a_offset = min_prefixlen( stp, descr );
			stp->s_start.a_l2r = 1;
		}
	}
}

static	void	find_stop( stp, descr )
STREL_T	*stp;
STREL_T	descr[];
{
	int	i, unbnd;
	int	stop;
	STREL_T	*stp1;

	if( RM_R2L( stp->s_type ) ){
		stp->s_stop.a_offset =
			stp->s_minlen + min_prefixlen( stp, descr ) - 1;
		stp->s_stop.a_l2r = 1;
	}else{
		stp->s_stop.a_offset = 
			stp->s_minlen + min_suffixlen( stp, descr );
		if( stp->s_stop.a_offset > 0 )
			stp->s_stop.a_offset--;
		stp->s_stop.a_l2r = 0;
	}
}

static	int	closes_unbnd( stp, descr )
STREL_T	*stp;
STREL_T	descr[];
{

	if( stp->s_maxlen == UNBOUNDED )
		return( 1 );
	if( max_prefixlen( stp, descr ) == UNBOUNDED )
		return( 1 );
	return( 0 );
}

static	int	min_prefixlen( stp, descr )
STREL_T	*stp;
STREL_T	descr[];
{
	STREL_T	*stp0, *stp1;
	int	s, plen;

	if( stp->s_scope == UNDEF )
		return( 0 );
	stp0 = stp->s_scopes[ 0 ];
	for( plen = 0, s = stp->s_index - 1; s >= stp0->s_index; s-- ){
		stp1 = &descr[ s ];
		plen += stp1->s_minlen;
	}
	return( plen );
}

static	int	max_prefixlen( stp, descr )
STREL_T	*stp;
STREL_T	descr[];
{
	STREL_T	*stp0, *stp1;
	int	s, plen;

	if( stp->s_scope == UNDEF )
		return( 0 );
	stp0 = stp->s_scopes[ 0 ];
	for( plen = 0, s = stp->s_index - 1; s >= stp0->s_index; s-- ){
		stp1 = &descr[ s ];
		if( stp1->s_maxlen == UNBOUNDED )
			return( UNBOUNDED );
		else
			plen += stp1->s_maxlen;
	}
	return( plen );
}

static	int	min_suffixlen( stp, descr )
STREL_T	*stp;
STREL_T	descr[];
{
	STREL_T	*stp0, *stp1, *stpn;
	int	s, slen;

	slen = 0;
	if( stp->s_scope == UNDEF ){
		for( stp1 = stp->s_next; stp1; stp1 = stp1->s_next )
			if( stp1->s_scope == 0 )
				slen += stp1->s_minglen;
			else
				slen += stp1->s_minlen;
		return( slen );
	}

	slen = 0;
	stpn = stp->s_scopes[ stp->s_n_scopes - 1 ];
	for( s = stp->s_index + 1; s <= stpn->s_index; s++ ){
		stp1 = &descr[ s ];
		slen += stp1->s_minlen;
	}
	stp0 = stp->s_scopes[ 0 ];
	for( stp1 = stp0->s_next; stp1; stp1 = stp1->s_next )
		slen += stp1->s_minlen;
	return( slen );
@


1.13
log
@removed no longer used versions of find_stop(), find_start(). renamed .2()
versions to be original (no suffix versions).  Removed n_descr parm to
all calls as it was no used, being determined from the s_next, s_scopes
pointers.
@
text
@d33 1
a33 1
	find_limits( 0, 0, descr );
d224 1
a224 2
static	void	find_limits( lev, fd, descr )
int	lev;
d233 1
a233 1
		find_1_limit( lev, stp, descr );
d237 2
a238 2
			find_limits( lev+2, stp1->s_index+1, descr );
			find_1_limit( lev+1, stp2, descr );
d248 1
a248 2
static	void	find_1_limit( lev, stp, descr )
int	lev;
@


1.12
log
@intermediate step in moving the address finding & printing stuff form
help to compile.c.  Duplicated find_start() and find_stop as void
find_starts() & find_stop2().  Created find_limits() & find_1_limit.
print_1_limit2() uses values in stp->...
@
text
@d5 1
d11 2
a12 3
static	void	print_1_limit2();
static	void	ext_prefix();
static	void	strel_name();
d15 2
a16 4
static	int	find_start();
static	void	find_start2();
static	int	find_stop();
static	void	find_stop2();
d33 1
a33 2
	find_limits( 0, 0, n_descr - 1, n_descr, descr );
	fprintf( stderr, "locus = %s, slen = %d\n", locus, slen );
d37 2
a38 1
	print_limits( stderr, 0, prefix, 0, n_descr - 1, n_descr, descr );
d41 1
a41 1
static	void	print_limits( fp, lev, prefix, fd, ld, n_descr, descr )
a45 2
int	ld;
int	n_descr;
d52 1
a52 1
	for( d = fd; d <= ld; d = nd ){
d54 2
a55 5
/*
		print_1_limit( fp, lev, prefix, stp, n_descr, descr );
*/
		print_1_limit2( fp, lev, prefix, stp, n_descr, descr );
		ext_prefix( stp, prefix, prefix1 ); 
d60 3
a62 9
				stp1->s_index+1, stp2->s_index-1,
				n_descr, descr );
			ext_prefix( stp2, prefix, prefix2 ); 
/*
			print_1_limit( fp, lev+1, prefix2, stp2,
				n_descr, descr );
*/
			print_1_limit2( fp, lev+1, prefix2, stp2,
				n_descr, descr );
d72 1
a72 1
static	void	print_1_limit( fp, lev, prefix, stp, n_descr, descr )
a73 1
int	lev;
a75 2
int	n_descr;
STREL_T	descr[];
a121 82
	start = find_start( stp, descr, &l2r );
	sprintf( tstr, "%s%d", !l2r ? "$-" : "", start );
	sprintf( bp, " %5s", tstr );
	bp += strlen( bp );

	stop = find_stop( stp, n_descr, descr, &l2r );
	sprintf( tstr, "%s%d", !l2r ? "$-" : "", stop );
	sprintf( bp, " %5s", tstr );
	bp += strlen( bp );

	strel_name( stp, name );
	sprintf( bp, "  %s%s", prefix, name );
	bp += strlen( bp );

	if( stp->s_scope == 0 ){
		sprintf( bp, "+--+" );
		bp += strlen( bp );
	}
	sprintf( bp, "\n" );
	bp += strlen( bp );

	fputs( buf, fp );
}

static	void	print_1_limit2( fp, lev, prefix, stp, n_descr, descr )
FILE	*fp;
int	lev;
char	prefix[];
STREL_T	*stp;
int	n_descr;
STREL_T	descr[];
{
	int	start, stop, l2r;
	char	name[ 20 ], tstr[ 20 ];
	char	*bp, buf[ 200 ];

	bp = buf;
	sprintf( bp, "%4d", stp->s_index );
	bp += strlen( bp );

	sprintf( bp, " %5d", stp->s_minlen );
	bp += strlen( bp );

	if( stp->s_maxlen == UNBOUNDED )
		sprintf( bp, " UNBND" );
	else
		sprintf( bp, " %5d", stp->s_maxlen );
	bp += strlen( bp );

	if( stp->s_minglen == UNDEF )
		sprintf( bp, " UNDEF" );
	else
		sprintf( bp, " %5d", stp->s_minglen );
	bp += strlen( bp );

	if( stp->s_maxglen == UNBOUNDED )
		sprintf( bp, " UNBND" );
	else if( stp->s_maxglen == UNDEF )
		sprintf( bp, " UNDEF" );
	else
		sprintf( bp, " %5d", stp->s_maxglen );
	bp += strlen( bp );

	if( stp->s_minilen == UNDEF )
		sprintf( bp, " UNDEF" );
	else
		sprintf( bp, " %5d", stp->s_minilen );
	bp += strlen( bp );

	if( stp->s_maxilen == UNBOUNDED )
		sprintf( bp, " UNBND" );
	else if( stp->s_maxilen == UNDEF )
		sprintf( bp, " UNDEF" );
	else
		sprintf( bp, " %5d", stp->s_maxilen );
	bp += strlen( bp );

/*
	start = find_start( stp, descr, &l2r );
	sprintf( tstr, "%s%d", !l2r ? "$-" : "", start );
*/
	find_start2( stp, descr );
a123 1

a126 5
/*
	stop = find_stop( stp, n_descr, descr, &l2r );
	sprintf( tstr, "%s%d", !l2r ? "$-" : "", stop );
*/
	find_stop2( stp, n_descr, descr );
a128 1

d132 1
a132 1
	strel_name( stp, name );
d146 1
a146 1
static	void	ext_prefix( stp, prefix, prefix1 )
d175 1
a175 1
static	void	strel_name( stp, name )
d224 1
a224 1
static	void	find_limits( lev, fd, ld, n_descr, descr )
a226 2
int	ld;
int	n_descr;
d232 1
a232 1
	for( d = fd; d <= ld; d = nd ){
d234 1
a234 1
		find_1_limit( lev, stp, n_descr, descr );
d238 2
a239 3
			find_limits( lev+2, stp1->s_index+1, stp2->s_index-1,
				n_descr, descr );
			find_1_limit( lev+1, stp2, n_descr, descr );
d249 1
a249 1
static	void	find_1_limit( lev, stp, n_descr, descr )
a251 1
int	n_descr;
d258 2
a259 36
	find_start2( stp, descr );
	find_stop2( stp, n_descr, descr );
}

static	int	find_start( stp, descr, l2r )
STREL_T	*stp;
STREL_T	descr[];
int	*l2r;
{
	char	name[ 20 ];
	int	start;

	strel_name( stp, name );
	if( stp->s_scope == UNDEF ){	/* ss	*/
		*l2r = 1; 
		start = 0;
	}else if( stp->s_scope == 0 ){	/* start a group	*/
		*l2r = 1; 
		start = 0;
	}else{
		if( RM_R2L( stp->s_type ) ){
			if( closes_unbnd( stp, descr ) ){
				start = min_suffixlen( stp, descr );
				*l2r = 0;
			}else{
				start = max_prefixlen( stp, descr );
				start += stp->s_maxlen - 1;
				*l2r = 1;
			}
		}else{
			start = min_prefixlen( stp, descr );
			*l2r = 1;
		}
	}

	return( start );
d262 1
a262 1
static	void	find_start2( stp, descr )
d314 1
a314 23
static	int	find_stop( stp, n_descr, descr, l2r )
STREL_T	*stp;
int	n_descr;
STREL_T	descr[];
int	*l2r;
{
	int	i, unbnd;
	int	stop;
	STREL_T	*stp1;

	if( RM_R2L( stp->s_type ) ){
		*l2r = 1;
		stop = stp->s_minlen + min_prefixlen( stp, descr ) - 1;
	}else{
		*l2r = 0;
		stop = stp->s_minlen + min_suffixlen( stp, descr );
		if( stop > 0 )
			stop--;
	}
	return( stop );
}

static	void	find_stop2( stp, n_descr, descr )
a315 1
int	n_descr;
a322 4
/*
		*l2r = 1;
		stop = stp->s_minlen + min_prefixlen( stp, descr ) - 1;
*/
a326 6
/*
		*l2r = 0;
		stop = stp->s_minlen + min_suffixlen( stp, descr );
		if( stop > 0 )
			stop--;
*/
@


1.11
log
@removed unused find_start(), find_start2(), find_stop() & their associate
subroutines.  Renamed find_start3() to find_start(), find_stop2() to
find_stop().  Moved ext_prefix() to a more logical place.  Converted
all internal funcs to static.
@
text
@d10 1
d13 2
d16 1
d18 1
d35 1
d40 1
a40 1
	print_limits( stderr, slen, 0, prefix, 0, n_descr - 1, n_descr, descr );
d43 1
a43 1
static	void	print_limits( fp, slen, lev, prefix, fd, ld, n_descr, descr )
a44 1
int	slen;
d58 4
a61 1
		print_1_limit( fp, slen, lev, prefix, stp, n_descr, descr );
d66 1
a66 1
			print_limits( fp, slen, lev+2, prefix1, 
d70 5
a74 1
			print_1_limit( fp, slen, lev+1, prefix2, stp2,
d85 78
a162 1
static	void	print_1_limit( fp, slen, lev, prefix, stp, n_descr, descr )
a163 1
int	slen;
d215 1
d218 5
d226 2
a227 1
	stop = find_stop( slen, stp, n_descr, descr, &l2r );
d229 5
d329 30
a358 2
static	int	find_stop( slen, stp, n_descr, descr, l2r )
int	slen;
a361 1
int	*l2r;
d363 3
a365 3
	int	i, unbnd;
	int	stop;
	STREL_T	*stp1;
d367 2
a368 10
	if( RM_R2L( stp->s_type ) ){
		*l2r = 1;
		stop = stp->s_minlen + min_prefixlen( stp, descr ) - 1;
	}else{
		*l2r = 0;
		stop = stp->s_minlen + min_suffixlen( stp, descr );
		if( stop > 0 )
			stop--;
	}
	return( stop );
d403 106
@


1.10
log
@finds stop & start.  I believe that the stop/start pair for each
descr element is the basis for the mixed radix counter that will be
used to find things.
@
text
@d8 4
a11 1
static	int	strel_name();
a12 1
static	int	find_start2();
d14 1
a14 5
static	int	find_stop2();
static	void	find_plen();	
static	int	find_nlen();	
static	int	find_start3();
static	int	contains_unbnd();
a17 1
static	int	max_suffixlen();
d37 1
a37 1
print_limits( fp, slen, lev, prefix, fd, ld, n_descr, descr )
d73 1
a73 1
print_1_limit( fp, slen, lev, prefix, stp, n_descr, descr )
d127 1
a127 4
/*
	start = find_start2( stp, descr, &l2r );
*/
	start = find_start3( stp, descr, &l2r );
a131 1
/*
a132 2
*/
	stop = find_stop2( slen, stp, n_descr, descr, &l2r );
d151 30
a180 1
static	int	strel_name( stp, name )
a228 32
static	int	find_start( slen, stp, n_descr, descr, l2r )
int	slen;
STREL_T	*stp;
int	n_descr;
STREL_T	descr[];
int	*l2r;
{
	int	i;
	int	start;
	STREL_T	*stp1;

	if(    	stp->s_type == SYM_SS ||
		stp->s_type == SYM_H5 || stp->s_type == SYM_P5 ||
		stp->s_type == SYM_T1 || stp->s_type == SYM_T3 ||
		stp->s_type == SYM_Q1 || stp->s_type == SYM_Q4 )
	{
		*l2r = 1;
		start = 0;
		for( stp1 = descr, i = 0; i < stp->s_index; i++, stp1++ )
			start += stp1->s_minlen;
		return( start + 1 );
	}else{
		*l2r = 0;
		start = 0;
		for( i = stp->s_index + 1; i < n_descr; i++, stp1++ ){
			stp1 = &descr[ i ];
			start += stp1->s_minlen;
		}
		return( start );
	}
}

a239 50
	if(    	stp->s_type == SYM_SS ||
		stp->s_type == SYM_H5 || stp->s_type == SYM_P5 ||
		stp->s_type == SYM_T1 || stp->s_type == SYM_T3 ||
		stp->s_type == SYM_Q1 || stp->s_type == SYM_Q4 )
	{
		*l2r = 0;
		stop = 0;
		for( i = stp->s_index + 1; i < n_descr; i++, stp1++ ){
			stp1 = &descr[ i ];
			stop += stp1->s_minlen;
		}
		return( stop );
	}else{
		for( unbnd = 0, i = stp->s_index - 1; i >= 0; i-- ){
			stp1 = &descr[ i ];
			if( stp1->s_maxlen == UNBOUNDED ){
				unbnd = 1;
				break;
			}
		}
		if( unbnd ){
			*l2r = 1;
			stop = 0;
			for( i = stp->s_index - 1; i >= 0; i-- ){
				stp1 = &descr[ i ];
				stop += stp1->s_minlen;
			}
		}else{
			*l2r = 0;
			stop = 0;
			for( i = stp->s_index - 1; i >= 0; i-- ){
				stp1 = &descr[ i ];
				stop += stp1->s_maxlen;;
			}
		}
		return( stop );
	}
}

static	int	find_stop2( slen, stp, n_descr, descr, l2r )
int	slen;
STREL_T	*stp;
int	n_descr;
STREL_T	descr[];
int	*l2r;
{
	int	i, unbnd;
	int	stop;
	STREL_T	*stp1;

d252 1
a252 116
ext_prefix( stp, prefix, prefix1 )
STREL_T	*stp;
char	prefix[];
char	prefix1[];
{
	char	*pp, *pp1;
	int	plen;
	STREL_T	*stp0;
	int	inner, next, first;

	strcpy( prefix1, prefix );
	plen = strlen( prefix1 );
	pp = &prefix1[ plen - 1 ];

	inner = stp->s_inner != NULL;
	if( inner )
		first = stp->s_scope == 0;
	else
		first = 0;
	next = stp->s_next != NULL;
	if( next )
		*pp = '|';
	else if( *pp != '|' )
		*pp = ' ';
	if( first )
		strcat( prefix1, "  |" );
	strcat( prefix1, "  +" );
}

int	find_start2( stp, descr, l2r )
STREL_T	*stp;
STREL_T	descr[];
int	*l2r;
{
	int	start, s;
	int	plen, nlen;
	STREL_T	*stp1, *stp2;
	int	unbnd, s_unbnd, p_unbnd, n_unbnd ;

	s_unbnd = stp->s_maxlen == UNBOUNDED;
	if( RM_R2L( stp->s_type ) ){
		if( s_unbnd ){
			start = 0;
			for( stp1 = stp->s_next; stp1; stp1 = stp1->s_next )
				start += stp1->s_minglen;
		}else{
			find_plen( stp, descr, &p_unbnd, &start );
			if( p_unbnd ){
			}else{
				start += stp->s_maxlen; 
			}
		}
		*l2r = !( s_unbnd || p_unbnd );
		if( *l2r )
			start--;
	}else{
		*l2r = 1;
		p_unbnd = 0;
		for( start = 0, stp1 = stp->s_prev; stp1; stp1 = stp1->s_prev ){
			start += stp1->s_minglen;
			if( stp1->s_maxglen == UNBOUNDED )
				p_unbnd = 1;
		}
		for( s = stp->s_scope - 1; s >= 0; s-- ){
			stp2 = stp->s_scopes[ s ];
			start += stp2->s_minlen + stp2->s_minilen;
			if( stp2->s_maxlen==UNBOUNDED ||
				stp2->s_maxilen==UNBOUNDED )
				unbnd = 1;
		}
	}
	return( start );
}

static	void	find_plen( stp, descr, p_unbnd, plen )
STREL_T	*stp;
STREL_T	descr[];
int	*p_unbnd;
int	*plen;
{
	int	start, s, sl;
	STREL_T	*stp1, *stp2, *stp3; 

	*p_unbnd = 0;
	*plen = 0;
	stp1 = stp->s_outer;
	for( s = stp->s_index - 1; s >= stp1->s_index; s-- ){
		stp2 = &descr[ s ];
		if( stp2->s_maxlen == UNBOUNDED ){
			*p_unbnd = 1;
			break;
		}else
			*plen += stp2->s_maxlen;
	}
	if( !*p_unbnd ){
		for( stp2 = stp1->s_prev; stp2; stp2 = stp2->s_prev ){
			if( stp2->s_maxglen == UNBOUNDED ){
				*p_unbnd = UNBOUNDED;
				break;
			}else
				*plen += stp2->s_maxglen;
		}
	}else{
		*plen = 0;
		if( stp->s_n_scopes > 0 ){
			stp3 = stp->s_scopes[ stp->s_n_scopes - 1 ];
			sl = stp3->s_index;
			for( s = stp->s_index + 1; s <= sl; s++ ){
				stp2 = &descr[ sl ];
				*plen += stp2->s_minlen;
			}
		}
	}
}

find_start3( stp, descr, l2r )
d269 1
a269 1
			if( contains_unbnd( stp, descr ) ){
d286 1
a286 1
static	int	contains_unbnd( stp, descr )
a360 32
	return( slen );
}

static	int	max_suffixlen( stp, descr )
STREL_T	*stp;
STREL_T	descr[];
{
	STREL_T	*stp0, *stp1, *stpn;
	int	s, slen;

	if( stp->s_scope == UNDEF || stp->s_scope == 0 ){
		for( stp1 = stp->s_next; stp1; stp1 = stp1->s_next ){
			if( stp1->s_maxlen == UNBOUNDED )
				return( UNBOUNDED );
			slen += stp1->s_maxlen;
		}
		return( slen );
	}

	slen = 0;
	stpn = stp->s_scopes[ stp->s_n_scopes - 1 ];
	for( s = stp->s_index + 1; s <= stpn->s_index; s++ ){
		stp1 = &descr[ s ];
		if( stp1->s_maxlen == UNBOUNDED )
			return( UNBOUNDED );
		slen += stp1->s_maxlen;
	}
	stp0 = stp->s_scopes[ 0 ];
	for( stp1 = stp0->s_next; stp1; stp1 = stp1->s_next )
		if( stp1->s_maxlen == UNBOUNDED )
			return( UNBOUNDED );
		slen += stp1->s_maxlen;
@


1.9
log
@find_start2() is as far as it will go.  Start on find_start3().
@
text
@a2 1

a4 1

d7 1
d12 1
d15 6
d131 1
a131 4
	start = find_start( slen, stp, n_descr, descr, &l2r );
	sprintf( tstr, "%s%d", !l2r ? "$-" : "", start );
	sprintf( bp, " %5s", tstr );
	bp += strlen( bp );
d133 1
a133 2

	start = find_start2( stp, descr, &l2r );
d138 1
d140 2
d291 23
a323 3
/*
fprintf( stderr, "%3d: prefix  = '%s'\n", stp->s_index, prefix );
*/
a333 3
/*
	*pp = next ? '|' : ' ';
*/
a340 5
/*
fprintf( stderr, "index = %d, inner = %d next = %d first = %d\n",
	stp->s_index, inner, next, first );
fprintf( stderr, "%3d: prefix1 = '%s'\n", stp->s_index, prefix1 );
*/
d427 144
@


1.8
log
@moved find_tlen() to SE_link() (compile.c)
@
text
@d2 1
d7 2
d11 1
d13 2
d80 9
a88 1
	char	name[ 20 ], tstr[ 20 ];;
a89 2
	fprintf( fp, "%4d", stp->s_index );
	fprintf( fp, " %5d", stp->s_minlen );
d91 1
a91 1
		fprintf( fp, " UNBND" );
d93 3
a95 1
		fprintf( fp, " %5d", stp->s_maxlen );
d97 1
a97 1
		fprintf( fp, " UNDEF" );
d99 3
a101 1
		fprintf( fp, " %5d", stp->s_minglen );
d103 1
a103 1
		fprintf( fp, " UNBND" );
d105 1
a105 1
		fprintf( fp, " UNDEF" );
d107 3
a109 1
		fprintf( fp, " %5d", stp->s_maxglen );
d111 1
a111 1
		fprintf( fp, " UNDEF" );
d113 3
a115 1
		fprintf( fp, " %5d", stp->s_minilen );
d117 1
a117 1
		fprintf( fp, " UNBND" );
d119 1
a119 1
		fprintf( fp, " UNDEF" );
d121 4
a124 1
		fprintf( fp, " %5d", stp->s_maxilen );
d127 2
a128 4
	fprintf( fp, " %5s", tstr );
/*
	start = find_start2( stp, descr );
	fprintf( fp, " %5d", start );
d130 6
d138 3
a140 1
	fprintf( fp, " %5s", tstr );
d142 11
a152 4
	fprintf( fp, "  %s%s", prefix, name );
	if( stp->s_scope == 0 )
		fprintf( fp, "+--+" );
	fprintf( fp, "\n" );
d326 1
a326 1
int	find_start2( stp, descr )
d329 1
d331 48
a378 1
	int	s0;
d380 30
a409 2
	s0 = stp->s_scope == 0;
	fprintf( stderr, "\nfs: idx = %d, s0 = %d\n", stp->s_index, s0 );
@


1.7
log
@code added to compute sizes of each group along with the sizes of
each interior scope of each group.  Treats the entire descriptor as
part of an imaginary scope = 0.
@
text
@a20 7
	find_tlen( stderr, 1, 0, descr, &tminlen, &tmaxlen );
	fprintf( stderr, "tminlen/tmaxlen = %3d/", tminlen );
	if( tmaxlen == UNBOUNDED )
		fprintf( stderr, "UNBND\n" ); 
	else
		fprintf( stderr, "%3d\n", tmaxlen );

d105 4
d290 2
a291 4
find_tlen( fp, lev, fd, descr, tminlen, tmaxlen )
FILE	*fp;
int	lev;
int	fd;
a292 2
int	*tminlen;
int	*tmaxlen;
d294 1
a294 63
	int	d, d1, d2, nd;
	int	gminlen, gmaxlen;
	int	minlen2, minlen3;
	int	maxlen2, maxlen3;
	int	nlev;
	STREL_T	*stp, *stp1, *stp2, *stp3;

	*tminlen = 0;
	*tmaxlen = 0;
	for( d = fd; ; d = nd ){
		stp = &descr[ d ];
		gminlen = stp->s_minlen;
		gmaxlen = stp->s_maxlen;
		for( d1 = 0; d1 < stp->s_n_scopes - 1; d1++ ){
			stp1 = stp->s_scopes[ d1 ];
			stp2 = stp->s_scopes[ d1+1 ];
			if( stp1->s_inner ){
				stp3 = stp1->s_inner;
				find_tlen( fp, lev+2, stp3->s_index,
					descr, &minlen3, &maxlen3 );
				stp1->s_minilen = minlen3;
				stp1->s_maxilen = maxlen3;
				gminlen += minlen3;
				if( gmaxlen != UNBOUNDED ){
					if( maxlen3 == UNBOUNDED )
						gmaxlen = UNBOUNDED;
					else
						gmaxlen += maxlen3;
				}
			}
			find_len( fp, lev+1, stp2, &minlen2, &maxlen2 );
			gminlen += minlen2;
			if( gmaxlen != UNBOUNDED ){
				if( maxlen2 == UNBOUNDED )
					gmaxlen = UNBOUNDED;
				else
					gmaxlen += maxlen2;
			}
		} 
		stp->s_minglen = gminlen;
		stp->s_maxglen = gmaxlen;
		*tminlen += gminlen;
		if( *tmaxlen != UNBOUNDED ){
			if( gmaxlen == UNBOUNDED )
				*tmaxlen = UNBOUNDED;
			else
				*tmaxlen += gmaxlen; 
		}
		if( stp->s_next )
			nd = stp->s_next->s_index;
		else
			break;
	} 
}

find_len( fp, lev, stp, minlen, maxlen )
FILE	*fp;
int	lev;
STREL_T	*stp;
int	*minlen;
int	*maxlen;
{
	int	i;
d296 2
a297 2
	*minlen = stp->s_minlen;
	*maxlen = stp->s_maxlen;
@


1.6
log
@added debug code to print the lower/upper bounds of each element.  This was
exploratory to the realization that the descriptors needed to be scoped,
because these upper/lower bounds need to taken within the remaining interior
of the string after each containing descriptor has been provisionally found.
@
text
@d18 2
a19 7
	int	d;
	STREL_T	*stp;
	char	name[ 20 ];
	int	start, stop;
	int	minl, maxl;
	int	l2r;
	char	tstr[ 20 ];
d21 7
d29 53
d83 24
a106 27
	fprintf( stderr, "descr =" );
	for( stp = descr, d = 0; d < n_descr; d++, stp++ ){
		strel_name( stp, name );
		fprintf( stderr, "\t%5s", name );
	}
	fprintf( stderr, "\n" );

	fprintf( stderr, "minl  =" );
	for( minl = 0, stp = descr, d = 0; d < n_descr; d++, stp++ ){
		fprintf( stderr, "\t%5d", stp->s_minlen );
		minl += stp->s_minlen;
	}
	fprintf( stderr, "\t%5d\n", minl );

	fprintf( stderr, "maxl  =" );
	for( maxl = 0, stp = descr, d = 0; d < n_descr; d++, stp++ ){
		if( stp->s_maxlen == UNBOUNDED ){
			fprintf( stderr, "\tUNBND" );
			maxl = UNBOUNDED;
		}else{
			if( maxl != UNBOUNDED )
				maxl += stp->s_maxlen;
			fprintf( stderr, "\t%5d", stp->s_maxlen );
		}
	}
	if( maxl == UNBOUNDED )
		fprintf( stderr, "\tUNBND\n" );
d108 12
a119 18
		fprintf( stderr, "\t%5d\n", maxl );

	fprintf( stderr, "first =" );
	for( stp = descr, d = 0; d < n_descr; d++, stp++ ){
		start = find_start( slen, stp, n_descr, descr, &l2r );
		sprintf( tstr, "\%s%d", !l2r ? "$-" : "", start );
		fprintf( stderr, "\t%5s", tstr );
	}
	fprintf( stderr, "\n" );

	fprintf( stderr, "last  =" );
	for( stp = descr, d = 0; d < n_descr; d++, stp++ ){
		stop = find_stop( slen, stp, n_descr, descr );
		fprintf( stderr, "\t%5d", stop );
	}
	fprintf( stderr, "\n" );

	fprintf( stderr, "\n" );
d185 1
a185 2
		stp->s_type == SYM_Q1 || stp->s_type == SYM_Q4 ||
		stp->s_maxlen != UNBOUNDED )
d195 1
a195 1
		for( i = stp->s_index + 1; i < stp->s_index; i++, stp1++ ){
d203 1
a203 1
static	int	find_stop( slen, stp, n_descr, descr )
d208 1
d210 1
a210 1
	int	i;
d214 36
a249 3
	for( stop = 0, i = stp->s_index; i < n_descr; i++, stp1++ ){
		stp1 = &descr[ i ];
		stop += stp1->s_minlen;
d251 116
a366 4
	if( stp->s_type == SYM_H3 ){
		return(  slen - stop + stp->s_minlen );
	}else
		return(  slen - stop + 1 );
@


1.5
log
@continued with development: partially marking the limits of each strel.
Stumbled on problem that $- style address are from the inner 3' end of
the chunk just found, not from the end of the seq & that this requires
that each 2d struct group be nested.
@
text
@d58 1
a58 1
	fprintf( stderr, "start =" );
d66 1
a66 1
	fprintf( stderr, "stop  =" );
d132 1
a132 1
	int	i, unbnd;
d137 4
a140 4
		stp->s_type == SYM_H5 ||
		stp->s_type == SYM_P5 ||
		stp->s_type == SYM_T1 || 
		stp->s_type == SYM_Q1 )
a146 20
	}else if( stp->s_maxlen != UNBOUNDED ){
		start = stp->s_maxlen;
		unbnd = 0;
		for( i = stp->s_index - 1; i >= 0; i-- ){
			stp1 = &descr[ i ];
			if( stp1->s_maxlen == UNBOUNDED ){
				unbnd = 1;
				break;
			}
			start += stp1->s_maxlen;
		}
		if( !unbnd )
			return( start );
		*l2r = 0;
		start = 0;
		for( i = stp->s_index + 1; i < n_descr; i++ ){
			stp1 = &descr[ i ];
			start += stp1->s_minlen;
		}
		return( start );
d150 1
a150 1
		for( i = stp->s_index + 1; i < n_descr; i++ ){
@


1.4
log
@started in on find the stop/start limits of each strel.
@
text
@d7 2
d21 4
d31 1
a31 1
		fprintf( stderr, "\t%s", name );
d36 23
d60 3
a62 1
		fprintf( stderr, "\t%d", stp->s_minlen );
d66 1
a66 1
	fprintf( stderr, "maxl  =" );
d68 2
a69 4
		if( stp->s_maxlen == UNBOUNDED )
			fprintf( stderr, "\tUNBND", stp->s_maxlen );
		else
			fprintf( stderr, "\t%d", stp->s_maxlen );
d123 73
@


1.3
log
@get the lengths of the bits in order to determine where the
search should occur.
@
text
@d4 1
d6 1
a6 1
static	int	motiflen();
d8 1
a8 1
int	find_motif( n_descr, descr, sites, slen, sbuf )
d12 1
d16 3
a18 1
	int	mlen;
d20 25
a44 1
	mlen = motiflen( n_descr, descr, slen );
d47 3
a49 4
static	int	motiflen( n_descr, descr, slen )
int	n_descr;
STREL_T	descr[];
int	slen;
d52 42
@


1.2
log
@modified parm list to accept the seq & slen.
@
text
@d5 3
a7 1
int	find_rnamot( n_descr, descr, sites, slen, sbuf )
d13 10
@


1.1
log
@Initial revision
@
text
@d5 1
a5 2
int	find_rnamot( fp, n_descr, descr, sites )
FILE	*fp;
d9 2
@
