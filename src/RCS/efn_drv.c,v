head	1.14;
access;
symbols;
locks; strict;
comment	@ * @;


1.14
date	2002.05.15.04.38.45;	author macke;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.14.19.13.19;	author macke;	state Exp;
branches;
next	1.12;

1.12
date	2001.10.29.20.02.18;	author macke;	state Exp;
branches;
next	1.11;

1.11
date	2000.10.09.19.38.39;	author macke;	state Exp;
branches;
next	1.10;

1.10
date	2000.10.07.05.17.57;	author macke;	state Exp;
branches;
next	1.9;

1.9
date	2000.08.31.20.05.27;	author macke;	state Exp;
branches;
next	1.8;

1.8
date	2000.08.31.20.01.34;	author macke;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.30.19.52.40;	author macke;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.30.17.54.09;	author macke;	state Exp;
branches;
next	1.5;

1.5
date	2000.08.30.17.18.18;	author macke;	state Exp;
branches;
next	1.4;

1.4
date	2000.08.30.15.54.55;	author macke;	state Exp;
branches;
next	1.3;

1.3
date	2000.08.30.04.27.22;	author macke;	state Exp;
branches;
next	1.2;

1.2
date	2000.08.30.03.37.24;	author macke;	state Exp;
branches;
next	1.1;

1.1
date	2000.08.30.03.07.31;	author macke;	state Exp;
branches;
next	;


desc
@driver program for efn.c.
@


1.14
log
@converted boolean 0,1 -> FALSE,TRUE
@
text
@/*
 *	This program is a transliteration of the Zuker program efn.f
 *	I have made several obvious modifications in the string handling
 *	of the get data parts. I have also renumbered each array to begin
 *	at C's 0, vs the original FTN's 1.
 *
 *	I have noticed a possible bug in the routine that reads the
 * 	misc loop file, in an if that is always true ...  I have left
 *	it alone.
 *
 *	Since this program is intended for incorporation into rnamotif
 *	which can NOT do circular molecules I have discarded the
 *	bookkeeping that makes circular NA's into linear ones.
 *
 */
#include <stdio.h>
#include <string.h>

#include "rmdefs.h"
#include "rnamot.h"

int	rm_error;
char	rm_wdfname[ 256 ];
int	rm_emsg_lineno = UNDEF;

char	rm_bc2b[ N_BCODES ] = { 'a', 'c', 'g', 't', 'n' };

char	rm_efndatadir[ 256 ];
int	rm_efnds_allocated;
int	rm_efndataok;
int	rm_l_base;
int	*rm_hstnum;
int	*rm_bcseq;
int	*rm_basepr;

char	*getenv();

static	int	getct( FILE * );
static	int	base2num( int );

int	RM_getefndata( void );
int	RM_efn( int, int, int );

main( argc, argv )
int	argc;
char	*argv[];
{
	FILE	*cfp = NULL;
	char	*ep;
	int	n_bases;
	int	e;
	int	rval = 0;

	if( ( ep = getenv( "EFNDATA" ) ) == NULL ){
		fprintf( stderr, "%s: EFNDATA not defined.\n", argv[ 0 ] );
		rval = 1;
		goto CLEAN_UP;
	}else{
		strcpy( rm_efndatadir, ep );
		if( ( rm_efndataok = RM_getefndata() ) == 0 ){
			rm_efndataok = FALSE; 
			rval = 1;
			goto CLEAN_UP;
		}
	}

	if( argc == 1 ){
		cfp = stdin;
		strcpy( rm_wdfname, " -- stdin -- " );
	}else if( argc > 2 ){
		fprintf( stderr, "usage: %s [ ct-file ]\n", argv[ 0 ] );
		rval = 1;
		goto CLEAN_UP;
	}else if( ( cfp = fopen( argv[ 1 ], "r" ) ) == NULL ){
		fprintf( stderr, "%s: can't read ct-file %s\n",
			argv[ 0 ], argv[ 1 ] );
		rval = 1;
		goto CLEAN_UP;
	}else
		strcpy( rm_wdfname, argv[ 1 ] );

	if( ( n_bases = getct( cfp ) ) == 0 ){
		rval = 1;
		goto CLEAN_UP;
	}
	rm_l_base = n_bases - 1;

	/* check for knots, abort if found.	*/
	if( RM_knotted() ){
		rval = 1;
		goto CLEAN_UP;
	}

	RM_initst();
	e = RM_efn( 0, rm_l_base, TRUE );
	printf( "energy = %8.3f\n", 0.01 * e );

CLEAN_UP : ;
	if( cfp != NULL && cfp != stdin )
		fclose( cfp );

	exit( rval );
}

static	int	getct( FILE *fp )
{
	char	line[ 256 ];
	int	i, npr;
	int	bn, prev, next, pn, hn;
	char	b[ 2 ];

	fgets( line, sizeof( line ), fp );
	sscanf( line, "%d", &npr );

	if( RM_allocefnds( npr ) )
		return( 0 );

	for( i = 0; i < npr; i++ ){
		fgets( line, sizeof( line ), fp );
		sscanf( line, "%d %s %d %d %d %d",
			&bn, b, &prev, &next, &pn, &hn );
		bn--;
		pn = pn == 0 ? UNDEF : pn - 1;
		rm_bcseq[ bn ] = base2num( *b );
		rm_basepr[ bn ] = pn;
		rm_hstnum[ bn ] = hn;
	}

	return( npr );
}

static	int	base2num( int b )
{

	switch( b ){
	case 'a' :
	case 'A' :
		return( BCODE_A );
		break;
	case 'c' :
	case 'C' :
		return( BCODE_C );
		break;
	case 'g' :
	case 'G' :
		return( BCODE_G );
		break;
	case 't' :
	case 'T' :
	case 'u' :
	case 'U' :
		return( BCODE_T );
		break;

	default :
		return( BCODE_N );
		break;
	}
}
@


1.13
log
@added new include file rmdefs.h used to define UNDEF, FALSE, TRUE, of which
only UNDEF is used right now.
@
text
@d61 1
a61 1
			rm_efndataok = 0; 
d95 1
a95 1
	e = RM_efn( 0, rm_l_base, 1 );
@


1.12
log
@updated to reflect various changes in file handling as well as adding
efn2()
@
text
@d19 1
@


1.11
log
@added called to RM_initst() which will be required for recursive version
of RM_efn().
@
text
@d22 1
a22 1
char	rm_dfname[ 256 ];
d28 1
d68 1
a68 1
		strcpy( rm_dfname, " -- stdin -- " );
d79 1
a79 1
		strcpy( rm_dfname, argv[ 1 ] );
@


1.10
log
@converted all headers from K&R to ANSI.
@
text
@d92 1
@


1.9
log
@renamed RM_efninit() to RM_allocefnds()
@
text
@d36 2
a37 2
static	int	getct();
static	int	base2num();
d39 2
a40 2
int	RM_getefndata();
int	RM_efn();
d102 1
a102 2
static	int	getct( fp )
FILE	*fp;
d129 1
a129 2
static	int	base2num( b )
int	b;
@


1.8
log
@removed d/s allocation to efn.c
@
text
@d113 1
a113 1
	if( RM_efninit( npr ) )
@


1.7
log
@Good enough.
@
text
@d113 1
a113 3
	rm_hstnum = ( int * )malloc( npr * sizeof( int ) );
	if( rm_hstnum == NULL ){
		fprintf( stderr, "getct: can't allocate rm_hstnum\n" );
a114 11
	}
	rm_bcseq = ( int * )malloc( npr * sizeof( int ) );
	if( rm_bcseq == NULL ){
		fprintf( stderr, "getct: can't allocate rm_bcseq\n" );
		return( 0 );
	}
	rm_basepr = ( int * )malloc( npr * sizeof( int ) );
	if( rm_basepr == NULL ){
		fprintf( stderr, "getct: can't allocate rm_basepr\n" );
		return( 0 );
	}
@


1.6
log
@about as small as it gets.
@
text
@d29 4
a32 5

extern	int	rm_l_base;
extern	int	*rm_hstnum;
extern	int	*rm_bcseq;
extern	int	*rm_basepr;
@


1.5
log
@data is now here and is now extern to efn.c
@
text
@a34 2
static	int	base2num();

d38 1
a38 1
static	int	knotted();
d88 1
a88 1
	if( knotted() ){
a141 32
}

static	int	knotted()
{
	int	i, j, ip, k, l;
	int	rval;

	for( rval = 0, i = 0; i <= rm_l_base; i++ ){
		if( rm_basepr[ i ] != UNDEF ){
			j = MAX( i, rm_basepr[i] );
			ip = MIN( i, rm_basepr[i] );
			if( rm_basepr[ip] != j || rm_basepr[j] != ip ){
				rval = 1;
				fprintf( stderr,
					"Base pair %5d.%5d is not reflexive\n",
					rm_hstnum[ip], rm_hstnum[j] );
			}
			for( k = ip+1; k <= j-1; k++ ){
				if( rm_basepr[ k ] != UNDEF ){
					l = rm_basepr[ k ];
					if( l <= ip || l >= j ){
						rval = 1;
						fprintf( stderr,
		"Base pairs %5d.%5d and %5d.%5d are improperly nested.\n",
							rm_hstnum[ip], rm_hstnum[j],
							rm_hstnum[k], rm_hstnum[l] );
					}
				}
			}
		}
	}
	return( rval );
@


1.4
log
@moved the getenv() stuff that finds where the data is
to the driver where it is stored in rm_efndatadir and its status
in rm_efndataok.
@
text
@d30 4
a33 6
extern	int	n_bases;
extern	int	l_base;
extern	int	*hstnum;
extern	int	*force;
extern	int	*numseq;
extern	int	*basepr;
d51 2
a53 1
	int	e;
d87 1
a87 1
	l_base = n_bases - 1;
d95 1
a95 1
	e = RM_efn( 0, l_base, 1 );
d116 3
a118 8
	hstnum = ( int * )malloc( npr * sizeof( int ) );
	if( hstnum == NULL ){
		fprintf( stderr, "getct: can't allocate hstnum\n" );
		return( 0 );
	}
	force = ( int * )malloc( npr * sizeof( int ) );
	if( force == NULL ){
		fprintf( stderr, "getct: can't allocate force\n" );
d121 3
a123 3
	numseq = ( int * )malloc( npr * sizeof( int ) );
	if( numseq == NULL ){
		fprintf( stderr, "getct: can't allocate numseq\n" );
d126 3
a128 3
	basepr = ( int * )malloc( npr * sizeof( int ) );
	if( basepr == NULL ){
		fprintf( stderr, "getct: can't allocate basepr\n" );
d138 3
a140 3
		numseq[ bn ] = base2num( *b );
		basepr[ bn ] = pn;
		hstnum[ bn ] = hn;
d151 5
a155 5
	for( rval = 0, i = 0; i <= l_base; i++ ){
		if( basepr[ i ] != UNDEF ){
			j = MAX( i, basepr[i] );
			ip = MIN( i, basepr[i] );
			if( basepr[ip] != j || basepr[j] != ip ){
d159 1
a159 1
					hstnum[ip], hstnum[j] );
d162 2
a163 2
				if( basepr[ k ] != UNDEF ){
					l = basepr[ k ];
d168 2
a169 2
							hstnum[ip], hstnum[j],
							hstnum[k], hstnum[l] );
@


1.3
log
@supports RM_errormsg() in efn.c
@
text
@d27 3
d51 2
a52 1
	FILE	*cfp;
d56 13
d74 2
a75 1
		exit( 1 );
d79 2
a80 1
		exit( 1 );
a95 5
	if( RM_getefndata() ){
		rval = 1;
		goto CLEAN_UP;
	}

d100 1
a100 1
	if( cfp != stdin )
@


1.2
log
@fairly clean driver.  Next step will be rename the various
arrays that hold the sequence, pairing and hstnum values, but
not yet.
@
text
@d21 4
a24 1
	/* name chosen to match variable in rnamotif */
d52 1
a52 1
	if( argc == 1 )
d54 2
a55 1
	else if( argc > 2 ){
d62 2
a63 1
	}
@


1.1
log
@Initial revision
@
text
@d19 1
a19 4
#define	ADE	0
#define	CYT	1
#define	GUA	2
#define	THY	3
d21 2
a22 1
#define	UNDEF		(-1)
a23 3
#define	MAX(a,b)	((a)>(b)?(a):(b))
#define	MIN(a,b)	((a)<(b)?(a):(b))

a30 2
static	char	num2base[ 4 ] = { 'A', 'C', 'G', 'T' };
#define	N2B(n)	((n)>=0&&(n)<=3?num2base[(n)]:'X')
a38 1

d172 1
a172 1
		return( ADE );
d176 1
a176 1
		return( CYT );
d180 1
a180 1
		return( GUA );
d186 1
a186 1
		return( THY );
d190 1
a190 1
		return( 4 );
@
