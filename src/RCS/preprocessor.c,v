head	1.6;
access;
symbols;
locks; strict;
comment	@ * @;


1.6
date	2002.05.15.23.06.38;	author macke;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.18.23.54.48;	author macke;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.18.03.02.55;	author macke;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.17.23.15.10;	author macke;	state Exp;
branches;
next	1.2;

1.2
date	2000.12.15.22.43.33;	author macke;	state Exp;
branches;
next	1.1;

1.1
date	2000.12.14.05.28.22;	author macke;	state Exp;
branches;
next	;


desc
@set of routines that performs file inclusion, along with the
interpolation of any command line parms before the reserved
word `descr'
@


1.6
log
@replaced boolean 0,1 with FALSE,TRUE
@
text
@#include <stdio.h>
#include <ctype.h>
#include <string.h>

#include "rmdefs.h"
#include "rnamot.h"

extern	int	rm_error;
extern	char	*rm_dfname;
extern	char	*rm_wdfname;
extern	char	*rm_xdfname;
extern	int	rm_lineno;
extern	int	rm_emsg_lineno;
extern	char	*rm_cldefs;
extern	INCDIR_T	*rm_idlist;

typedef	struct	fstk_t	{
	char	*f_fname;
	FILE	*f_fp;
	int	f_lineno;
} FSTK_T;

#define	FSTK_SIZE	10
static	FSTK_T	fstk[ FSTK_SIZE ];
static	int	fstkp = -1;
#define	IS_FSTK_EMPTY()	(fstkp==-1)
#define	IS_FSTK_FULL()	(fstkp>=FSTK_SIZE-1)

static	char	emsg[ 256 ];

static	FILE	*pushfile( char [] );
static	FILE	*popfile();
static	FILE	*include();
static	void	dumpfstk( FILE *, char [] );
static	FILE	*getline( char [], int, FILE * );
static	void	putline( FILE *, char [], int, char [] );
static	char	*isdescr( char [] );

char	*RM_str2seq( char [] );

char	*RM_preprocessor( void )
{
	FILE	*dfp, *ofp;
	char	line[ 1024 ];
	char	work[ 1024 ];
	char	*dp, *lp;

	rm_wdfname = rm_dfname;
	if( ( dfp = pushfile( rm_wdfname ) ) == NULL ){
		fprintf( stderr,
			"RM_preprocessor: can't read descr file '%s'.\n",
			rm_dfname );
		return( NULL );
	}
	if( rm_xdfname == NULL )
		rm_xdfname = tempnam( NULL, "rmxd" );
	if( ( ofp = fopen( rm_xdfname, "w" ) ) == NULL ){
		fprintf( stderr,
			"RM_preprocessor: can't write temp file '%s'.\n",
			rm_xdfname );
		return( NULL );
	}

	for( ; dfp = getline( line, sizeof( line ), dfp ); ){
		rm_lineno++;
		if( *line == '#' ){
			for( lp = &line[1]; isspace( *lp ); lp++ )
				;
			if( !strncmp( lp, "include", 7 ) )
				dfp = include( line );		
		}else if( dp = isdescr( line ) ){
			if( rm_cldefs != NULL ){
				if( dp > line ){
					strncpy( work, line, dp - line );
					work[ dp - line ] = '\0';
					putline( ofp,
						rm_wdfname, rm_lineno, work );
				}
				putline( ofp, "cmd line defs", 1, rm_cldefs );
				putline( ofp, rm_wdfname, rm_lineno, dp );
			}else
				putline( ofp, rm_wdfname, rm_lineno, line );
		}else{
			putline( ofp, rm_wdfname, rm_lineno, line );
		}
	} 
	fclose( ofp );

	return( rm_xdfname );
}

static	FILE	*pushfile( char fname[] )
{
	char	*sp;
	FILE	*fp;
	FSTK_T	*fsp;

	if( IS_FSTK_FULL() ){
		sprintf( emsg, "pushfile: fstk overflow: '%s'.", fname );
		rm_emsg_lineno = rm_lineno;
		RM_errormsg( TRUE, emsg );
	}
	sp = ( char * )malloc( strlen( fname ) + 1 );
	if( sp == NULL ){
		sprintf( emsg, "RM_pushfile: can't allocate fname for: '%s'.",
			fname );
		rm_emsg_lineno = rm_lineno;
		RM_errormsg( TRUE, emsg );
	}
	strcpy( sp, fname );
	if( ( fp = fopen( fname, "r" ) ) == NULL ){
		sprintf( emsg, "RM_pushfile: can't read '%s'.", fname );
		rm_emsg_lineno = rm_lineno;
		RM_errormsg( TRUE, emsg );
	}
	if( !IS_FSTK_EMPTY() )
		fstk[ fstkp ].f_lineno = rm_lineno;
	fstkp++;
	fsp = &fstk[ fstkp ];
	fsp->f_fname = sp;
	fsp->f_fp = fp;
	fsp->f_lineno = 0;
	rm_wdfname = fsp->f_fname;
	rm_lineno = 0;

	return( fp );
}

static	FILE	*popfile( void )
{
	FSTK_T	*fsp;

	if( IS_FSTK_EMPTY() )
		return( NULL );

	fsp = &fstk[ fstkp ];
	fclose( fsp->f_fp );
	free( fsp->f_fname );
	fstkp--;
	if( IS_FSTK_EMPTY() )
		return( NULL );

	fsp = &fstk[ fstkp ];
	rm_wdfname = fsp->f_fname;
	rm_lineno = fsp->f_lineno;

	return( fsp->f_fp );
}

static	FILE	*include( char str[] )
{
	char	*sp, *sp1, *sp2;
	char	work[ 256 ], fname[ 256 ], path[ 256 ];
	int	c;
	FILE	*fp;
	INCDIR_T	*idp;

	for( sp = &str[1]; isspace( *sp ); sp++ )
		;
	for( ; *sp && !isspace( *sp ); sp++ )
		;
	if( *sp == '\0' ){
		RM_errormsg( TRUE, "RM_include: no filename." );
	}
	for( ; isspace( *sp ); sp++ )
		;
	if( *sp == '"' )
		c = '"';
	else if( *sp == '<' )
		c = '>';
	else if( *sp == '\'' )
		c = '\'';
	else{
		sprintf( emsg, "RM_include: bad include filename '%s'.", sp );
		rm_emsg_lineno = rm_lineno;
		RM_errormsg( TRUE, emsg );
	}
	sp++;
	if( ( sp1 = strchr( sp, c ) ) == NULL ){
		sprintf( emsg, "RM_include: bad include filename '%s'.", sp );
		rm_emsg_lineno = rm_lineno;
		RM_errormsg( TRUE, emsg );
	}
	strncpy( work, sp, sp1 - sp );
	work[ sp1 - sp ] = '\0';
	if( c == '"' ){
		sp2 = RM_str2seq( work );
		strcpy( fname, sp2 );
	}else
		strcpy( fname, work );

	if( rm_idlist == NULL )
		fp = pushfile( fname );
	else{
		for( idp = rm_idlist; idp; idp = idp->i_next ){
			sprintf( path, "%s/%s", idp->i_name, fname );
			if( fp = pushfile( path ) )
				break;
		}
	}
	if( fp == NULL ){
		sprintf( emsg,
			"RM_include: can't find include file '%s'.", fname );
		rm_emsg_lineno = rm_lineno;
		RM_errormsg( TRUE, emsg );
	}
	
	return( fp );
}

static	void	dumpfstk( FILE *fp, char msg[] )
{
	int	f;	
	FSTK_T	*fsp;

	fprintf( fp, "%s FSTK: %d entries\n", msg, fstkp + 1 );
	for( f = fstkp; f >= 0; f-- ){
		fsp = &fstk[ f ];
		fprintf( fp, "fstk[%2d] = '%s', line = %d\n",
			f, fsp->f_fname, fsp->f_lineno );
			
	} 
}

static	FILE	*getline( char line[], int l_size, FILE *fp )
{

	do{
		if( fgets( line, l_size, fp ) )
			return( fp );
	}while( fp = popfile() );
	return( NULL );
}
static	void	putline( FILE *fp, char fname[], int lineno, char line[] ) 
{

	fprintf( fp, "\n# line %d '%s'\n", lineno, fname );
	fprintf( fp, "%s", line );
}

static	char	*isdescr( char line[] )
{
	char	*dp, *edp, *qp, *qp1;
	int	instr;

	if( ( dp = strstr( line, "descr" ) ) == NULL ) 
		return( NULL );
	edp = dp + 5;
	if( !isspace( *edp ) && *edp != '#' )
		return( NULL );
	if( dp == line ) 
		return( line );
	if( !isspace( dp[-1] ) && dp[-1] != ';' )
		return( NULL );
	if( ( qp = strchr( line, '\'' ) ) != NULL ){
		if( qp < dp ){
			for( instr = TRUE, qp1 = qp + 1; qp1 < dp; qp1++ ){
				if( *qp1 == '\'' )
					instr ^= TRUE;
				else if( *qp1 == '\\' )
					qp1++;
			}
			return( !instr ? dp : NULL );
		}
	}
	if( ( qp = strchr( line, '"' ) ) != NULL ){
		if( qp < dp ){
			for( instr = TRUE, qp1 = qp + 1; qp1 < dp; qp1++ ){
				if( *qp1 == '"' )
					instr ^= TRUE;
				else if( *qp1 == '\\' )
					qp1++;
			}
			return( instr ? dp : NULL );
		}
	}
	return( dp );
}
@


1.5
log
@Added test to check if rm_xdfname != NULL, and if so, don't create it.
@
text
@d5 1
d101 1
a101 1
		RM_errormsg( 1, emsg );
d108 1
a108 1
		RM_errormsg( 1, emsg );
d114 1
a114 1
		RM_errormsg( 1, emsg );
d163 1
a163 1
		RM_errormsg( 1, "RM_include: no filename." );
d176 1
a176 1
		RM_errormsg( 1, emsg );
d182 1
a182 1
		RM_errormsg( 1, emsg );
d205 1
a205 1
		RM_errormsg( 1, emsg );
d257 1
a257 1
			for( instr = 1, qp1 = qp + 1; qp1 < dp; qp1++ ){
d259 1
a259 1
					instr ^= 1;
d268 1
a268 1
			for( instr = 1, qp1 = qp + 1; qp1 < dp; qp1++ ){
d270 1
a270 1
					instr ^= 1;
@


1.4
log
@changed (back, again) rm_wdfname from rm_wdfname[X] to a pointer.  All
data now contained in this var is allocated and save during the lifetime
of a run.
@
text
@d40 1
a40 1
char	*RM_preprocess( void )
d49 2
a50 1
		fprintf( stderr, "RM_preprocess: can't read descr file '%s'.\n",
d54 2
a55 1
	rm_xdfname = tempnam( NULL, "rmxd" );
d57 2
a58 1
		fprintf( stderr, "RM_preprocess: can't write temp file '%s'.\n",
@


1.3
log
@fixed logic in line number to start on 0, in case the 1st file can
not be read.
@
text
@d9 1
a9 1
extern	char	rm_wdfname[];
d47 1
a47 1
	strcpy( rm_wdfname, rm_dfname );
d119 1
a119 1
	strcpy( rm_wdfname, fsp->f_fname );
d140 1
a140 1
	strcpy( rm_wdfname, fsp->f_fname );
@


1.2
log
@added code to set the working file to rm_wdfname; set rm_xdfname.
@
text
@d9 1
a9 1
extern	char	*rm_wdfname;
d12 1
d16 6
d47 1
a47 1
	rm_wdfname = rm_dfname;
d95 2
a96 1
		sprintf( emsg, "pushfile: fstk overflow: %s.", fname );
d101 1
a101 1
		sprintf( emsg, "RM_pushfile: can't allocate fname for: %s.",
d103 1
d108 2
a109 1
		sprintf( emsg, "RM_pushfile: can't read %s.", fname );
d119 1
a119 1
	rm_wdfname = fsp->f_fname;
a127 1
	char	*pp;
d140 1
a140 1
	rm_wdfname = fsp->f_fname;
a152 1
	FSTK_T	*fsp;
d171 1
d177 1
d200 1
@


1.1
log
@Initial revision
@
text
@d9 2
a35 1
	char	*ofname;
d40 2
a41 1
	if( ( dfp = pushfile( rm_dfname ) ) == NULL ){
d46 2
a47 2
	ofname = tempnam( NULL, "rmxd" );
	if( ( ofp = fopen( ofname, "w" ) ) == NULL ){
d49 1
a49 1
			ofname );
d66 1
a66 1
						rm_dfname, rm_lineno, work );
d69 1
a69 1
				putline( ofp, rm_dfname, rm_lineno, dp );
d71 1
a71 1
				putline( ofp, rm_dfname, rm_lineno, line );
d73 1
a73 1
			putline( ofp, rm_dfname, rm_lineno, line );
d78 1
a78 1
	return( ofname );
d109 1
a109 1
	rm_dfname = fsp->f_fname;
d131 1
a131 1
	rm_dfname = fsp->f_fname;
@
