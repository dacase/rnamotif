head	1.11;
access;
symbols;
locks; strict;
comment	@ * @;


1.11
date	2002.11.29.00.32.47;	author macke;	state Exp;
branches;
next	1.10;

1.10
date	2002.01.31.19.46.22;	author macke;	state Exp;
branches;
next	1.9;

1.9
date	2001.10.29.20.03.37;	author macke;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.06.06.12.32;	author macke;	state Exp;
branches;
next	1.7;

1.7
date	2001.02.06.05.35.34;	author macke;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.21.21.52.29;	author macke;	state Exp;
branches;
next	1.5;

1.5
date	2000.11.29.18.08.34;	author macke;	state Exp;
branches;
next	1.4;

1.4
date	2000.11.29.17.16.17;	author macke;	state Exp;
branches;
next	1.3;

1.3
date	2000.11.29.04.59.37;	author macke;	state Exp;
branches;
next	1.2;

1.2
date	2000.11.28.23.43.12;	author macke;	state Exp;
branches;
next	1.1;

1.1
date	2000.11.27.22.04.25;	author macke;	state Exp;
branches;
next	;


desc
@new version that deals with multi-field score.
@


1.11
log
@replaced calls to tempnam() with calls to mkstemp()
@
text
@#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>

#define	U_MSG_S	\
	"usage: %s [ -a ] [ -l ] [ -smax N ] [ -td dir ] [ rm-output-file ]\n"

#define	MIN(a,b)	((a)<(b)?(a):(b))
#define	MAX(a,b)	((a)>(b)?(a):(b))

#define	SMAX		30000000	/* largest file to sort */
#define	MAXFIELDS	200
#define	OFIELD1		1
#define	DFIELD1		4
#define	MAXW		20
static	char	*fields[ MAXFIELDS ];
static	char	*sfields[ MAXFIELDS ];
static	int	smaxw;
static	char	*ofields[ MAXFIELDS ];
static	int	*ofmt;
static	int	*omaxw;
static	int	n_fields, n_ofields, n_sfields, n_sfields1, m_sfields;

#define	LINE_SIZE	50000
static	char	ra_line[ LINE_SIZE ];
static	char	line[ LINE_SIZE ];
static	char	dline[ LINE_SIZE ];

#define	WBSIZE	70

#define	FMT_LEFT	0
#define	FMT_RIGHT	1
static	int	getline( char [], FILE * );
static	void	ungetline( char [] );
static	int	*getfmt( int, int, char *[], int * );
static	int	is_a_number( char [] );
static	int	fcmprs( int, char [] );
static	void	align( FILE *, int, char [], char [] );

main( int argc, char *argv[] )
{
	char	*ifname, *tfdir;
	FILE	*ifp, *tfp1, *tfp2;
/*
	char	*tfnp1, *tfnp2;
*/
	char	tfnp1[ 256 ], tfnp2[ 256 ];
	int	tfd1, tfd2;
	char	cmd[ 256 ];
	char	*sp, *vbp, *l_vbp;
	int	ac, f, fw, fs, of1, df1;
	int	aopt, lopt, scored, sort;
	int	smax;
	struct	stat	sbuf;

	ifname = NULL;
	tfdir = NULL;
	aopt = 0;	/* 1 = make fastn alignment		*/ 
	lopt = 0;	/* 1 = print only entry's locus name	*/
	smax = SMAX;	/* Don't sort files larger than SMAX	*/
	for( ac = 1; ac < argc; ac++ ){
		if( !strcmp( argv[ ac ], "-a" ) )
			aopt = 1;
		else if( !strcmp( argv[ ac ], "-l" ) )
			lopt = 1;
		else if( !strcmp( argv[ ac ], "-smax" ) ){
			ac++;
			if( ac >= argc ){
				fprintf( stderr, U_MSG_S, argv[ 0 ] );
				exit( 1 );
			}
			smax = atoi( argv[ ac ] );
		}else if( !strcmp( argv[ ac ], "-td" ) ){
			ac++;
			if( ac >= argc ){
				fprintf( stderr, U_MSG_S, argv[ 0 ] );
				exit( 1 );
			}else if( tfdir != NULL ){
				fprintf( stderr, U_MSG_S, argv[ 0 ] );
				exit( 1 );
			}else
				tfdir = argv[ ac ];
		}else if( *argv[ ac ] == '-' ){
			fprintf( stderr, U_MSG_S, argv[ 0 ] );
			exit( 1 );
		}else if( ifname != NULL ){
			fprintf( stderr, U_MSG_S, argv[ 0 ] );
			exit( 1 );
		}else
			ifname = argv[ ac ];
	}
	if( ifname == NULL ){
		ifp = stdin;
	}else if( ( ifp = fopen( ifname, "r" ) ) == NULL ){
		fprintf( stderr, "%s: can't read rm-output-file '%s'\n",
			argv[ 0 ], ifname );
		exit( 1 );
	}
	if( tfdir == NULL )
		tfdir = P_tmpdir;

/*
	tfnp1 = tempnam( tfdir, "raw" );
	if( ( tfp1 = fopen( tfnp1, "w+" ) ) == NULL ){
		fprintf( stderr, "%s: can't open temp-file '%s'\n",
			argv[ 0 ], tfnp1 );
		exit( 1 );
	}
*/
	sprintf( tfnp1, "%s/raw_XXXXXX", tfdir );
	tfd1 = mkstemp( tfnp1 );
	if( ( tfp1 = fdopen( tfd1, "w+" ) ) == NULL ){
		fprintf( stderr, "%s: can't open temp-file '%s'\n",
			argv[ 0 ], tfnp1 );
		exit( 1 );
	}

	while( getline( line, ifp ) ){
		if( *line == '>' ){
			ungetline( line );
			break;
		}
		n_fields = split( line, fields, " \t\n" );
		if( n_fields == 0 )
			continue;
		else if( !strcmp( fields[ 0 ], "#RM" ) ){
			if( n_fields < 2 )
				continue;
			if( !strcmp( fields[ 1 ], "descr" ) ){
				ofmt = getfmt( n_fields, DFIELD1, fields,
					&n_ofields );
				if( ofmt == NULL )
					exit( 1 );
			}
			if( !aopt )
				fputs( line, stdout );
			continue;
		}
		for( f = 0; f < n_fields; f++ )
			free( fields[ f ] );
	}

	omaxw = ( int * )malloc( ( n_ofields ) * sizeof( int ) );
	if( omaxw == NULL ){
		fprintf( stderr, "%s: can't allocate omaxw.\n",
			argv[ 0 ] );
		exit( 1 );
	}
	for( f = 0; f < n_ofields; f++ )
		omaxw[ f ] = 0;

	m_sfields = 0;
	for( n_sfields1 = 0, scored = 1, sort = 1; getline( line, ifp ); ){
		if( *line == '#' )
			continue;	/* allow cat of rnamotif runs */
		if( *line == '>' ){
			if( aopt )
				fputs( line, tfp1 );
			continue;
		}

		n_fields = split( line, fields, " \t\n" );
		df1 = n_fields - ( n_ofields - DFIELD1 );
		of1 = df1 - ( DFIELD1 - OFIELD1 );
		n_sfields = df1 - DFIELD1;
		m_sfields = MAX( m_sfields, n_sfields );

		if( n_sfields > 1 )
			scored = 0;

		if( n_sfields1 == 0 )
			n_sfields1 = n_sfields;
		else if( n_sfields != m_sfields )
			sort = 0;

		ofields[ 0 ] = fields[ 0 ];
		for( f = of1; f < n_fields; f++ )
			ofields[ f - of1 + 1 ] = fields[ f ];
		for( f = 0; f < n_sfields; f++ )
			sfields[ f ] = fields[ f + 1 ];

		if( scored )
			scored = is_a_number( sfields[ 0 ] );

		if( lopt ){
			for( l_vbp = vbp = NULL, sp = ofields[ 0 ]; *sp; sp++ ){
				if( *sp == '|' ){
					l_vbp = vbp;
					vbp = sp;
				}
			}
			if( vbp != NULL ){
				vbp++;
				if( *vbp != '\0' )
					strcpy( ofields[ 0 ], vbp );
				else if( l_vbp != NULL ){
					l_vbp++;
					vbp--;
					strncpy( ofields[0], l_vbp, vbp-l_vbp );
					ofields[0][vbp-l_vbp] = '\0';
				}else{
					vbp--;
					*vbp = '\0';
				}
			}
		}
		fw = strlen( ofields[ 0 ] );
		if( fw > omaxw[ 0 ] )
			omaxw[ 0 ] = fw;
		for( fw = 0, f = 0; f < n_sfields; f++ ){
			fw += strlen( sfields[ f ] );
		}
		fw += ( n_sfields - 1 );
		if( fw > smaxw )
			smaxw = fw;
		for( f = OFIELD1; f < DFIELD1; f++ ){
			fw = strlen( ofields[ f ] );
			if( fw > omaxw[ f ] )
				omaxw[ f ] = fw;
		}
		for( f = DFIELD1; f < n_ofields; f++ ){
			fw = strlen( ofields[ f ] );
			if( !aopt ){
				if( fw > MAXW )
					fw = fcmprs( fw, ofields[ f ] );
			}
			if( fw > omaxw[ f ] )
				omaxw[ f ] = fw;
		}
		fprintf( tfp1, "%s", ofields[ 0 ] );
		for( f = 0; f < n_sfields; f++ ) 
			fprintf( tfp1, " %s", sfields[ f ] );
		for( f = OFIELD1; f < n_ofields; f++ )
			fprintf( tfp1, " %s", ofields[ f ] );
		fprintf( tfp1, "\n" );
		for( f = 0; f < n_fields; f++ )
			free( fields[ f ] );
	}

	if( !aopt ){
		fclose( tfp1 );

		if( stat( tfnp1, &sbuf ) ){
			fprintf( stderr,
				"%s: can't stat raw temp-file '%s'\n",
				argv[ 0 ], tfnp1 );
			exit( 1 );
		}
		if( sbuf.st_size > smax )
			scored = sort = 0;

/*
		tfnp2 = tempnam( tfdir, "srt" );
*/
		sprintf( tfnp2, "%s/srt_XXXXXX", tfdir );
		tfd2 = mkstemp( tfnp2 );
		if( scored ){
			sprintf( cmd,
			"sort +1rn -2 +0 -1 +2n -3 +3n -4 +4n -5 %s > %s\n",
				tfnp1, tfnp2 );
		}else if( sort ){
			sprintf( cmd,
			"sort +0 -1 +%dn -%d +%dn -%d +%dn -%d %s > %s\n",
				n_sfields+1, n_sfields+2,
				n_sfields+2, n_sfields+3,
				n_sfields+3, n_sfields+4,
				tfnp1, tfnp2 );
		}else
			sprintf( cmd, "cp %s %s\n", tfnp1, tfnp2 );
		system( cmd );

/*
		if( ( tfp2 = fopen( tfnp2, "r" ) ) == NULL ){
			fprintf( stderr,
				"%s: can't open sorted temp-file '%s'\n",
				argv[ 0 ], tfnp2 );
			exit( 1 );
		}
*/
		if( ( tfp2 = fdopen( tfd2, "r" ) ) == NULL ){
			fprintf( stderr,
				"%s: can't open sorted temp-file '%s'\n",
				argv[ 0 ], tfnp2 );
			exit( 1 );
		}

		while( fgets( line, sizeof( line ), tfp2 ) ){
			n_fields = split( line, fields, " \t\n" );
			df1 = n_fields - ( n_ofields - DFIELD1 );
			of1 = df1 - ( DFIELD1 - OFIELD1 );
			n_sfields = df1 - DFIELD1;

			ofields[ 0 ] = fields[ 0 ];
			for( f = of1; f < n_fields; f++ )
				ofields[ f - of1 + 1 ] = fields[ f ];
			for( f = 0; f < n_sfields; f++ )
				sfields[ f ] = fields[ f + 1 ];

			for( f = 0; f < OFIELD1; f++ ){
				fw = strlen( ofields[ f ] );
				if( ofmt[ f ] == FMT_LEFT ){
					if( f != 0 )
						putchar( ' ' );
					printf( "%s", ofields[ f ] );
					for( fs = 0; fs < omaxw[f] - fw; fs++ )
						putchar( ' ' );
				}else{
					printf( " " );
					for( fs = 0; fs < omaxw[f] - fw; fs++ )
						putchar( ' ' );
					printf( "%s", ofields[ f ] );
				}
			}
			printf( " " );
			if( m_sfields == 1 ){
				fw = strlen( sfields[ 0 ] );
/*
				printf( " " );
*/
				for( fs = 0; fs < smaxw - fw; fs++ )
					putchar( ' ' );
				printf( "%s", sfields[ 0 ] );
			}else{
				for( fs = 0, f = 0; f < n_sfields; f++ ){
					fw = strlen( sfields[ f ] );
					if( f != 0 ){
						putchar( ' ' );
						fs++;
					}
					printf( "%s", sfields[ f ] );
					fs += fw;
				}
				for( ; fs < smaxw; fs++ )
					putchar( ' ' );
			}
			for( f = OFIELD1; f < n_ofields; f++ ){
				fw = strlen( ofields[ f ] );
				if( ofmt[ f ] == FMT_LEFT ){
					if( f != 0 )
						putchar( ' ' );
					printf( "%s", ofields[ f ] );
					for( fs = 0; fs < omaxw[f] - fw; fs++ )
						putchar( ' ' );
				}else{
					printf( " " );
					for( fs = 0; fs < omaxw[f] - fw; fs++ )
						putchar( ' ' );
					printf( "%s", ofields[ f ] );
				}
			}
			printf( "\n" );
			for( f = 0; f < n_fields; f++ )
				free( fields[ f ] );
		}
		fclose( tfp2 );
		unlink( tfnp2 );
	}else{
		rewind( tfp1 );
		*dline = *line = '\0';
		while( fgets( line, sizeof( line ), tfp1 ) ){
			if( *line == '>' )
				strcpy( dline, line );
			else{
				align( stdout, lopt, dline, line );
				*dline = *line = '\0';
			}
		}
		align( stdout, lopt, dline, line );
	}

	unlink( tfnp1 );

	if( ifp != stdin )
		fclose( ifp );

	exit( 0 );
}

static	int	getline( char line[], FILE *fp )
{
	int	i, c;
	char	*lp;

	if( *ra_line ){
		strcpy( line, ra_line );
		*ra_line = '\0';
		return( 1 );
	}
	for( lp = line, i = 0; ( c = getc( fp ) ) != EOF; i++ ){
		if( i < LINE_SIZE )
			*lp++ = c;
		if( c == '\n' )
			break;
	}
	*lp = '\0';
	return( lp > line );
}

static	void	ungetline( char line[] )
{

	strcpy( ra_line, line );
}

static	int	*getfmt( int n_fields, int df1, char *fields[], int *n_fmt )
{
	int	f;
	int	*fmt;

	*n_fmt = n_fields - 2 + df1;
	fmt = ( int * )malloc( *n_fmt * sizeof( int ) );
	if( fmt == NULL ){
		fprintf( stderr, "getfmt: can't allocate fmt.\n" );
		return( NULL );
	}
	fmt[ 0 ] = FMT_LEFT;
	for( f = 1; f < df1; f++ )
		fmt[ f ] = FMT_RIGHT;
	for( f = 2; f < n_fields; f++ ){
		if( !strncmp( fields[ f ], "h3", 2 ) ||
				!strncmp( fields[ f ], "t2", 2 ) ||
				!strncmp( fields[ f ], "q2", 2 ) ||
				!strncmp( fields[ f ], "q4", 2 ) )
			fmt[ f - 2 + df1 ] = FMT_RIGHT;
		else
			fmt[ f - 2 + df1 ] = FMT_LEFT;
	}

	return( fmt );
}

static	int	is_a_number( char str[] )
{
	char	*sp;
	int	mcnt, ecnt;
	int	efmt;

	sp = str;
	if( *sp == '-' )
		sp++;
	for( mcnt = efmt = ecnt = 0; isdigit( *sp ); sp++ )
		mcnt++;
	if( *sp == '.' )
		sp++;
	for( ; isdigit( *sp ); sp++ )
		mcnt++;
	if( *sp == 'e' || *sp == 'E' ){
		efmt = 1;
		sp++;
		if( *sp == '-' )
			sp++;
		for( ; isdigit( *sp ); sp++ )
			ecnt++;
	}
	if( mcnt == 0 ) 
		return( 0 );
	if( efmt && ecnt == 0 )
		return( 0 );
	if( *sp != '\0' )
		return( 0 );
	return( 1 );
}

static	int	fcmprs( int flen, char field[] )
{
	char	tmp[ 10000 ];

	if( flen > MAXW ){
		sprintf( tmp, "%.*s...(%d)...%.*s",
			3, field, flen, 3, &field[ flen - 3 ] );
		strcpy( field, tmp );
		return( strlen( field ) );
	}else
		return( flen );
}

static	void	align( FILE *fp, int lopt, char dline[], char line[] )
{
	char	*def;
	char	name[ 256 ], ver[ 10 ];
	static	char	l_name[ 256 ] = "";
	static	int	l_cnt = 1;
	int	f, fs, fw;
	int	df1, of1;
	char	*wp, work[ 50000 ];
	int	w, wb, wlim, wlen;

	if( !*dline || !*align )
		return;

	for( def = &dline[ 1 ]; *def && isspace( *def ); def++ )
		;
	if( *def ){
		def = strchr( def, ' ' );
		if( def ){
			for( ; isspace( *def ); def++ )
				;
		}
	}
	n_fields = split( line, fields, " \t\n" );
	df1 = n_fields - ( n_ofields - DFIELD1 );
	of1 = df1 - ( DFIELD1 - OFIELD1 );
	n_sfields = df1 - DFIELD1;

	ofields[ 0 ] = fields[ 0 ];
	for( f = of1; f < n_fields; f++ )
		ofields[ f - of1 + 1 ] = fields[ f ];
	for( f = 0; f < n_sfields; f++ )
		sfields[ f ] = fields[ f + 1 ];

	if( lopt ){
		sprintf( name, "%s_%s%s",
			ofields[0], ofields[2],
			*ofields[1] == '0' ? "d" : "c" );
	}else{
		sprintf( name, "%s_%s_%s_%s",
			ofields[0], ofields[1], ofields[2], ofields[3] );
	}
	if( !strcmp( l_name, name ) ){
		l_cnt++;
		sprintf( ver, "%s%d", !lopt ? "_" : "", l_cnt );
	}else{
		l_cnt = 1;
		*ver = '\0';
	}
	fprintf( fp, ">%s%s %s", name, ver, sfields[ 0 ] );
	for( f = 1; f < n_sfields; f++ )
		fprintf( fp, " %s", sfields[ f ] );
	fprintf( fp, " %s", def );
	strcpy( l_name, name );

	for( wp = work, f = DFIELD1; f < n_ofields; f++ ){
		if( f != DFIELD1 )
			*wp++ = '|';
		fw = strlen( ofields[ f ] );
		if( ofmt[ f ] == FMT_LEFT ){
			sprintf( wp, "%s", ofields[ f ] );
			wp += strlen( wp );
			for( fs = 0; fs < omaxw[ f ] - fw; fs++ )
				*wp++ = '-';
		}else{
			for( fs = 0; fs < omaxw[ f ] - fw; fs++ )
				*wp++ = '-';
			sprintf( wp, "%s", ofields[ f ] );
			wp += strlen( wp );
		}
	}
	*wp = '\0';
	wlen = wp - work;
	for( wp = work, wb = 0; wb < wlen; wb += WBSIZE ){
		wlim = MIN( wb + WBSIZE, wlen );
		for( w = wb; w < wlim; w++ )
			putc( *wp++, fp );
		putc( '\n', fp );
	}

	for( f = 0; f < n_fields; f++ )
		free( fields[ f ] );
}
@


1.10
log
@renamed isnumber() to is_a_number() as isnumber() is a new bulitin
'wide' character function.
@
text
@d46 1
d48 3
d101 2
d104 1
d111 8
d254 1
d256 3
d274 1
d276 7
@


1.9
log
@fixed bug that failed to insert a space if the score consisted on >1
columns
@
text
@d38 1
a38 1
static	int	isnumber( char [] );
d170 1
a170 1
			scored = isnumber( sfields[ 0 ] );
d407 1
a407 1
static	int	isnumber( char str[] )
@


1.8
log
@forgot to initialize smax to SMAX
@
text
@d289 1
d292 1
d294 1
@


1.7
log
@added code to allow user to set the temp dir, and to set the
upper bound on sorting.
@
text
@d58 1
@


1.6
log
@fixed logic that resulted in 0-length name when the fastn id field
ended with '|'.
@
text
@d4 2
d7 2
a8 1
#define	U_MSG_S	"usage: %s [ -a ] [ -l ] [ rm-output-file ]\n"
d13 1
d44 1
a44 1
	char	*ifname;
d51 2
d55 1
d61 1
a61 1
		else if( !strcmp( argv[ ac ], "-l" ) ){
d63 17
d97 1
a97 1
	tfnp1 = tempnam( NULL, "raw" );
d229 10
a238 1
		tfnp2 = tempnam( NULL, "srt" );
@


1.5
log
@Ooops. Backwards logic on sort/scored.
@
text
@d44 1
a44 1
	char	*sp, *vbp;
d148 3
a150 2
			for( vbp = NULL, sp = ofields[ 0 ]; *sp; sp++ ){
				if( *sp == '|' )
d152 1
d154 14
a167 2
			if( vbp != NULL )
				strcpy( ofields[ 0 ], &vbp[ 1 ] );
@


1.4
log
@looks like it's all there.  Time to test.
@
text
@d144 2
a145 2
		if( sort )
			sort = isnumber( sfields[ 0 ] );
@


1.3
log
@working save for adding score fields to -l output.  All info has been
acquired, but not figured out what to do with.  Will sleep on.
@
text
@d16 1
a16 2
static	int	*sfmt;
static	int	*smaxw;
a113 8
	smaxw = ( int * )malloc( ( n_ofields ) * sizeof( int ) );
	if( smaxw == NULL ){
		fprintf( stderr, "%s: can't allocate smaxw.\n",
			argv[ 0 ] );
		exit( 1 );
	}
	for( f = 0; f < n_ofields; f++ )
		smaxw[ f ] = 0;
a114 1

d116 2
a131 2
		else if( sort )
			sort = isnumber( sfields[ 0 ] );
d135 1
a135 1
		else if( n_sfields != n_sfields )
d144 3
d158 2
a159 4
		for( f = 0; f < n_sfields; f++ ){
			fw = strlen( sfields[ f ] );
			if( fw > smaxw[ f ] )
				smaxw[ f ] = fw;
d161 3
d226 1
a226 1
			for( f = 0; f < of1; f++ ){
d241 20
a260 1
			for( f = of1; f < n_ofields; f++ ){
d343 1
a343 1
	for( f = df1; f < n_fields; f++ ){
d348 1
a348 1
			fmt[ f ] = FMT_RIGHT;
d350 1
a350 1
			fmt[ f ] = FMT_LEFT;
d352 1
@


1.2
log
@getting there.  Stuff is being saved.  Score fields are extracted.
New logic required to decide if sort required.  New sort command required
as #RM scored is always true.  Maybe tonight?
@
text
@d21 1
a21 1
static	int	n_fields, n_ofields, n_sfields, m_sfields;
d35 1
d47 1
a47 1
	int	aopt, lopt, scored;
d125 1
a125 1
	while( getline( line, ifp ) ){
d138 10
a193 1
/*
d202 1
a202 1
		}else{
d204 4
a207 1
				"sort +0 -1 +1n -2 +2n -3 +3n -4 %s > %s\n",
d209 2
a210 1
		}
d222 28
a249 3
			for( f = 0; f < t_fields; f++ ){
				fw = strlen( fields[ f ] );
				if( fmt[ f ] == FMT_LEFT ){
d252 2
a253 2
					printf( "%s", fields[ f ] );
					for( fs = 0; fs < maxw[ f ] - fw; fs++ )
d257 1
a257 1
					for( fs = 0; fs < maxw[ f ] - fw; fs++ )
d259 1
a259 1
					printf( "%s", fields[ f ] );
a280 1
*/
d342 32
a385 1
/*
d394 1
d411 10
d423 2
a424 1
			fields[0], fields[3], *fields[2] == '0' ? "d" : "c" );
d427 1
a427 1
			fields[ 0 ], fields[ 2 ], fields[ 3 ], fields[ 4 ] );
d436 4
a439 1
	fprintf( fp, ">%s%s %s %s", name, ver, fields[ 1 ], def );
d442 2
a443 2
	for( wp = work, f = field1; f < t_fields; f++ ){
		if( f != field1 )
d445 3
a447 3
		fw = strlen( fields[ f ] );
		if( fmt[ f ] == FMT_LEFT ){
			sprintf( wp, "%s", fields[ f ] );
d449 1
a449 1
			for( fs = 0; fs < maxw[ f ] - fw; fs++ )
d452 1
a452 1
			for( fs = 0; fs < maxw[ f ] - fw; fs++ )
d454 1
a454 1
			sprintf( wp, "%s", fields[ f ] );
a469 1
*/
@


1.1
log
@Initial revision
@
text
@d7 2
a8 1
#define	MAX(a,b)	((a)<(b)?(a):(b))
d11 2
a12 1
#define	FIELD1		4
d15 7
a21 1
static	int	n_fields, t_fields, field1;
d23 5
a29 2
static	int	*maxw;

d32 3
a34 2
static	int	*fmt;
static	int	*getfmt( int, int, char *[] );
a43 3
#define	LINE_SIZE	50000
	char	line[ LINE_SIZE ];
	char	dline[ LINE_SIZE ];
d45 1
a45 1
	int	ac, f, fw, fs;
d80 1
a80 3
	scored = 0;	/* #RM scored line seen */
	field1 = FIELD1;
	for( t_fields = 0; fgets( line, sizeof( line ), ifp ); ){
d82 2
a83 3
			if( aopt )
				fputs( line, tfp1 );
			continue;
d92 3
a94 2
				fmt = getfmt( n_fields, field1, fields );
				if( fmt == NULL )
a95 3
			}else if( !strcmp( fields[ 1 ], "scored" ) ){
				field1++;
				scored = 1;
d100 28
a127 1
		}else if( *fields[ 0 ] == '#' )
a128 10
		if( t_fields == 0 ){
			t_fields = n_fields;
			maxw = ( int * )malloc( ( t_fields ) * sizeof( int ) );
			if( maxw == NULL ){
				fprintf( stderr, "%s: can't allocate maxw.\n",
					argv[ 0 ] );
				exit( 1 );
			}
			for( f = 0; f < t_fields; f++ )
				maxw[ f ] = 0;
d130 13
d144 1
a144 1
			for( vbp = NULL, sp = fields[ 0 ]; *sp; sp++ ){
d149 1
a149 1
				strcpy( fields[ 0 ], &vbp[ 1 ] );
d151 12
a162 7
		fw = strlen( fields[ 0 ] );
		if( fw > maxw[ 0 ] )
			maxw[ 0 ] = fw;
		for( f = 1; f < field1; f++ ){
			fw = strlen( fields[ f ] );
			if( fw > maxw[ f ] )
				maxw[ f ] = fw;
d164 2
a165 2
		for( f = field1; f < t_fields; f++ ){
			fw = strlen( fields[ f ] );
d168 1
a168 1
					fw = fcmprs( fw, fields[ f ] );
d170 2
a171 2
			if( fw > maxw[ f ] )
				maxw[ f ] = fw;
d173 5
a177 3
		fprintf( tfp1, "%s", fields[ 0 ] );
		for( f = 1; f < n_fields; f++ )
			fprintf( tfp1, " %s", fields[ f ] );
d183 1
d242 1
d252 27
a278 1
static	int	*getfmt( int n_fields, int field1, char *fields[] )
d283 2
a284 1
	fmt = ( int * )malloc( ( n_fields - 2 + field1 ) * sizeof( int ) );
d290 1
a290 1
	for( f = 1; f < field1; f++ )
d292 1
a292 1
	for( f = 2; f < n_fields; f++ ){
d297 1
a297 1
			fmt[ f - 2 + field1 ] = FMT_RIGHT;
d299 1
a299 1
			fmt[ f - 2 + field1 ] = FMT_LEFT;
d316 1
d377 1
a377 1
		wlim = MAX( wb + WBSIZE, wlen );
d386 1
@
