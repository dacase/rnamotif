head	1.67;
access;
symbols;
locks; strict;
comment	@ * @;


1.67
date	2002.05.23.02.15.40;	author macke;	state Exp;
branches;
next	1.66;

1.66
date	2002.05.11.17.47.18;	author macke;	state Exp;
branches;
next	1.65;

1.65
date	2001.11.14.17.33.13;	author macke;	state Exp;
branches;
next	1.64;

1.64
date	2001.08.24.17.18.03;	author macke;	state Exp;
branches;
next	1.63;

1.63
date	2001.07.30.19.56.22;	author macke;	state Exp;
branches;
next	1.62;

1.62
date	2001.05.31.21.01.49;	author macke;	state Exp;
branches;
next	1.61;

1.61
date	2001.02.07.19.30.55;	author macke;	state Exp;
branches;
next	1.60;

1.60
date	2001.02.06.05.45.54;	author macke;	state Exp;
branches;
next	1.59;

1.59
date	2001.01.18.23.56.16;	author macke;	state Exp;
branches;
next	1.58;

1.58
date	2000.12.15.22.42.43;	author macke;	state Exp;
branches;
next	1.57;

1.57
date	2000.12.14.05.29.30;	author macke;	state Exp;
branches;
next	1.56;

1.56
date	2000.12.11.23.21.08;	author macke;	state Exp;
branches;
next	1.55;

1.55
date	2000.12.09.22.03.19;	author macke;	state Exp;
branches;
next	1.54;

1.54
date	2000.12.07.19.18.07;	author macke;	state Exp;
branches;
next	1.53;

1.53
date	2000.12.05.18.44.44;	author macke;	state Exp;
branches;
next	1.52;

1.52
date	2000.12.04.19.12.32;	author macke;	state Exp;
branches;
next	1.51;

1.51
date	2000.11.15.05.18.50;	author macke;	state Exp;
branches;
next	1.50;

1.50
date	2000.10.07.06.09.38;	author macke;	state Exp;
branches;
next	1.49;

1.49
date	2000.09.11.04.05.37;	author macke;	state Exp;
branches;
next	1.48;

1.48
date	2000.03.03.18.25.02;	author macke;	state Exp;
branches;
next	1.47;

1.47
date	2000.02.10.00.14.23;	author macke;	state Exp;
branches;
next	1.46;

1.46
date	2000.02.06.00.48.49;	author macke;	state Exp;
branches;
next	1.45;

1.45
date	99.10.03.19.03.57;	author macke;	state Exp;
branches;
next	1.44;

1.44
date	99.10.03.18.18.08;	author macke;	state Exp;
branches;
next	1.43;

1.43
date	99.09.16.22.51.14;	author macke;	state Exp;
branches;
next	1.42;

1.42
date	99.09.16.21.23.11;	author macke;	state Exp;
branches;
next	1.41;

1.41
date	99.09.15.18.33.22;	author macke;	state Exp;
branches;
next	1.40;

1.40
date	99.09.15.03.33.58;	author macke;	state Exp;
branches;
next	1.39;

1.39
date	99.09.14.16.51.25;	author macke;	state Exp;
branches;
next	1.38;

1.38
date	99.09.10.17.12.40;	author macke;	state Exp;
branches;
next	1.37;

1.37
date	99.08.27.19.14.42;	author macke;	state Exp;
branches;
next	1.36;

1.36
date	99.07.14.22.44.27;	author macke;	state Exp;
branches;
next	1.35;

1.35
date	99.06.22.17.12.20;	author macke;	state Exp;
branches;
next	1.34;

1.34
date	99.06.22.16.34.44;	author macke;	state Exp;
branches;
next	1.33;

1.33
date	99.06.22.01.01.19;	author macke;	state Exp;
branches;
next	1.32;

1.32
date	99.06.20.02.13.59;	author macke;	state Exp;
branches;
next	1.31;

1.31
date	99.05.28.01.21.13;	author macke;	state Exp;
branches;
next	1.30;

1.30
date	99.05.28.01.18.28;	author macke;	state Exp;
branches;
next	1.29;

1.29
date	99.05.24.20.02.28;	author macke;	state Exp;
branches;
next	1.28;

1.28
date	99.05.12.20.33.38;	author macke;	state Exp;
branches;
next	1.27;

1.27
date	99.05.04.15.41.31;	author macke;	state Exp;
branches;
next	1.26;

1.26
date	99.05.04.03.17.46;	author macke;	state Exp;
branches;
next	1.25;

1.25
date	99.04.29.12.13.08;	author macke;	state Exp;
branches;
next	1.24;

1.24
date	99.04.29.03.40.05;	author macke;	state Exp;
branches;
next	1.23;

1.23
date	99.04.28.02.21.47;	author macke;	state Exp;
branches;
next	1.22;

1.22
date	99.04.19.02.02.40;	author macke;	state Exp;
branches;
next	1.21;

1.21
date	99.04.19.01.35.05;	author macke;	state Exp;
branches;
next	1.20;

1.20
date	99.04.12.04.25.34;	author macke;	state Exp;
branches;
next	1.19;

1.19
date	99.04.05.01.05.30;	author macke;	state Exp;
branches;
next	1.18;

1.18
date	99.03.27.02.31.09;	author macke;	state Exp;
branches;
next	1.17;

1.17
date	99.02.22.23.25.23;	author macke;	state Exp;
branches;
next	1.16;

1.16
date	99.02.21.01.46.38;	author macke;	state Exp;
branches;
next	1.15;

1.15
date	99.02.03.20.22.07;	author macke;	state Exp;
branches;
next	1.14;

1.14
date	99.02.03.05.45.54;	author macke;	state Exp;
branches;
next	1.13;

1.13
date	99.01.29.20.48.32;	author macke;	state Exp;
branches;
next	1.12;

1.12
date	99.01.08.20.38.32;	author macke;	state Exp;
branches;
next	1.11;

1.11
date	98.12.30.22.57.31;	author macke;	state Exp;
branches;
next	1.10;

1.10
date	98.12.29.22.55.41;	author macke;	state Exp;
branches;
next	1.9;

1.9
date	98.12.27.14.48.03;	author macke;	state Exp;
branches;
next	1.8;

1.8
date	98.12.27.11.13.10;	author macke;	state Exp;
branches;
next	1.7;

1.7
date	98.12.23.19.43.00;	author macke;	state Exp;
branches;
next	1.6;

1.6
date	98.12.23.04.35.50;	author macke;	state Exp;
branches;
next	1.5;

1.5
date	98.12.23.03.30.10;	author macke;	state Exp;
branches;
next	1.4;

1.4
date	98.12.19.03.31.36;	author macke;	state Exp;
branches;
next	1.3;

1.3
date	98.12.14.04.32.05;	author macke;	state Exp;
branches;
next	1.2;

1.2
date	98.12.13.02.40.05;	author macke;	state Exp;
branches;
next	1.1;

1.1
date	98.12.11.05.10.49;	author macke;	state Exp;
branches;
next	;


desc
@main program for rnamot
@


1.67
log
@add include of rmdefs.h which now contains the defs for the file types.
@
text
@#include <stdio.h>

#include "rmdefs.h"
#include "rnamot.h"

extern	FILE	*yyin;

extern	int	rm_error;
extern	char	*rm_dfname;
extern	char	*rm_xdfname;
extern	int	rm_preprocess;
extern	int	rm_unlink_xdf;
extern	int	rm_copt;
extern	int	rm_dopt;
extern	int	rm_hopt;
extern	int	rm_popt;
extern	int	rm_sopt;
extern	int	rm_vopt;
extern	int	rm_dbfmt;
extern	FILE	*rm_dbfp;
extern	char	**rm_dbfname;
extern	int	rm_n_dbfname;
extern	int	rm_c_dbfname;

extern	STREL_T	rm_descr[];
extern	int	rm_n_descr;
extern	int	rm_dminlen;	/* min. len. of entire motif	*/
extern	int	rm_dmaxlen;	/* max. len. of entire motif	*/

extern	SITE_T	*rm_sites;

extern	SEARCH_T	**rm_searches;
extern	int		rm_n_searches;

#define	SID_SIZE	100
static	char	sid[ SID_SIZE ];
#define	SDEF_SIZE	20000
static	char	sdef[ SDEF_SIZE ];
#define	SBUF_SIZE	30000000
static	char	sbuf[ SBUF_SIZE ];
static	int	slen;
static	char	csbuf[ SBUF_SIZE ];

IDENT_T	*RM_find_id();

char	*RM_preprocessor( void );
FILE	*DB_fnext( FILE *, int *, int, char *[] );
int	FN_fgetseq( FILE *, char *, int, char *, int, char * );
int	PIR_fgetseq( FILE *, char *, int, char *, int, char * );
int	GB_fgetseq( FILE *, char *, int, char *, int, char * );

static	void	mk_rcmp( int, char [], char [] );

main( int argc, char *argv[] )
{
	IDENT_T	*ip;
	int	done = 0;
	int	chk_both_strs;
	int	show_progress;
	int	ecnt;
	int	( *fgetseq )( FILE *, char *, int, char *, int, char * );

	if( RM_init( argc, argv ) )
		exit( 1 );

	if( rm_vopt ){
		fprintf( stderr, "%s: %s.\n", argv[ 0 ], VERSION );
		done = 1;
	}
	if( rm_sopt ){
		RM_dump( stderr, 2, 0, 0, 0 );
		done = 1;
	}
	if( done )
		exit( 0 );

	if( rm_preprocess ){
		if( ( rm_xdfname = RM_preprocessor() ) == NULL )
			exit( 1 );
	}

	if( ( yyin = fopen( rm_xdfname, "r" ) ) == NULL ){
		fprintf( stderr, "%s: can't read xd-file %s.\n",
			argv[ 0 ], rm_xdfname );
		exit( 1 );
	}

	if( yyparse() ){
		RM_errormsg( 0, "syntax error." );
	}

	if( rm_unlink_xdf )
		unlink( rm_xdfname );

	if( !rm_error ){
		if( SE_link( rm_n_descr, rm_descr ) )
			exit( 1 );
		RM_linkscore();
		if( rm_dfname != NULL ){
			fprintf( stderr,
				"%s: complete descr length: min/max = %d/",
				rm_dfname, rm_dminlen );
			if( rm_dmaxlen == UNBOUNDED )
				fprintf( stderr, "UNBND\n" );
			else
				fprintf( stderr, "%d\n", rm_dmaxlen );
		}
	}

	if( rm_dopt || rm_hopt )
		RM_dump( stderr, rm_dopt, rm_dopt, rm_dopt, rm_hopt );

	if( rm_dopt || rm_popt )
		RM_dumpscore( stderr );

	if( rm_error )
		exit( 1 );

	if( rm_copt )
		exit( 0 );

	ip = RM_find_id( "chk_both_strs" );
	if( ip == NULL )
		chk_both_strs = 1;
	else
		chk_both_strs = ip->i_val.v_value.v_ival;

	ip = RM_find_id( "show_progress" );
	if( ip == NULL )
		show_progress = 0;
	else
		show_progress = ip->i_val.v_value.v_ival;

	if( rm_dbfmt == DT_FASTN )
		fgetseq = FN_fgetseq;
	else if( rm_dbfmt == DT_PIR )
		fgetseq = PIR_fgetseq;
	else if( rm_dbfmt == DT_GENBANK )
		fgetseq = GB_fgetseq;
	else{
		fprintf( stderr, "%s: unknown data format %d.\n",
			argv[ 0 ], rm_dbfmt );
		exit( 1 );
	}
	rm_dbfp = DB_fnext( rm_dbfp, &rm_c_dbfname, rm_n_dbfname, rm_dbfname );
	if( rm_dbfp == NULL )
		exit( 1 );

	for( ecnt = 0; ; ){
		slen = fgetseq( rm_dbfp, sid,
			SDEF_SIZE, sdef, SBUF_SIZE, sbuf );
		if( slen == EOF ){
			rm_dbfp = DB_fnext( rm_dbfp,
				&rm_c_dbfname, rm_n_dbfname, rm_dbfname );
			if( rm_dbfp == NULL )
				break;
		}

		ecnt++;

		if( show_progress ){
			if( ecnt % show_progress == 0 )
				fprintf( stderr, "%s: %7d: %s\n",
					argv[ 0 ], ecnt, sid );
		}

		find_motif_driver( rm_n_searches, rm_searches, rm_sites,
			sid, sdef, 0, slen, sbuf );
		if( chk_both_strs ){
			mk_rcmp( slen, sbuf, csbuf );
			find_motif_driver( rm_n_searches, rm_searches, rm_sites,
				sid, sdef, 1, slen, csbuf );
		}
	}

	exit( 0 );
}

static	void	mk_rcmp( int slen, char sbuf[], char csbuf[] )
{
	static	int	init = 0;
	static	char	wc_cmp[ 128 ];
	char	*sp, *cp;
	int	i;

	if( !init ){
		init = 1;
		for( i = 0; i < 128; i++ )
			wc_cmp[ i ] = 'n';
		wc_cmp[ 'a' ] = 't'; wc_cmp[ 'A' ] = 't';
		wc_cmp[ 'c' ] = 'g'; wc_cmp[ 'C' ] = 'g';
		wc_cmp[ 'g' ] = 'c'; wc_cmp[ 'G' ] = 'c';
		wc_cmp[ 't' ] = 'a'; wc_cmp[ 'T' ] = 'a';
		wc_cmp[ 'u' ] = 'a'; wc_cmp[ 'U' ] = 'a';
	}

	csbuf[ slen ] = '\0';
	for( sp = sbuf, cp = &csbuf[ slen - 1 ], i = 0; i < slen; i++ )
		*cp-- = wc_cmp[ *sp++ ];
}
@


1.66
log
@added ability to read GB flat files.
@
text
@d3 1
@


1.65
log
@removed commented out code that handled the old FN_file handlers.
@
text
@d49 1
d137 2
@


1.64
log
@modified to use the new var rm_dbfmt to decide which fgetseq() to
use.  Change the name of FN_fnext() to DB_fnext()
@
text
@a45 3
/*
FILE	*FN_fnext( FILE *, int *, int, char *[] );
*/
a140 3
/*
	rm_dbfp = FN_fnext( rm_dbfp, &rm_c_dbfname, rm_n_dbfname, rm_dbfname );
*/
a145 4
/*
		slen = FN_fgetseq( rm_dbfp, sid,
			SDEF_SIZE, sdef, SBUF_SIZE, sbuf );
*/
a148 4
/*
			rm_dbfp = FN_fnext( rm_dbfp,
				&rm_c_dbfname, rm_n_dbfname, rm_dbfname );
*/
@


1.63
log
@bumped size of sbuf to 30,000,000 so as to deal with
largest HS chromo file.
@
text
@d18 1
d46 1
d48 4
d62 1
d135 10
d146 2
d152 1
d155 3
d159 1
d161 3
@


1.62
log
@Updated to deal with FN_fgetseq() now returning 0 for a 0-length
sequence and EOF for true end of file.
@
text
@d37 1
a37 1
#define	SBUF_SIZE	5000000
@


1.61
log
@removed dtype, as it is always fastn, added code to deal with >1
db files.
@
text
@d135 1
a135 1
		if( slen == 0 ){
@


1.60
log
@added code to print the heartbeat mes for ecnt % show_progress == 0.
@
text
@d19 3
a21 1
extern	int	rm_dtype;
a43 5
#ifdef	USE_GENBANK
typedef	void	DBASE_T;
DBASE_T	*dbp, *GB_opendb();
#endif

d45 1
d128 3
a130 6
#ifdef	USE_GENBANK
	if( rm_dtype == DT_GENBANK ){
		if( ( dbp = GB_opendb( rm_dbfp ) ) == NULL )
			exit( 1 );
	}
#endif
d133 8
a140 9
		if( rm_dtype == DT_FASTN )
			slen = FN_fgetseq( rm_dbfp, sid,
				SDEF_SIZE, sdef, SBUF_SIZE, sbuf );
#ifdef	USE_GENBANK
		else
			slen = GB_fgetseq( dbp, sid, SBUF_SIZE, sbuf );
#endif
		if( slen == 0 )
			break;
d151 1
a151 1
			sid, rm_dtype, sdef, 0, slen, sbuf );
d155 1
a155 1
				sid, rm_dtype, sdef, 1, slen, csbuf );
@


1.59
log
@added test to call RM_preprocessor() only rm_preprocess == 1.  Also only
unlink() the preprocessor output file it was not created via tempnam().
@
text
@d57 1
d137 1
a137 1
	for( ; ; ){
d148 7
a154 2
		if( show_progress )
			fprintf( stderr, "%s\n", sid );
@


1.58
log
@added call to unlink() to delete the expanded descr file, rm_xdfname.
@
text
@d10 2
d47 1
a47 1
char	*RM_preprocess( void );
d72 4
a75 2
	if( ( rm_xdfname = RM_preprocess() ) == NULL )
		exit( 1 );
d87 2
a88 1
	unlink( rm_xdfname );
a92 2
		fprintf( stderr, "%s: complete descr length: min/max = %d/",
			rm_dfname, rm_dminlen );
d94 9
a102 4
		if( rm_dmaxlen == UNBOUNDED )
			fprintf( stderr, "UNBND\n" );
		else
			fprintf( stderr, "%d\n", rm_dmaxlen );
@


1.57
log
@removed unlink() of cldfname and ipfname as these files are no
longer used.  Called RM_preprocess() to perform includes. This
is followed by setting yyin to this file then calling yyparse().
@
text
@d83 2
@


1.56
log
@made rm_ipfname visible so as to delete it after compilation.
Also use normal quit on syntax error.
@
text
@d5 2
d9 1
a9 2
extern	char	*rm_cldfname;
extern	char	*rm_ipfname;
d45 2
d70 9
a81 4
	if( rm_cldfname != NULL )
		unlink( rm_cldfname );
	if( rm_ipfname != NULL )
		unlink( rm_ipfname );
@


1.55
log
@removed error message about no descriptor as the grammar prevents it.
Added code to unlink() cmd line defs file.
@
text
@d8 1
d68 1
a68 1
		RM_errormsg( 1, "syntax error." );
d72 3
@


1.54
log
@removed code that made call RM_evalcldefs() as this is now done
properly inline.
@
text
@d69 2
a70 3
	if( rm_n_descr == 0 ){
		RM_errormsg( 1, "no descriptor." );
	}
@


1.53
log
@removed fclose( yyin ) as it is now done in yywrap() when included
files are unstacked.
@
text
@a71 4
	if( rm_cldfname != NULL ){
		if( RM_evalcldefs() )
			exit( 1 );
	}
@


1.52
log
@change rm_dfname to be pointer vs address of actual space.
@
text
@a4 2
extern	FILE	*yyin;

a68 1
	fclose( yyin );
@


1.51
log
@modified to parse -D (cmd line defs) after parsing the descriptor.
@
text
@d8 1
a8 1
extern	char	rm_dfname[];
@


1.50
log
@convert headers from K&R to ANSI
@
text
@d5 2
d9 1
d70 8
@


1.49
log
@new option rm_sopt (-s) which prints out the symbol table in
short form.  Used to get the name of the global parameters.
@
text
@d42 1
a42 1
static	void	mk_rcmp();
d44 1
a44 3
main( argc, argv )
int	argc;
char	*argv[];
d137 1
a137 4
static	void	mk_rcmp( slen, sbuf, csbuf )
int	slen;
char	sbuf[];
char	csbuf[];
@


1.48
log
@removed unused var dbnp.
@
text
@d11 1
d49 1
d58 7
a65 1
	}
@


1.47
log
@added variable show_progress so as to be able to monitor the
search
@
text
@a47 1
	char	*dbnp;
@


1.46
log
@increased size of sdef to 20000, send SDEF_SIZE to FN_fgetseq().
@
text
@d50 1
d88 1
a88 1
	if( ip == NULL ){
d90 1
a90 1
	}else
d93 6
d116 3
@


1.45
log
@changed refs to errormsg() to RM_errormsg()
@
text
@d27 1
a27 1
#define	SDEF_SIZE	10000
d101 2
a102 1
			slen = FN_fgetseq( rm_dbfp, sid, sdef, SBUF_SIZE, sbuf );
@


1.44
log
@changed names of SC_link() and SC_dump() to RM_linkscore() and
RM_dumpscore()
@
text
@d60 1
a60 1
		errormsg( 1, "syntax error." );
@


1.43
log
@changed name of find_id() to RM_find_id().
@
text
@d67 1
a67 1
		SC_link();
d78 1
a78 1
		SC_dump( stderr );
@


1.42
log
@changed SC_lgo() back to SC_link() because execution in only done if
the pattern is found.
@
text
@d34 1
a34 1
IDENT_T	*find_id();
d86 1
a86 1
	ip = find_id( "chk_both_strs" );
@


1.41
log
@changed name of SC_link() to SC_lgo().
@
text
@d67 1
a67 1
		SC_lgo();
@


1.40
log
@add call to SC_link() to resolve labels after all score actions ahve
been compiled.
@
text
@d67 1
a67 1
		SC_link();
@


1.39
log
@added code to dump the program if -p is set.
@
text
@d67 1
@


1.38
log
@no change. removed trailing blank after if( rm_dtype == DT_FAST )
that I discovered after adding & removing debug output.
@
text
@d10 1
d75 3
@


1.37
log
@changed RM_init() to set rm_vopt, so -v terminates normally.
removed unused. dbp from id line.
added code to get and use the `def' line from fastn and pass it
to find_motif()
@
text
@d95 1
a95 1
		if( rm_dtype == DT_FASTN ) 
@


1.36
log
@increase size of sbuf from 2m to 5m
@
text
@d10 1
d24 4
a47 1
	char	locus[ 20 ];
d53 5
a80 27
/*
	ip = find_id( "database" );
	if( ip == NULL ){
		fprintf( stderr, "rnamot: 'database' not defined.\n" );
		exit( 1 );
	}else
		dbnp = ip->i_val.v_value.v_pval;

	for( dbp = DB_open( dbnp ); dbp; ){
		if( slen = DB_getseq( dbp, locus, SBUF_SIZE, sbuf ) ){
			find_motif_driver( rm_n_searches, rm_searches, rm_sites,
				locus, 0, slen, sbuf );
			mk_rcmp( slen, sbuf, csbuf );
			find_motif_driver( rm_n_searches, rm_searches, rm_sites,
				locus, 1, slen, csbuf );
		}
		dbp = DB_next( dbp );
	}

	while( slen = DB_getseq( stdin, locus, SBUF_SIZE, sbuf ) ){
		find_motif_driver( rm_n_searches, rm_searches, rm_sites,
			locus, 0, slen, sbuf );
		mk_rcmp( slen, sbuf, csbuf );
		find_motif_driver( rm_n_searches, rm_searches, rm_sites,
			locus, 1, slen, csbuf );
	}
*/
d96 1
a96 1
			slen = FN_fgetseq( rm_dbfp, locus, SBUF_SIZE, sbuf );
d99 1
a99 1
			slen = GB_fgetseq( dbp, locus, SBUF_SIZE, sbuf );
d105 1
a105 1
			locus, 0, slen, sbuf );
d109 1
a109 1
				locus, 1, slen, csbuf );
@


1.35
log
@removed local decl of DBASE_T which is no longer needed and in fact
wont work unless USE_GENBANK is defined.
@
text
@d23 1
a23 1
#define	SBUF_SIZE	2000000
@


1.34
log
@added if() to check that datatype is DT_GENBANK before trying to open
a genbank/nanogen hits file.
@
text
@a40 1
	DBASE_T	*dbp;
@


1.33
log
@read from FASTN (def) or Genbank Hits.
@
text
@d107 4
a110 2
	if( ( dbp = GB_opendb( rm_dbfp ) ) == NULL )
		exit( 1 );
@


1.32
log
@about to redo the whole database thing, but need to think a bit more
about it.
@
text
@a4 2
#include "dbase.h"

d30 5
d45 1
d73 1
d91 1
a91 1
/*
d100 29
a130 6
}

static	void	init_rcmp()
{
	int	i;

@


1.31
log
@changed name of SBUFSIZE to SBUF_SIZE to be consistant with current
use of underscores.
@
text
@d8 1
a8 1
extern	char	rm_fname[];
d12 2
d28 1
d32 2
d43 2
a44 1
	RM_init( argc, argv );
d53 1
a53 1
			rm_fname, rm_dminlen );
d79 4
a82 1
				locus, slen, sbuf );
d86 9
d97 32
@


1.30
log
@moved all global variables from here to compile.c. This will make it
easier to embed the rnamot algorithm in other programs.
@
text
@d23 2
a24 2
#define	SBUFSIZE	2000000
static	char	sbuf[ SBUFSIZE ];
d71 1
a71 1
		if( slen = DB_getseq( dbp, locus, SBUFSIZE, sbuf ) ){
@


1.29
log
@moved DBASE_T typedef from rnamot.h to dbase.h in order to
further encapsulate a very system dependent feature.
@
text
@d7 10
a16 8
int	rm_error;
VALUE_T	rm_tokval;
int	rm_lineno;
int	rm_emsg_lineno;
char	rm_fname[ 256 ] = "--stdin--";
int	rm_copt = 0;
int	rm_dopt = 0;
int	rm_hopt = 0;	/* dump hierarchy	*/
d18 1
a18 14
#define	RM_GLOBAL_IDS_SIZE	50
IDENT_T	rm_global_ids[ RM_GLOBAL_IDS_SIZE ] = {
	{ "wc", T_PAIR, C_VAR, S_GLOBAL, { T_PAIR, NULL } },
	{ "gu", T_PAIR, C_VAR, S_GLOBAL, { T_PAIR, NULL } },
	{ "tr", T_PAIR, C_VAR, S_GLOBAL, { T_PAIR, NULL } },
	{ "qu", T_PAIR, C_VAR, S_GLOBAL, { T_PAIR, NULL } },
 /*5*/	{ "database", T_STRING, C_VAR, S_GLOBAL, { T_STRING, "RNA" } },
	{ "overlap", T_INT, C_VAR, S_GLOBAL, { T_INT, 0 } },
	{ "wc_minlen", T_INT, C_VAR, S_GLOBAL, { T_INT, 3 } },
	{ "wc_maxlen", T_INT, C_VAR, S_GLOBAL, { T_INT, 30 } },
 /*9*/	{ "windowsize", T_INT, C_VAR, S_GLOBAL, { T_INT, 6000 } }
};
int	rm_s_global_ids = RM_GLOBAL_IDS_SIZE;
int	rm_n_global_ids = 9;
d20 2
a21 25
#define	RM_DESCR_SIZE 100
STREL_T	rm_descr[ RM_DESCR_SIZE ];
int	rm_s_descr = RM_DESCR_SIZE;
int	rm_n_descr;
int	rm_dminlen;	/* min. len. of entire motif	*/
int	rm_dmaxlen;	/* max. len. of entire motif	*/

#define	RM_POS_SIZE	10
POS_T	rm_pos[ RM_POS_SIZE ];
int	rm_s_pos = RM_POS_SIZE;
int	rm_n_pos;

SITE_T	*rm_sites = NULL;

#define	RM_S_B2C	256	
int	rm_b2bc[ RM_S_B2C ];
int	rm_s_b2bc = RM_S_B2C;
char	rm_bc2b[ N_BCODES ] = { 'a', 'c', 'g', 't', 'n' };

SEARCH_T	**rm_searches;
int		rm_n_searches;

extern	int	yydebug;

char	*getenv();
@


1.28
log
@changed default database from VRT to RNA.
@
text
@d5 2
a61 3

DBASE_T	*DB_open();
DBASE_T *DB_next();
@


1.27
log
@added new var rm_bc2b[] which gives the bases associated with the
base codes; is inverse of rm_b2bc[].
@
text
@d20 1
a20 1
 /*5*/	{ "database", T_STRING, C_VAR, S_GLOBAL, { T_STRING, "VRT" } },
@


1.26
log
@added new array rm_b2bc[] which maps characters from the sequence into
basecodes: a=0, c=1, etc which in turn are used to index into a bmat
of the correct dimension which contains 1 for legal base-aggr and 0 for
unacceptable pairs, trips, etc.
@
text
@d46 1
@


1.25
log
@modified find_motif_driver() to use searches instead of descr as paramters.
@
text
@d43 4
@


1.24
log
@changed name of maxlen to windowsize
@
text
@d102 1
a102 1
			find_motif_driver( rm_n_descr, rm_descr, rm_sites,
@


1.23
log
@added new global variable: maxlen which is the default maximum lenght
of any UNBOUNDED descriptor.
Added rm_searches, rm_n_searches which are used to direct the search.
@
text
@d24 1
a24 1
 /*9*/	{ "maxlen", T_INT, C_VAR, S_GLOBAL, { T_INT, 6000 } }
@


1.22
log
@changed names of rm_tminlen, rm_tmaxlen, to rm_dminlen, rm_dmaxlen where
d is for descr vs t for total.
@
text
@d20 1
a20 1
	{ "database", T_STRING, C_VAR, S_GLOBAL, { T_STRING, "VRT" } },
d23 2
a24 1
	{ "wc_maxlen", T_INT, C_VAR, S_GLOBAL, { T_INT, 30 } }
d27 1
a27 1
int	rm_n_global_ids = 8;
d42 3
@


1.21
log
@changed name of find_motif() to find_motif_driver() which sets up the
loop that call find_motif()
@
text
@a27 2
int	rm_tminlen;
int	rm_tmaxlen;
d32 2
d73 2
a74 2
			rm_fname, rm_tminlen );
		if( rm_tmaxlen == UNBOUNDED )
d77 1
a77 1
			fprintf( stderr, "%d\n", rm_tmaxlen );
@


1.20
log
@added 2 new global symbols: wc_minlen, wc_maxlen which control the min/max
length of h5/h3 elements if they are not specifically set.
@
text
@d98 1
a98 1
			find_motif( rm_n_descr, rm_descr, rm_sites,
@


1.19
log
@modified dump control to permit -d, or -h to dump. 1st three dump
options are under control of -d, last -h.
@
text
@d20 1
d22 2
a23 1
	{ "database", T_STRING, C_VAR, S_GLOBAL, { T_STRING, "VRT" } }
d26 1
a26 1
int	rm_n_global_ids = 6;
@


1.18
log
@added rm_tminlen, rm_tmaxlen which hold the min & max len of the complete
descr, plus code to print these values out before searching begins.
@
text
@d12 1
d78 2
a79 2
	if( rm_dopt )
		RM_dump( stderr, 1, 1, 1 );
@


1.17
log
@place RM_dump() under control of -d cmd-line opt.
pass locus returned from DB_getseq() to find_motif()
@
text
@d25 2
d69 6
@


1.16
log
@added rm_copt (-c) on the command line which only compiles the descriptor
but does not execute it.
@
text
@d11 1
d57 1
d69 2
a70 1
	RM_dump( stderr, 1, 1, 1 );
d72 3
d86 1
a86 1
		if( slen = DB_getseq( dbp, SBUFSIZE, sbuf ) ){
d88 1
a88 1
				slen, sbuf );
@


1.15
log
@changed name of find_rnamot() to find_motif(); separated term condition
from getseq() && DB_next() to just DB_next().
@
text
@d10 1
d57 1
a57 1
	RM_init();
d68 3
@


1.14
log
@numerous changes to the main program to connect to the database(s) t
be searched.
@
text
@d77 1
a77 1
			find_rnamot( rm_n_descr, rm_descr, rm_sites,
d79 2
a80 2
		}else
			dbp = DB_next();
@


1.13
log
@added new fxns: opendb() & nextdb() as the first step to finding the
compiled motifs.
@
text
@d18 1
a18 1
	{ "database", T_STRING, C_VAR, S_GLOBAL, { T_STRING, "gbvrt" } }
d37 1
a37 2
static	FILE	*opendb();	
static	FILE	*nextdb();
d39 3
a41 1
char	*getenv();
d45 3
d52 3
a54 1
	FILE	*dbfp;
a67 14
	for( dbfp = opendb(); dbfp; dbfp = nextdb( dbfp ) ){
		find_rnamot( dbfp, rm_n_descr, rm_descr, rm_sites );
	}

	exit( 0 );
}

static	FILE	*opendb()
{
	IDENT_T	*ip;
	char	dbfname[ 256 ];
	char	*gbhp;
	FILE	*fp;

d69 5
a73 1
	RM_dump_id( stderr, ip );
d75 6
a80 9
	if( ( gbhp = getenv( "GBHOME" ) ) == NULL ){
		fprintf( stderr, "rnamot: GBHOME not defined.\n" );
		exit( 1 );
	}
	sprintf( dbfname, "%s/%s.seq", gbhp, ip->i_val.v_value.v_pval );
	if( ( fp = fopen( dbfname, "r" ) ) == NULL ){
		fprintf( stderr, "rnamot: can't read dbfile '%s'.\n",
			dbfname );
		exit( 1 );
d83 1
a83 11
	return( fp );
}

static	FILE	*nextdb( fp )
FILE	*fp;
{

	if( fp != NULL )
		fclose( fp );

	return( NULL );
@


1.12
log
@removed typo that had two consec. ;; in a decl.
@
text
@d18 1
a18 1
	{ "database", T_STRING, C_VAR, S_GLOBAL, { T_STRING, NULL } }
d37 7
d48 1
d61 40
@


1.11
log
@new var rm_sites which holds the site list for the descriptor.
@
text
@d20 1
a20 1
int	rm_s_global_ids = RM_GLOBAL_IDS_SIZE;;
@


1.10
log
@added new vars rm_pos, rm_s_pos, rm_n_pos for holding the positions in
the site currently being compiled.
@
text
@d33 2
@


1.9
log
@replaced fprintf( stderr, error msg with a call to errormsg().
@
text
@d28 5
@


1.8
log
@added call to SE_link() following the parse.
@
text
@d38 1
a38 1
		fprintf( stderr, "syntax error.\n" );
@


1.7
log
@Moved all shared vars to here; renamed them so they all begin with rm_
@
text
@d40 4
@


1.6
log
@renamed SE_dump() to RM_dump(); updated p-list for parms, descr, sites
vs pair, parm, descr, site.
@
text
@d5 23
@


1.5
log
@call RM_init() to declare & define global symbols.
@
text
@d18 1
a18 1
	SE_dump( stderr, 1, 1, 1, 1 );
@


1.4
log
@added argc, argv in prep to being able to read either from stdin or a named
argument.
@
text
@d12 2
@


1.3
log
@added yydebug; changed while() to if().
@
text
@d5 1
a5 1
extern	int	 yydebug;
d7 3
a9 1
main()
@


1.2
log
@added call to SE_dump() following the parse.
@
text
@d5 2
d10 1
a10 1
	while( yyparse() ){
@


1.1
log
@Initial revision
@
text
@d11 2
@
