head	1.24;
access;
symbols;
locks; strict;
comment	@ * @;


1.24
date	2003.02.24.04.13.35;	author macke;	state Exp;
branches;
next	1.23;

1.23
date	2000.12.18.00.19.41;	author macke;	state Exp;
branches;
next	1.22;

1.22
date	2000.10.07.06.07.08;	author macke;	state Exp;
branches;
next	1.21;

1.21
date	2000.04.25.00.21.41;	author macke;	state Exp;
branches;
next	1.20;

1.20
date	2000.03.27.21.45.06;	author macke;	state Exp;
branches;
next	1.19;

1.19
date	2000.03.03.19.49.34;	author macke;	state Exp;
branches;
next	1.18;

1.18
date	99.10.03.19.17.02;	author macke;	state Exp;
branches;
next	1.17;

1.17
date	99.10.03.19.11.03;	author macke;	state Exp;
branches;
next	1.16;

1.16
date	99.10.03.19.03.33;	author macke;	state Exp;
branches;
next	1.15;

1.15
date	99.09.30.01.03.50;	author macke;	state Exp;
branches;
next	1.14;

1.14
date	99.09.15.17.38.37;	author macke;	state Exp;
branches;
next	1.13;

1.13
date	99.09.04.23.26.59;	author macke;	state Exp;
branches;
next	1.12;

1.12
date	99.09.04.04.19.04;	author macke;	state Exp;
branches;
next	1.11;

1.11
date	99.05.28.20.24.06;	author macke;	state Exp;
branches;
next	1.10;

1.10
date	99.01.08.18.54.11;	author macke;	state Exp;
branches;
next	1.9;

1.9
date	98.12.29.21.31.54;	author macke;	state Exp;
branches;
next	1.8;

1.8
date	98.12.27.14.45.04;	author macke;	state Exp;
branches;
next	1.7;

1.7
date	98.12.23.19.41.32;	author macke;	state Exp;
branches;
next	1.6;

1.6
date	98.12.23.03.28.47;	author macke;	state Exp;
branches;
next	1.5;

1.5
date	98.12.21.04.15.39;	author macke;	state Exp;
branches;
next	1.4;

1.4
date	98.12.18.04.34.49;	author macke;	state Exp;
branches;
next	1.3;

1.3
date	98.12.15.04.20.06;	author macke;	state Exp;
branches;
next	1.2;

1.2
date	98.12.14.18.11.12;	author macke;	state Exp;
branches;
next	1.1;

1.1
date	98.12.14.04.29.14;	author macke;	state Exp;
branches;
next	;


desc
@utility routines for building parse trees.
@


1.24
log
@moved visible func decls to rnamot.h
@
text
@#include <stdio.h>

#include "rnamot.h"
#include "y.tab.h"

extern	int	rm_lineno;
extern	char	*rm_wdfname;

NODE_T	*RM_node( int sym, VALUE_T *vp, NODE_T *left, NODE_T *right )
{
	NODE_T	*np;
	char	emsg[ 256 ];

	np = ( NODE_T * )malloc( sizeof( NODE_T ) );
	if( np == NULL ){
		sprintf( emsg, "RM_node: can't allocate np for sym %d.", sym );
		RM_errormsg( 1, emsg );
	}
	np->n_sym = sym;
	np->n_type = T_UNDEF;
	np->n_class = C_UNDEF;
	np->n_filename = rm_wdfname;
	np->n_lineno = rm_lineno;
	np->n_left = left;
	np->n_right = right;
	if( sym == SYM_IDENT ){
		np->n_val.v_type = T_IDENT;
		np->n_val.v_value.v_pval = vp->v_value.v_pval;
	}else if( sym == SYM_INT ){
		np->n_class = C_LIT;
		np->n_val.v_type = T_INT;
		np->n_val.v_value.v_ival = vp->v_value.v_ival;
	}else if( sym == SYM_FLOAT ){
		np->n_class = C_LIT;
		np->n_val.v_type = T_FLOAT;
		np->n_val.v_value.v_dval = vp->v_value.v_dval;
	}else if( sym == SYM_STRING ){
		np->n_class = C_LIT;
		np->n_val.v_type = T_STRING;
		np->n_val.v_value.v_pval = vp->v_value.v_pval;
	}else if( sym == SYM_DOLLAR ){
		np->n_class = C_LIT;
		np->n_val.v_type = T_POS;
		np->n_val.v_value.v_pval = vp->v_value.v_pval;
	}else if( sym == SYM_CALL ){
		np->n_val.v_type = T_IDENT;
		np->n_val.v_value.v_pval = left->n_val.v_value.v_pval;
		np->n_left = NULL;
	}
	return( np );
}

void	RM_dumpexpr( FILE *fp, NODE_T *np, int indent )
{

	if( np ){
		RM_dumpnode( fp, np, indent );
		RM_dumpexpr( fp, np->n_left, indent + 3 );
		RM_dumpexpr( fp, np->n_right, indent + 3 );
	}
}

void	RM_dumpnode( FILE *fp, NODE_T *np, int indent )
{

	fprintf( fp, "%*s",indent, "" );
	fprintf( fp, "%8p: lf = %8p rt = %8p fn,ln,tp,cl = %s:%3d,%2d,%2d ",
		np, np->n_left, np->n_right,
		np->n_filename, np->n_lineno, np->n_type, np->n_class );
	switch( np->n_sym ){

#include "dumpnode.h"

	}
}
@


1.23
log
@save filename in each node.
@
text
@a8 2
void	RM_dumpnode( FILE *, NODE_T *, int );

@


1.22
log
@converted K&R to ANSI.
@
text
@d7 1
d24 1
d69 1
a69 1
	fprintf( fp, "%8p: lf = %8p rt = %8p ln,tp,cl = %3d,%2d,%2d ",
d71 1
a71 1
		np->n_lineno, np->n_type, np->n_class );
@


1.21
log
@change float v_fval to v_dval
@
text
@d8 1
a8 1
void	RM_dumpnode();
d10 1
a10 5
NODE_T	*RM_node( sym, vp, left, right )
int	sym;
VALUE_T	*vp;
NODE_T	*left;
NODE_T	*right;
d53 1
a53 4
void	RM_dumpexpr( fp, np, indent )
FILE	*fp;
NODE_T	*np;
int	indent;
d63 1
a63 4
void	RM_dumpnode( fp, np, indent )
FILE	*fp;
NODE_T	*np;
int	indent;
@


1.20
log
@change dumpnode format to use %8p vs %7p.
@
text
@d40 1
a40 1
		np->n_val.v_value.v_fval = vp->v_value.v_fval;
@


1.19
log
@removed all unused vars that were detected by the fermat C-compiler.
@
text
@d77 1
a77 1
	fprintf( fp, "%7p: lf = %7p rt = %7p ln,tp,cl = %3d,%2d,%2d ",
@


1.18
log
@remove unused fun RM_updnode()
@
text
@a74 1
	POS_T	*posp;
@


1.17
log
@changed all names to have a RM_ prefix.
@
text
@a56 14
NODE_T	*RM_updnode( np, vp, left, right )
NODE_T	*np;
VALUE_T	*vp;
NODE_T	*left;
NODE_T	*right;
{

	if( left != NULL )
		np->n_left = left;
	if( right != NULL )
		np->n_right = right;
	return( np );
}

d83 1
a83 1
#include "RM_dumpnode.h"
@


1.16
log
@changed refs to errormsg() to RM_errormsg()
@
text
@d8 1
a8 1
void	dumpnode();
d10 1
a10 1
NODE_T	*node( sym, vp, left, right )
d21 1
a21 1
		sprintf( emsg, "node: can't allocate np for sym %d.", sym );
d57 1
a57 1
NODE_T	*updnode( np, vp, left, right )
d71 1
a71 1
void	dumpexpr( fp, np, indent )
d78 3
a80 3
		dumpnode( fp, np, indent );
		dumpexpr( fp, np->n_left, indent + 3 );
		dumpexpr( fp, np->n_right, indent + 3 );
d84 1
a84 1
void	dumpnode( fp, np, indent )
d97 1
a97 1
#include "dumpnode.h"
@


1.15
log
@changed type for SYM_CALL to T_IDENT from T_STRING.
@
text
@d22 1
a22 1
		errormsg( 1, emsg );
@


1.14
log
@set v_type to T_IDENT for SYM_IDENT.
@
text
@d50 1
a50 1
		np->n_val.v_type = T_STRING;
@


1.13
log
@added SYM_CALL; replaced literal case interior with #include
of dumpnode.h which is created from y.tab. by mk_dumpnode.h
@
text
@d31 1
a31 1
		np->n_val.v_type = T_STRING;
@


1.12
log
@added code to create float lits & dump them out
@
text
@d49 4
d96 3
a98 93
	case SYM_PARMS :
		fprintf( fp, "SYM_PARMS\n" );
		break;
	case SYM_DESCR :
		fprintf( fp, "SYM_DESCR\n" );
		break;
	case SYM_SITES :
		fprintf( fp, "SYM_SITES\n" );
		break;
	case SYM_H5 :
		fprintf( fp, "SYM_H5\n" );
		break;
	case SYM_H3 :
		fprintf( fp, "SYM_H3\n" );
		break;
	case SYM_P5 :
		fprintf( fp, "SYM_P5\n" );
		break;
	case SYM_P3 :
		fprintf( fp, "SYM_P3\n" );
		break;
	case SYM_T1 :
		fprintf( fp, "SYM_T1\n" );
		break;
	case SYM_T2 :
		fprintf( fp, "SYM_T2\n" );
		break;
	case SYM_T3 :
		fprintf( fp, "SYM_T3\n" );
		break;
	case SYM_Q1 :
		fprintf( fp, "SYM_Q1\n" );
		break;
	case SYM_Q2 :
		fprintf( fp, "SYM_Q2\n" );
		break;
	case SYM_Q3 :
		fprintf( fp, "SYM_Q3\n" );
		break;
	case SYM_Q4 :
		fprintf( fp, "SYM_Q4\n" );
		break;
	case SYM_IDENT :
		fprintf( fp, "SYM_IDENT = '%s'\n", np->n_val.v_value.v_pval );
		break;
	case SYM_INT :
		fprintf( fp, "SYM_INT = %d\n", np->n_val.v_value.v_ival );
		break;
	case SYM_FLOAT :
		fprintf( fp, "SYM_FLOAT = %e\n", np->n_val.v_value.v_fval );
		break;
	case SYM_STRING :
		fprintf( fp, "SYM_STRING = '%s'\n", np->n_val.v_value.v_pval );
		break;
	case SYM_ASSIGN :
		fprintf( fp, "SYM_ASSIGN\n" );
		break;
	case SYM_PLUS_ASSIGN :
		fprintf( fp, "SYM_PLUS_ASSIGN\n" );
		break;
	case SYM_MINUS_ASSIGN :
		fprintf( fp, "SYM_MINUS_ASSIGN\n" );
		break;
	case SYM_PLUS :
		fprintf( fp, "SYM_PLUS\n" );
		break;
	case SYM_MINUS :
		fprintf( fp, "SYM_MINUS\n" );
		break;
	case SYM_DOLLAR :
		fprintf( fp, "SYM_DOLLAR\n" );
		break;
	case SYM_LPAREN :
		fprintf( fp, "SYM_LPAREN\n" );
		break;
	case SYM_RPAREN :
		fprintf( fp, "SYM_RPAREN\n" );
		break;
	case SYM_LCURLY :
		fprintf( fp, "SYM_LCURLY\n" );
		break;
	case SYM_RCURLY :
		fprintf( fp, "SYM_RCURLY\n" );
		break;
	case SYM_COMMA :
		fprintf( fp, "SYM_COMMA\n" );
		break;
	case SYM_COLON :
		fprintf( fp, "SYM_COLON\n" );
		break;
	case SYM_ERROR :
		fprintf( fp, "SYM_ERROR\n" );
		break;
@


1.11
log
@changed format used to print pointer from %d to %p.
@
text
@d37 4
d139 3
@


1.10
log
@forgot to return the value np, the node that was update in updnode().
@
text
@d84 1
a84 1
	fprintf( fp, "%7d: lf = %7d rt = %7d ln,tp,cl = %3d,%2d,%2d ",
@


1.9
log
@SYM_DOLLAR places the pointer to the pair object created by rmlex.l
into the n_val field of the NODE_T.
@
text
@d60 1
@


1.8
log
@removed \n from end of errormsg str as errormsg() appends one.
@
text
@d41 4
d80 1
@


1.7
log
@changed name of rmlineno to rm_lineno.
@
text
@d21 1
a21 1
		sprintf( emsg, "node: can't allocate np for sym %d.\n", sym );
@


1.6
log
@print lineno in dumpnode(); added updnode() which adds bits to an infix
node.
@
text
@d6 1
a6 1
extern	int	rmlineno;
d27 1
a27 1
	np->n_lineno = rmlineno;
@


1.5
log
@replaced fprintf( stderr ... errormsg with call to errormsg();
set class of SYM_INT, SYM_STRING to C_LIT.
@
text
@d45 13
d78 3
a80 2
	fprintf( fp, "%7d: lf = %7d rt = %7d tp,cl = %2d,%2d ",
		np, np->n_left, np->n_right, np->n_type, np->n_class );
@


1.4
log
@save the number of the line that the node was defined on.
@
text
@d17 1
d21 2
a22 3
		fprintf( stderr, "node: FATAL: can't alloc np for sym = %d.\n",
			sym );
		exit( 1 );
d34 1
d38 1
@


1.3
log
@changed EQUAL to ASSIGN; char *v_cval from VALUE_T is now void *v_pval;
@
text
@d6 2
d27 1
@


1.2
log
@changed symbol names: SYM_PARM, SYM_SITE -> SYM_PARMS, SYM_SITES
@
text
@d29 1
a29 1
		np->n_val.v_value.v_cval = vp->v_value.v_cval;
d33 3
d106 1
a106 1
		fprintf( fp, "SYM_IDENT = '%s'\n", np->n_val.v_value.v_cval );
d112 1
a112 1
		fprintf( fp, "SYM_STRING = %'d'\n", np->n_val.v_value.v_cval );
d114 2
a115 2
	case SYM_EQUAL :
		fprintf( fp, "SYM_EQUAL\n" );
d117 2
a118 2
	case SYM_PLUS_EQUAL :
		fprintf( fp, "SYM_PLUS_EQUAL\n" );
d120 2
a121 2
	case SYM_MINUS_EQUAL :
		fprintf( fp, "SYM_MINUS_EQUAL\n" );
@


1.1
log
@Initial revision
@
text
@d60 2
a61 2
	case SYM_PARM :
		fprintf( fp, "SYM_PARM\n" );
d66 2
a67 2
	case SYM_SITE :
		fprintf( fp, "SYM_SITE\n" );
@
