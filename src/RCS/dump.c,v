head	1.49;
access;
symbols;
locks; strict;
comment	@ * @;


1.49
date	2002.05.15.04.17.50;	author macke;	state Exp;
branches;
next	1.48;

1.48
date	2002.05.14.18.56.37;	author macke;	state Exp;
branches;
next	1.47;

1.47
date	2002.02.15.22.41.26;	author macke;	state Exp;
branches;
next	1.46;

1.46
date	2002.02.07.19.37.24;	author macke;	state Exp;
branches;
next	1.45;

1.45
date	2002.02.07.03.14.24;	author macke;	state Exp;
branches;
next	1.44;

1.44
date	2001.07.30.20.01.36;	author macke;	state Exp;
branches;
next	1.43;

1.43
date	2000.12.18.03.04.01;	author macke;	state Exp;
branches;
next	1.42;

1.42
date	2000.12.05.02.35.49;	author macke;	state Exp;
branches;
next	1.41;

1.41
date	2000.10.07.04.57.52;	author macke;	state Exp;
branches;
next	1.40;

1.40
date	2000.09.10.20.40.40;	author macke;	state Exp;
branches;
next	1.39;

1.39
date	2000.04.25.00.15.18;	author macke;	state Exp;
branches;
next	1.38;

1.38
date	2000.03.27.18.56.56;	author macke;	state Exp;
branches;
next	1.37;

1.37
date	2000.03.03.19.00.40;	author macke;	state Exp;
branches;
next	1.36;

1.36
date	99.10.31.01.20.44;	author macke;	state Exp;
branches;
next	1.35;

1.35
date	99.09.28.04.03.35;	author macke;	state Exp;
branches;
next	1.34;

1.34
date	99.09.17.17.07.48;	author macke;	state Exp;
branches;
next	1.33;

1.33
date	99.09.01.22.57.51;	author macke;	state Exp;
branches;
next	1.32;

1.32
date	99.07.08.01.32.04;	author macke;	state Exp;
branches;
next	1.31;

1.31
date	99.06.29.18.20.54;	author macke;	state Exp;
branches;
next	1.30;

1.30
date	99.06.28.23.59.55;	author macke;	state Exp;
branches;
next	1.29;

1.29
date	99.05.28.20.21.45;	author macke;	state Exp;
branches;
next	1.28;

1.28
date	99.05.04.15.40.51;	author macke;	state Exp;
branches;
next	1.27;

1.27
date	99.05.01.06.08.09;	author macke;	state Exp;
branches;
next	1.26;

1.26
date	99.04.28.02.23.04;	author macke;	state Exp;
branches;
next	1.25;

1.25
date	99.04.12.04.20.34;	author macke;	state Exp;
branches;
next	1.24;

1.24
date	99.04.12.03.26.21;	author macke;	state Exp;
branches;
next	1.23;

1.23
date	99.04.05.01.06.36;	author macke;	state Exp;
branches;
next	1.22;

1.22
date	99.04.04.21.14.28;	author macke;	state Exp;
branches;
next	1.21;

1.21
date	99.03.30.16.38.54;	author macke;	state Exp;
branches;
next	1.20;

1.20
date	99.03.27.21.12.28;	author macke;	state Exp;
branches;
next	1.19;

1.19
date	99.03.27.05.37.22;	author macke;	state Exp;
branches;
next	1.18;

1.18
date	99.03.27.02.41.01;	author macke;	state Exp;
branches;
next	1.17;

1.17
date	99.03.27.02.35.02;	author macke;	state Exp;
branches;
next	1.16;

1.16
date	99.03.27.02.01.57;	author macke;	state Exp;
branches;
next	1.15;

1.15
date	99.03.15.02.49.03;	author macke;	state Exp;
branches;
next	1.14;

1.14
date	99.03.14.20.49.44;	author macke;	state Exp;
branches;
next	1.13;

1.13
date	99.03.09.20.29.23;	author macke;	state Exp;
branches;
next	1.12;

1.12
date	99.02.28.04.05.00;	author macke;	state Exp;
branches;
next	1.11;

1.11
date	99.02.28.02.43.14;	author macke;	state Exp;
branches;
next	1.10;

1.10
date	99.01.10.04.48.48;	author macke;	state Exp;
branches;
next	1.9;

1.9
date	99.01.08.20.49.35;	author macke;	state Exp;
branches;
next	1.8;

1.8
date	99.01.02.18.58.53;	author macke;	state Exp;
branches;
next	1.7;

1.7
date	98.12.30.22.58.22;	author macke;	state Exp;
branches;
next	1.6;

1.6
date	98.12.29.22.55.05;	author macke;	state Exp;
branches;
next	1.5;

1.5
date	98.12.29.21.33.25;	author macke;	state Exp;
branches;
next	1.4;

1.4
date	98.12.27.11.11.09;	author macke;	state Exp;
branches;
next	1.3;

1.3
date	98.12.24.22.35.26;	author macke;	state Exp;
branches;
next	1.2;

1.2
date	98.12.24.05.42.20;	author macke;	state Exp;
branches;
next	1.1;

1.1
date	98.12.23.19.43.35;	author macke;	state Exp;
branches;
next	;


desc
@data structure dump routines.
@


1.49
log
@replaced boolean '0' with FALSE
@
text
@#include <stdio.h>
#include <ctype.h>
#include <string.h>

#include "rmdefs.h"
#include "rnamot.h"
#include "y.tab.h"

extern	INCDIR_T	*rm_idlist;

extern	IDENT_T	*rm_global_ids;
extern	int	rm_n_global_ids;

extern	STREL_T	rm_descr[];
extern	int	rm_n_descr;
extern	STREL_T	*rm_lctx;
extern	int	rm_lctx_explicit;
extern	STREL_T	*rm_rctx;
extern	int	rm_rctx_explicit;

extern	SITE_T	*rm_sites;

extern	char	rm_bc2b[];

extern	SEARCH_T	**rm_searches;
extern	int	rm_n_searches;

void	RM_dump_gids( FILE *, IDENT_T *, int );
void	RM_dump_id( FILE *, IDENT_T *, int );
void	RM_dump_pairset( FILE *, PAIRSET_T * );
void	RM_dump_pair( FILE *, PAIR_T * );
void	RM_dump_pairmat( FILE *, PAIRSET_T * );
void	RM_dump_descr( FILE *, STREL_T * );
void	RM_dump_pos( FILE *, int, POS_T * );
void	RM_dump_sites( FILE * );
void	RM_strel_name( STREL_T *, char [] );

static	char	*attr2str( signed char [] );
static	void	print_hierarchy( FILE *, int, char [], int, STREL_T [] );
static	void	print_1_element( FILE *, char [], STREL_T * );
static	void	mk_prefix( STREL_T *, char [], char [] );
static	void	print_searches( FILE *, int, SEARCH_T *[] );

void	RM_dump( FILE *fp,
	int d_parms, int d_descr, int d_sites, int d_hierarchy )
{
	int	i;
	STREL_T	*stp;
	char	prefix[ 100 ];
	INCDIR_T	*id1;

	if( rm_idlist != NULL ){
		for( i = 0, id1 = rm_idlist; id1; id1 = id1->i_next )
			i++;
		fprintf( fp, "INCLUDES: %3d dirs.\n", i );
		for( id1 = rm_idlist; id1; id1 = id1->i_next )
			fprintf( fp, "\t%s\n", id1->i_name );
	}

	if( d_parms ){
		fprintf( fp, "PARMS: %3d global symbols.\n", rm_n_global_ids );
		RM_dump_gids( fp, rm_global_ids, d_parms );
	}

	if( d_descr ){
		fprintf( fp, "DESCR: %3d structure elements.\n", rm_n_descr );
		for( stp = rm_descr, i = 0; i < rm_n_descr; i++, stp++ )
			RM_dump_descr( fp, stp );
		if( rm_lctx != NULL ){
			fprintf( fp, "DESCR: left context (%s).\n",
				rm_lctx_explicit ? "Explicit" : "Implicit" );
			RM_dump_descr( fp, rm_lctx );
		}
		if( rm_rctx != NULL ){
			fprintf( fp, "DESCR: right context (%s).\n",
				rm_rctx_explicit ? "Explicit" : "Implicit" );
			RM_dump_descr( fp, rm_rctx );
		}
	}

	if( d_sites ){
		RM_dump_sites( fp );
	}

	if( d_hierarchy ){
		fprintf( fp,
	"desc# minl  maxl  mngl  mxgl  mnil  mxil start  stop  descr\n" );
		strcpy( prefix, "+" );
		print_hierarchy( fp, 0, prefix, 0, rm_descr );
		print_searches( fp, rm_n_searches, rm_searches );
	}
}

void	RM_dump_gids( FILE *fp, IDENT_T *ip, int fmt )
{

	if( ip != NULL ){
		RM_dump_gids( fp, ip->i_left, fmt );
		RM_dump_id( fp, ip, fmt );
		RM_dump_gids( fp, ip->i_right, fmt );
	}
}

void	RM_dump_id( FILE *fp, IDENT_T *ip, int fmt )
{
	PAIRSET_T	*ps;

	if( fmt == 1 )
		fprintf( fp, "%s (%s) = {\n", ip->i_name,
			ip->i_reinit ? "RW" : "RO" );
	else
		fprintf( fp, "%-16s (%s) = ", ip->i_name,
			ip->i_reinit ? "RW" : "RO" );

	if( fmt == 1 ){
		fprintf( fp, "\ttype  = " );
		switch( ip->i_type ){
		case T_UNDEF :
			fprintf( fp, "UNDEF\n" );
			break;
		case T_INT :
			fprintf( fp, "INT\n" );
			break;
		case T_FLOAT :
			fprintf( fp, "FLOAT\n" );
			break;
		case T_STRING :
			fprintf( fp, "STRING\n" );
			break;
		case T_PAIRSET :
			fprintf( fp, "PAIR\n" );
			break;
		case T_IDENT :
			fprintf( fp, "IDENT\n" );
			break;
		default :
			fprintf( fp, "-- BAD type %d\n", ip->i_type );
			break;
		}

		fprintf( fp, "\tclass = " );
		switch( ip->i_class ){
		case C_UNDEF :
			fprintf( fp, "UNDEF\n" );
			break;
		case C_LIT :
			fprintf( fp, "LIT\n" );
			break;
		case C_VAR :
			fprintf( fp, "VAR\n" );
			break;
		case C_EXPR :
			fprintf( fp, "EXPR\n" );
			break;
		default :
			fprintf( fp, "-- BAD class %d\n", ip->i_class );
			break;
		}
			
		fprintf( fp, "\tscope = " );
		switch( ip->i_scope ){
		case S_UNDEF :
			fprintf( fp, "UNDEF\n" );
			break;
		case S_GLOBAL :
			fprintf( fp, "GLOBAL\n" );
			break;
		case S_STREL :
			fprintf( fp, "STREL\n" );
			break;
		case S_SITE :
			fprintf( fp, "SITE\n" );
			break;
		default :
			fprintf( fp, "-- BAD scope %d\n", ip->i_scope );
			break;
		}

		fprintf( fp, "\treinit= %d\n", ip->i_reinit);
		fprintf( fp, "\tvalue = " );
	}

	switch( ip->i_val.v_type ){
	case T_UNDEF :
		fprintf( fp, "UNDEF\n" );
		break;
	case T_INT :
		fprintf( fp, "%d\n", ip->i_val.v_value.v_ival );
		break;
	case T_FLOAT :
		fprintf( fp, "%lg\n", ip->i_val.v_value.v_dval );
		break;
	case T_STRING :
		fprintf( fp, "'%s'\n", ip->i_val.v_value.v_pval ?
					ip->i_val.v_value.v_pval : "NULL" );
		break;
	case T_PAIRSET :
		ps = ip->i_val.v_value.v_pval;
		RM_dump_pairset( fp, ps );
		fprintf( fp, "\n" );
		break;
	case T_IDENT :
		fprintf( fp, "IDENT?\n" );
		break;
	default :
		fprintf( fp, "-- BAD type %d\n", ip->i_val.v_type );
		break;
	}
		
	if( fmt ==1 )
		fprintf( fp, "}\n" );
}

void	RM_dump_pairset( FILE *fp, PAIRSET_T *ps )
{
	PAIR_T	*pp;
	int	i;

	fprintf( fp, "{ " );
	if( ps != NULL ){
		for( pp = ps->ps_pairs, i = 0; i < ps->ps_n_pairs; i++, pp++ ){
			RM_dump_pair( fp, pp );
			if( i < ps->ps_n_pairs - 1 )
				fprintf( fp, ", " );
		}
	}
	fprintf( fp, " }" );
}

void	RM_dump_pair( FILE *fp, PAIR_T *pp )
{
	int	b;

	fprintf( fp, "\"" );
	for( b = 0; b < pp->p_n_bases; b++ ){
		fprintf( stderr, "%c", pp->p_bases[ b ] );
		if( b < pp->p_n_bases - 1 )
			fprintf( stderr, ":" );
	}
	fprintf( fp, "\"" );
}

void	RM_dump_pairmat( FILE *fp, PAIRSET_T *ps )
{
	PAIR_T	*pp;
	int	nb, np;
	int	i1, i2, i3, i4;
	int	b1, b2, b3, b4;
	BP_MAT_T	*bpmatp;
	BT_MAT_T	*btmatp;
	BQ_MAT_T	*bqmatp;

	pp = ps->ps_pairs;
	nb = pp->p_n_bases;
	fprintf( fp, "{ " );
	if( nb == 2 ){
		bpmatp = ps->ps_mat[ 0 ];
		for( np = 0, i1 = 0; i1 < N_BCODES; i1++ ){
		    for( i2 = 0; i2 < N_BCODES; i2++ ){
			if( (*bpmatp)[i1][i2] ){
			    b1 = rm_bc2b[ i1 ];
			    b2 = rm_bc2b[ i2 ];
			    if( np > 0 )
				fprintf( fp, ", " );
			    fprintf( fp, "%c:%c", b1, b2 );
			    np++;
			}
		    }
		}
	}else if( nb == 3 ){
		btmatp = ps->ps_mat[ 1 ];
		for( np = 0, i1 = 0; i1 < N_BCODES; i1++ ){
		    for( i2 = 0; i2 < N_BCODES; i2++ ){
			for( i3 = 0; i3 < N_BCODES; i3++ ){
			    if( (*btmatp)[i1][i2][i3] ){
				b1 = rm_bc2b[ i1 ];
				b2 = rm_bc2b[ i2 ];
				b3 = rm_bc2b[ i3 ];
				if( np > 0 )
				    fprintf( fp, ", " );
				fprintf( fp, "%c:%c:%c", b1, b2, b3 );
				np++;
			    }
			}
		    }
		}
	}else if( nb == 4 ){
		bqmatp = ps->ps_mat[ 1 ];
		for( np = 0, i1 = 0; i1 < N_BCODES; i1++ ){
		    for( i2 = 0; i2 < N_BCODES; i2++ ){
			for( i3 = 0; i3 < N_BCODES; i3++ ){
			    for( i4 = 0; i4 < N_BCODES; i4++ ){
				if( (*bqmatp)[i1][i2][i3][i4] ){
				    b1 = rm_bc2b[ i1 ];
				    b2 = rm_bc2b[ i2 ];
				    b3 = rm_bc2b[ i3 ];
				    b4 = rm_bc2b[ i4 ];
				    if( np > 0 )
					fprintf( fp, ", " );
				    fprintf( fp, "%c:%c:%c:%c", b1, b2, b3, b4);
				    np++;
				}
			    }
			}
		    }
		}
	}
	fprintf( fp, " }\n" );
}

void	RM_dump_descr( FILE *fp, STREL_T *stp )
{
	int	i;
	STREL_T	*stp1;

	fprintf( fp, "descr[%3d] = {\n", stp->s_index );
	fprintf( fp, "\ttype     = " );
	switch( stp->s_type ){
	case SYM_CTX :
		fprintf( fp, "ctx" );
		break;
	case SYM_SS :
		fprintf( fp, "ss" );
		break;
	case SYM_H5 :
		fprintf( fp, "h5" );
		break;
	case SYM_H3 :
		fprintf( fp, "h3" );
		break;
	case SYM_P5 :
		fprintf( fp, "p5" );
		break;
	case SYM_P3 :
		fprintf( fp, "p3" );
		break;
	case SYM_T1 :
		fprintf( fp, "t1" );
		break;
	case SYM_T2 :
		fprintf( fp, "t2" );
		break;
	case SYM_T3 :
		fprintf( fp, "t3" );
		break;
	case SYM_Q1 :
		fprintf( fp, "q1" );
		break;
	case SYM_Q2 :
		fprintf( fp, "q2" );
		break;
	case SYM_Q3 :
		fprintf( fp, "q3" );
		break;
	case SYM_Q4 :
		fprintf( fp, "q4" );
		break;
	default :
		fprintf( fp, "unknown (%d)", stp->s_type );
		break;
	}
	fprintf( fp, "\n" );

	fprintf( fp, "\tattr     = %s", attr2str( stp->s_attr ) );
	fprintf( fp, "\n" );

	fprintf( fp, "\tlineno   = %d\n", stp->s_lineno );

	fprintf( fp, "\tsearchno = " );
	if( stp->s_searchno == UNDEF )
		fprintf( fp, "UNDEF" );
	else
		fprintf( fp, "%d", stp->s_searchno );
	fprintf( fp, "\n" );

	fprintf( fp, "\ttag      = '%s'\n",
		stp->s_tag ? stp->s_tag : "(No tag)" );

	fprintf( fp, "\tnext     = " );
	if( stp->s_next != NULL ) 
		fprintf( fp, "%d\n", stp->s_next->s_index );
	else
		fprintf( fp, "(None)\n" );

	fprintf( fp, "\tprev     = " );
	if( stp->s_prev != NULL ) 
		fprintf( fp, "%d\n", stp->s_prev->s_index );
	else
		fprintf( fp, "(None)\n" );

	fprintf( fp, "\tinner    = " );
	if( stp->s_inner ){
		stp1 = stp->s_inner;
		fprintf( fp, "%d", stp1->s_index );
	}else
		fprintf( fp, "(None)" );
	fprintf( fp, "\n" );

	fprintf( fp, "\touter    = " );
	if( stp->s_outer ){
		stp1 = stp->s_outer;
		fprintf( fp, "%d", stp1->s_index );
	}else
		fprintf( fp, "(None)" );
	fprintf( fp, "\n" );

	fprintf( fp, "\tmates    = [ " );
	for( i = 0; i < stp->s_n_mates; i++ ){
		stp1 = stp->s_mates[ i ];
		fprintf( fp, "%d", stp1->s_index );
		if( i < stp->s_n_mates - 1 )
			fprintf( fp, ", " );
	}
	fprintf( fp, " ]\n" );
	fprintf( fp, "\tscopes   = [ " );
	for( i = 0; i < stp->s_n_scopes; i++ ){
		stp1 = stp->s_scopes[ i ];
		fprintf( fp, "%d", stp1->s_index );
		if( i < stp->s_n_scopes - 1 )
			fprintf( fp, ", " );
	}
	fprintf( fp, " ]\n" );
	fprintf( fp, "\tscope    = %d\n", stp->s_scope );

	fprintf( fp, "\tlen      = " );
	if( stp->s_minlen == UNDEF )
		fprintf( fp, "UNDEF" );
	else if( stp->s_minlen == UNBOUNDED )
		fprintf( fp, "UNBOUNDED" );
	else
		fprintf( fp, "%d", stp->s_minlen );
	fprintf( fp, ":" );
	if( stp->s_maxlen == UNDEF )
		fprintf( fp, "UNDEF" );
	else if( stp->s_maxlen == UNBOUNDED )
		fprintf( fp, "UNBOUNDED" );
	else
		fprintf( fp, "%d", stp->s_maxlen );
	fprintf( fp, "\n" );

	fprintf( fp, "\tglen     = " );
	if( stp->s_minglen == UNDEF )
		fprintf( fp, "UNDEF" );
	else if( stp->s_minglen == UNBOUNDED )
		fprintf( fp, "UNBOUNDED" );
	else
		fprintf( fp, "%d", stp->s_minglen );
	fprintf( fp, ":" );
	if( stp->s_maxglen == UNDEF )
		fprintf( fp, "UNDEF" );
	else if( stp->s_maxglen == UNBOUNDED )
		fprintf( fp, "UNBOUNDED" );
	else
		fprintf( fp, "%d", stp->s_maxglen );
	fprintf( fp, "\n" );

	fprintf( fp, "\tilen     = " );
	if( stp->s_minilen == UNDEF )
		fprintf( fp, "UNDEF" );
	else if( stp->s_minilen == UNBOUNDED )
		fprintf( fp, "UNBOUNDED" );
	else
		fprintf( fp, "%d", stp->s_minilen );
	fprintf( fp, ":" );
	if( stp->s_maxilen == UNDEF )
		fprintf( fp, "UNDEF" );
	else if( stp->s_maxilen == UNBOUNDED )
		fprintf( fp, "UNBOUNDED" );
	else
		fprintf( fp, "%d", stp->s_maxilen );
	fprintf( fp, "\n" );

	fprintf( fp, "\tstart    = " );
	if( stp->s_start.a_offset == UNDEF )
		fprintf( fp, "UNDEF" );
	else if( stp->s_start.a_l2r )
		fprintf( fp, "%d", stp->s_start.a_offset );
	else
		fprintf( fp, "$-%d", stp->s_start.a_offset );
	fprintf( fp, "\n" );

	fprintf( fp, "\tstop     = " );
	if( stp->s_stop.a_offset == UNDEF )
		fprintf( fp, "UNDEF" );
	else if( stp->s_stop.a_l2r )
		fprintf( fp, "%d", stp->s_stop.a_offset );
	else
		fprintf( fp, "$-%d", stp->s_stop.a_offset );
	fprintf( fp, "\n" );

	fprintf( fp, "\tseq      = '%s'\n",
		stp->s_seq ? stp->s_seq : "(No seq)" );

	fprintf( fp, "\tmismatch = " );
	if( stp->s_mismatch == UNDEF )
		fprintf( fp, "UNDEF\n" );
	else
		fprintf( fp, "%d\n", stp->s_mismatch );
	fprintf( fp, "\tmatchfrac= " );
	if( stp->s_matchfrac == UNDEF )
		fprintf( fp, "UNDEF\n" );
	else
		fprintf( fp, "%5.3lf\n", stp->s_matchfrac );

	fprintf( fp, "\tmispair  = " );
	if( stp->s_mispair == UNDEF )
		fprintf( fp, "UNDEF\n" );
	else
		fprintf( fp, "%d\n", stp->s_mispair );
	fprintf( fp, "\tpairfrac = " );
	if( stp->s_pairfrac == UNDEF )
		fprintf( fp, "UNDEF\n" );
	else
		fprintf( fp, "%5.3lf\n", stp->s_pairfrac );

	fprintf( fp, "\tpair     = " );
	if( stp->s_pairset != NULL )
		RM_dump_pairset( fp, stp->s_pairset );
	else
		fprintf( fp, "(None)" );
	fprintf( fp, "\n" );

	fprintf( fp, "}\n" );
}

void	RM_dump_pos( FILE *fp, int p, POS_T *posp )
{
	STREL_T	*stp;

	fprintf( fp, "\tpos[%2d] = {\n", p + 1 );
	fprintf( fp, "\t\ttype     = " );
	switch( posp->p_type ){
	case SYM_SS :
		fprintf( fp, "ss" );
		break;
	case SYM_H5 :
		fprintf( fp, "h5" );
		break;
	case SYM_H3 :
		fprintf( fp, "h3" );
		break;
	case SYM_P5 :
		fprintf( fp, "p5" );
		break;
	case SYM_P3 :
		fprintf( fp, "p3" );
		break;
	case SYM_T1 :
		fprintf( fp, "t1" );
		break;
	case SYM_T2 :
		fprintf( fp, "t2" );
		break;
	case SYM_T3 :
		fprintf( fp, "t3" );
		break;
	case SYM_Q1 :
		fprintf( fp, "q1" );
		break;
	case SYM_Q2 :
		fprintf( fp, "q2" );
		break;
	case SYM_Q3 :
		fprintf( fp, "q3" );
		break;
	case SYM_Q4 :
		fprintf( fp, "q4" );
		break;
	default :
		fprintf( fp, "unknown (%d)", posp->p_type );
		break;
	}
	fprintf( fp, "\n" );

	fprintf( fp, "\t\tlineno   = %d\n", posp->p_lineno );
	fprintf( fp, "\t\ttag      = '%s'\n",
		posp->p_tag ? posp->p_tag : "(No tag)" );
	stp = posp->p_descr;
/*
	fprintf( fp, "\t\tdindex   = %d\n", posp->p_descr->s_index );
*/
	fprintf( fp, "\t\tdindex   = %d\n", stp->s_index );
	fprintf( fp, "\t\tl2r      = %s\n",
		posp->p_addr.a_l2r ? "TRUE" : "FALSE" );
	fprintf( fp, "\t\toffset   = %d\n", posp->p_addr.a_offset );
	fprintf( fp, "\t}\n" );
}

void	RM_dump_sites( FILE *fp )
{
	int	i, j, n_sites;
	SITE_T	*sp;
	POS_T	*posp;

	for( n_sites = 0, sp = rm_sites; sp; sp = sp->s_next )
		n_sites++;
	fprintf( fp, "SITES: %4d sites.\n", n_sites );
	for( i = 0, sp = rm_sites; sp; sp = sp->s_next, i++ ){
		fprintf( fp, "site[%2d] = {\n", i + 1 );
		fprintf( fp, "\tnpos    = %3d\n", sp->s_n_pos );
		for( posp = sp->s_pos, j = 0; j < sp->s_n_pos; j++, posp++ )
			RM_dump_pos( fp, j, posp );	
		fprintf( fp, "\tpairset = " );
		RM_dump_pairset( fp, sp->s_pairset );
		fprintf( fp, "\n" );
		fprintf( fp, "}\n" );
	}
}

void	RM_strel_name( STREL_T *stp, char name[] )
{

	switch( stp->s_type ){
	case SYM_CTX :
		strcpy( name, "ctx" );
		break;

	case SYM_SS :
		strcpy( name, "ss" );
		break;

	case SYM_H5 :
		strcpy( name, "h5" );
		break;
	case SYM_H3 :
		strcpy( name, "h3" );
		break;

	case SYM_P5 :
		strcpy( name, "p5" );
		break;
	case SYM_P3 :
		strcpy( name, "p3" );
		break;

	case SYM_T1 :
		strcpy( name, "t1" );
		break;
	case SYM_T2 :
		strcpy( name, "t2" );
		break;
	case SYM_T3 :
		strcpy( name, "t3" );
		break;

	case SYM_Q1 :
		strcpy( name, "q1" );
		break;
	case SYM_Q2 :
		strcpy( name, "q2" );
		break;
	case SYM_Q3 :
		strcpy( name, "q3" );
		break;
	case SYM_Q4 :
		strcpy( name, "q4" );
		break;
	}
}

static	char	*attr2str( signed char attr[] )
{
	int	acnt = 0;
	static	char	astr[ 256 ];

	strcpy( astr, "{ " );
	if( attr[ SA_PROPER ] ){
		if( acnt > 0 )
			strcat( astr, "," );
		strcat( astr, "P" );
		acnt++;
	}
	if( attr[ SA_ENDS ] ){
		if( attr[ SA_ENDS ] & SA_5PAIRED ){
			if( acnt > 0 )
				strcat( astr, "," );
			strcat( astr, "p5" );
			acnt++;
		}
		if( attr[ SA_ENDS ] & SA_3PAIRED ){
			if( acnt > 0 )
				strcat( astr, "," );
			strcat( astr, "p3" );
			acnt++;
		}
	}
	if( attr[ SA_STRICT ] ){
		if( attr[ SA_STRICT ] & SA_5STRICT ){
			if( acnt > 0 )
				strcat( astr, "," );
			strcat( astr, "s5" );
			acnt++;
		}
		if( attr[ SA_STRICT ] & SA_3STRICT ){
			if( acnt > 0 )
				strcat( astr, "," );
			strcat( astr, "s3" );
			acnt++;
		}
	}
	return( strcat( astr, " }" ) );
}

static	void	print_hierarchy( FILE *fp, int lev, char prefix[],
	int fd, STREL_T descr[] )
{
	int	d, nd, s;
	STREL_T	*stp, *stp1, *stp2;
	char	prefix1[ 100 ], prefix2[ 100 ];;

	for( d = fd; ; d = nd ){
		stp = &descr[ d ];
		print_1_element( fp, prefix, stp );
		mk_prefix( stp, prefix, prefix1 ); 
		for( s = 1; s < stp->s_n_scopes; s++ ){
			stp1 = stp->s_scopes[ s - 1 ];
			stp2 = stp->s_scopes[ s ];
			if( stp1->s_index + 1 < stp2->s_index )
				print_hierarchy( fp, lev+2, prefix1, 
					stp1->s_index+1, descr );
			mk_prefix( stp2, prefix, prefix2 ); 
			print_1_element( fp, prefix2, stp2 );
		}
		stp1 = stp->s_next;
		if( stp1 == NULL )
			return;
		else
			nd = stp1->s_index;
	} 
}

static	void	print_1_element( FILE *fp, char prefix[], STREL_T *stp )
{
	char	name[ 20 ], tstr[ 20 ];
	char	*bp, buf[ 200 ];

	bp = buf;
	sprintf( bp, "%4d", stp->s_index );
	bp += strlen( bp );

	sprintf( bp, " %5d", stp->s_minlen );
	bp += strlen( bp );

	if( stp->s_maxlen == UNBOUNDED )
		sprintf( bp, " UNBND" );
	else
		sprintf( bp, " %5d", stp->s_maxlen );
	bp += strlen( bp );

	if( stp->s_minglen == UNDEF )
		sprintf( bp, " UNDEF" );
	else
		sprintf( bp, " %5d", stp->s_minglen );
	bp += strlen( bp );

	if( stp->s_maxglen == UNBOUNDED )
		sprintf( bp, " UNBND" );
	else if( stp->s_maxglen == UNDEF )
		sprintf( bp, " UNDEF" );
	else
		sprintf( bp, " %5d", stp->s_maxglen );
	bp += strlen( bp );

	if( stp->s_minilen == UNDEF )
		sprintf( bp, " UNDEF" );
	else
		sprintf( bp, " %5d", stp->s_minilen );
	bp += strlen( bp );

	if( stp->s_maxilen == UNBOUNDED )
		sprintf( bp, " UNBND" );
	else if( stp->s_maxilen == UNDEF )
		sprintf( bp, " UNDEF" );
	else
		sprintf( bp, " %5d", stp->s_maxilen );
	bp += strlen( bp );

	sprintf( tstr, "%s%d", !stp->s_start.a_l2r ? "$-" : "",
		stp->s_start.a_offset );
	sprintf( bp, " %5s", tstr );
	bp += strlen( bp );

	sprintf( tstr, "%s%d", !stp->s_stop.a_l2r ? "$-" : "",
		stp->s_stop.a_offset );
	sprintf( bp, " %5s", tstr );
	bp += strlen( bp );

	RM_strel_name( stp, name );
	sprintf( bp, "  %s%s", prefix, name );
	bp += strlen( bp );

	if( stp->s_scope == 0 ){
		sprintf( bp, "+--+" );
		bp += strlen( bp );
	}
	sprintf( bp, "\n" );
	bp += strlen( bp );

	fputs( buf, fp );
}

static	void	mk_prefix( STREL_T *stp, char prefix[], char prefix1[] )
{
	char	*pp;
	int	plen;
	int	inner, next, first;

	strcpy( prefix1, prefix );
	plen = strlen( prefix1 );
	pp = &prefix1[ plen - 1 ];

	inner = stp->s_inner != NULL;
	if( inner )
		first = stp->s_scope == 0;
	else
		first = FALSE;
	next = stp->s_next != NULL;
	if( next )
		*pp = '|';
	else if( *pp != '|' )
		*pp = ' ';
	if( first )
		strcat( prefix1, "  |" );
	strcat( prefix1, "  +" );
}

static	void	print_searches( FILE *fp, int n_searches, SEARCH_T *searches[] )
{
	int	s;
	STREL_T	*stp, *stp1;
	char	name[ 20 ];

	fprintf( fp, "total search depth: %3d\n", n_searches );
	fprintf( fp, "srch# desc# type  forward  backup\n" );
	for( s = 0; s < n_searches; s++ ){
		stp = searches[ s ]->s_descr;
		RM_strel_name( stp, name );
		fprintf( fp, "%4d %5d %5s", s, stp->s_index, name );
		stp1 = searches[ s ]->s_forward;
		if( stp1 != NULL )
			fprintf( fp, " %8d", stp1->s_index );
		else
			fprintf( fp, "   (None)" );
		stp1 = searches[ s ]->s_backup;
		if( stp1 != NULL )
			fprintf( fp, " %7d", stp1->s_index );
		else
			fprintf( fp, "  (None)" );
		fprintf( fp, "\n" );
	}
}
@


1.48
log
@add new include rmdefs.h which holds UNDEF, FALSE, TRUE.  Only UNDEF used
right now.
@
text
@d816 1
a816 1
		first = 0;
@


1.47
log
@changed to reflect the change from bit to byte attributes.
@
text
@d5 1
@


1.46
log
@added code to print new attribute.
@
text
@d37 1
a37 1
static	char	*attr2str( int );
d660 1
a660 1
static	char	*attr2str( int attr )
d662 1
a662 1
	int	i, acnt;
d666 8
a673 3
	for( acnt = 0, i = 0; i < SA_N_ATTR; i++ ){
		switch( attr & (1<<i) ){
		case SA_PROPER :
d676 1
a676 1
			strcat( astr, "P" );
d678 2
a679 2
			break;
		case SA_5PAIRED :
d682 1
a682 1
			strcat( astr, "p5" );
d684 4
a687 2
			break;
		case SA_3PAIRED :
d690 1
a690 1
			strcat( astr, "p3" );
d692 2
a693 2
			break;
		case SA_STRICT :
d696 1
a696 1
			strcat( astr, "S" );
a697 1
			break;
@


1.45
log
@added code to print the reinit stat of each symbol.
@
text
@d686 6
@


1.44
log
@added/modified code to deal with the new descriptor type
ctx (context).
@
text
@d108 2
a109 1
		fprintf( fp, "%s = {\n", ip->i_name );
d111 2
a112 1
		fprintf( fp, "%-16s = ", ip->i_name );
@


1.43
log
@modified to deal with new tree based global symbol table.
@
text
@a9 3
/*
extern	IDENT_T	*rm_global_ids[];
*/
d15 4
a60 10
/*
		for( ip = rm_global_ids, i = 0; i < rm_n_global_ids; i++, ip++ )
			RM_dump_id( fp, ip, d_parms );
*/
/*
		for( i = 0; i < rm_n_global_ids; i++ ){
			ip = rm_global_ids[ i ];
			RM_dump_id( fp, ip, d_parms );
		}
*/
d68 10
d316 3
d525 1
d575 5
a579 1
	fprintf( fp, "\t\tdindex   = %d\n", posp->p_dindex );
d611 4
@


1.42
log
@added code to dump the include directory list.
@
text
@d10 4
a13 1
extern	IDENT_T	rm_global_ids[];
d26 1
a45 1
	IDENT_T	*ip;
d60 1
d63 8
d89 10
@


1.41
log
@converted all headers from K&R to ANSI.
@
text
@d8 2
d45 9
@


1.40
log
@added fmt option to RM_dump_id(). Comes in as the value of d_parms.  If
1 (as usual), get the old format, If 2 get a an abbreviated format that
is useful for seeing what exists!
@
text
@d21 17
a37 21
void	RM_dump_id();
void	RM_dump_pairset();
void	RM_dump_pair();
void	RM_dump_pairmat();
void	RM_dump_descr();
void	RM_dump_sites();
void	RM_strel_name();

static	char	*attr2str();
static	void	print_hierarchy();
static	void	print_1_element();
static	void	mk_prefix();
static	void	print_searches();
static	void	print_mat();

void	RM_dump( fp, d_parms, d_descr, d_sites, d_hierarchy )
FILE	*fp;
int	d_parms;
int	d_descr;
int	d_sites;
int	d_hierarchy;
d69 1
a69 4
void	RM_dump_id( fp, ip, fmt )
FILE	*fp;
IDENT_T	*ip;
int	fmt;
d177 1
a177 3
void	RM_dump_pairset( fp, ps )
FILE	*fp;
PAIRSET_T	*ps;
d193 1
a193 3
void	RM_dump_pair( fp, pp )
FILE	*fp;
PAIR_T	*pp;
d206 1
a206 3
void	RM_dump_pairmat( fp, ps )
FILE	*fp;
PAIRSET_T	*ps;
d274 1
a274 3
void	RM_dump_descr( fp, stp )
FILE	*fp;
STREL_T	*stp;
d486 1
a486 4
void	RM_dump_pos( fp, p, posp )
FILE	*fp;
int	p;
POS_T	*posp;
d544 1
a544 2
void	RM_dump_sites( fp )
FILE	*fp;
d565 1
a565 3
void	RM_strel_name( stp, name )
STREL_T	*stp;
char	name[];
d612 1
a612 2
static	char	*attr2str( attr )
int	attr;
d643 2
a644 6
static	void	print_hierarchy( fp, lev, prefix, fd, descr )
FILE	*fp;
int	lev;
char	prefix[];
int	fd;
STREL_T	descr[];
d671 1
a671 4
static	void	print_1_element( fp, prefix, stp )
FILE	*fp;
char	prefix[];
STREL_T	*stp;
d741 1
a741 4
static	void	mk_prefix( stp, prefix, prefix1 )
STREL_T	*stp;
char	prefix[];
char	prefix1[];
d766 1
a766 4
static	void	print_searches( fp, n_searches, searches )
FILE	*fp;
int	n_searches;
SEARCH_T	*searches[];
@


1.39
log
@changed float values to double.
@
text
@d51 1
a51 1
			RM_dump_id( fp, ip );
d73 1
a73 1
void	RM_dump_id( fp, ip )
d76 1
d80 68
a147 1
	fprintf( fp, "%s = {\n", ip->i_name );
d149 2
a150 61
	fprintf( fp, "\ttype  = " );
	switch( ip->i_type ){
	case T_UNDEF :
		fprintf( fp, "UNDEF\n" );
		break;
	case T_INT :
		fprintf( fp, "INT\n" );
		break;
	case T_FLOAT :
		fprintf( fp, "FLOAT\n" );
		break;
	case T_STRING :
		fprintf( fp, "STRING\n" );
		break;
	case T_PAIRSET :
		fprintf( fp, "PAIR\n" );
		break;
	case T_IDENT :
		fprintf( fp, "IDENT\n" );
		break;
	default :
		fprintf( fp, "-- BAD type %d\n", ip->i_type );
		break;
	}

	fprintf( fp, "\tclass = " );
	switch( ip->i_class ){
	case C_UNDEF :
		fprintf( fp, "UNDEF\n" );
		break;
	case C_LIT :
		fprintf( fp, "LIT\n" );
		break;
	case C_VAR :
		fprintf( fp, "VAR\n" );
		break;
	case C_EXPR :
		fprintf( fp, "EXPR\n" );
		break;
	default :
		fprintf( fp, "-- BAD class %d\n", ip->i_class );
		break;
	}
		
	fprintf( fp, "\tscope = " );
	switch( ip->i_scope ){
	case S_UNDEF :
		fprintf( fp, "UNDEF\n" );
		break;
	case S_GLOBAL :
		fprintf( fp, "GLOBAL\n" );
		break;
	case S_STREL :
		fprintf( fp, "STREL\n" );
		break;
	case S_SITE :
		fprintf( fp, "SITE\n" );
		break;
	default :
		fprintf( fp, "-- BAD scope %d\n", ip->i_scope );
		break;
a152 3
	fprintf( fp, "\treinit= %d\n", ip->i_reinit);

	fprintf( fp, "\tvalue = " );
d164 1
a164 1
		fprintf( fp, "%s\n", ip->i_val.v_value.v_pval ?
d180 2
a181 1
	fprintf( fp, "}\n" );
@


1.38
log
@changed all refs of T_PAIR to T_PAIRSET
@
text
@d155 1
a155 1
		fprintf( fp, "%f\n", ip->i_val.v_value.v_fval );
d471 1
a471 1
		fprintf( fp, "%5.3f\n", stp->s_matchfrac );
d482 1
a482 1
		fprintf( fp, "%5.3f\n", stp->s_pairfrac );
@


1.37
log
@removed unused vars as detected by the SGI compiler on fermat.
@
text
@d95 1
a95 1
	case T_PAIR :
d161 1
a161 1
	case T_PAIR :
@


1.36
log
@added code to dump the names of the bits in the attribute set.
@
text
@a76 1
	PAIR_T	*pp;
a77 1
	int	i, b;
d182 1
a182 1
	int	i, b;
a560 1
	PAIRSET_T	*ps;
d655 1
a655 1
	strcat( astr, " }" );
a694 1
	int	start, stop, l2r;
d768 1
a768 1
	char	*pp, *pp1;
a769 1
	STREL_T	*stp0;
@


1.35
log
@added code to dump matchfrac & pairfrac; added 1 space SITES:
@
text
@d29 1
d334 1
a334 1
	fprintf( fp, "\tproper   = %s", stp->s_proper ? "yes" : "no" );
d627 32
@


1.34
log
@added code to RM_dump_id() to print value of i_reinit;
@
text
@d468 5
d479 5
d566 1
a566 1
	fprintf( fp, "SITES: %3d sites.\n", n_sites );
@


1.33
log
@check in print_hierarchy that an internal scope exists before trying
to print it.
@
text
@d145 2
@


1.32
log
@rename mk_strel_name() to RM_strel_name() and made it visible.
@
text
@d634 3
a636 2
			print_hierarchy( fp, lev+2, prefix1, 
				stp1->s_index+1, descr );
@


1.31
log
@change code that dumps the contents of ps_mat to use ps_mat[1] for 3,4-plex
instead of ps_mat[0] for 2-plex.
@
text
@d27 1
a31 1
static	void	mk_strel_name();
d567 49
d707 1
a707 1
	mk_strel_name( stp, name );
a749 49
static	void	mk_strel_name( stp, name )
STREL_T	*stp;
char	name[];
{

	switch( stp->s_type ){
	case SYM_SS :
		strcpy( name, "ss" );
		break;

	case SYM_H5 :
		strcpy( name, "h5" );
		break;
	case SYM_H3 :
		strcpy( name, "h3" );
		break;

	case SYM_P5 :
		strcpy( name, "p5" );
		break;
	case SYM_P3 :
		strcpy( name, "p3" );
		break;

	case SYM_T1 :
		strcpy( name, "t1" );
		break;
	case SYM_T2 :
		strcpy( name, "t2" );
		break;
	case SYM_T3 :
		strcpy( name, "t3" );
		break;

	case SYM_Q1 :
		strcpy( name, "q1" );
		break;
	case SYM_Q2 :
		strcpy( name, "q2" );
		break;
	case SYM_Q3 :
		strcpy( name, "q3" );
		break;
	case SYM_Q4 :
		strcpy( name, "q4" );
		break;
	}
}

d763 1
a763 1
		mk_strel_name( stp, name );
@


1.30
log
@use ps_mat[0] for now to dump the base pair info.
@
text
@d239 1
a239 1
		btmatp = ps->ps_mat[ 0 ];
d256 1
a256 1
		bqmatp = ps->ps_mat[ 0 ];
@


1.29
log
@converted RM_dump_pos() to void RM_dump_pos() as it returns no value.
@
text
@d225 1
a225 1
		bpmatp = ps->ps_mat;
d239 1
a239 1
		btmatp = ps->ps_mat;
d256 1
a256 1
		bqmatp = ps->ps_mat;
@


1.28
log
@added new func RM_dump_pairmat() used to print the value of the binary
pairing matrix.
@
text
@d483 1
a483 1
RM_dump_pos( fp, p, posp )
@


1.27
log
@added code to dump new field s_searchno of STREL_T.
modified print_searches() to print a table with headings vs id's inline.
@
text
@d16 2
d24 1
d33 1
d207 70
@


1.26
log
@extended -h (hierarchy) option to print the search order as well.
@
text
@d61 1
a61 1
	"descr minl  maxl  mngl  mxgl  mnil  mxil start  stop  descr\n" );
d262 7
d686 1
d690 2
a691 2
		fprintf( fp, "%3d: type = %s", stp->s_index, name );
		stp1 = searches[ s ]->s_next;
d693 1
a693 1
			fprintf( fp, ", next = %6d", stp1->s_index );
d695 1
a695 1
			fprintf( fp, ", next = (None)" );
d698 1
a698 1
			fprintf( fp, ", backup = %6d", stp1->s_index );
d700 1
a700 1
			fprintf( fp, ", backup = (None)" );
@


1.25
log
@removed incorrect $ that was printed before l2r addresses in start
field of STREL_T
@
text
@d16 3
d29 1
d64 1
d666 28
@


1.24
log
@fixed stmts that printed values of descr start/stop that used = UNDEF
vs == UNDEF
@
text
@d358 1
a358 1
		fprintf( fp, "$%d", stp->s_start.a_offset );
@


1.23
log
@moved print_limits() from find_motif.c to here. Renamed to print_hierarchy().
@
text
@d50 1
d54 1
d355 1
a355 1
	if( stp->s_start.a_offset = UNDEF )
d364 1
a364 1
	if( stp->s_stop.a_offset = UNDEF )
@


1.22
log
@added code to dump fields s_start, s_stop of STREL_T.
@
text
@d22 6
a27 1
void	RM_dump( fp, d_parms, d_descr, d_sites )
d32 1
d37 1
d53 6
d476 183
@


1.21
log
@print s_scope, the actual index into s_scopes[] not s_scope + 1.
@
text
@d339 18
d437 3
a439 2
	fprintf( fp, "\t\tl2r      = %s\n", posp->p_l2r ? "TRUE" : "FALSE" );
	fprintf( fp, "\t\toffset   = %d\n", posp->p_offset );
@


1.20
log
@added code to dump s_outer field of STREL_T.
@
text
@d289 1
a289 1
	fprintf( fp, "\tscope    = %d\n", stp->s_scope + 1 );
@


1.19
log
@remove if()'s that skipped printing mates, scopes, pairset for type ss,
and print (None) where appropriate.
@
text
@d265 8
@


1.18
log
@added code to print s_prev field of STREL_T.
@
text
@d265 6
a270 18
	if( stp->s_type != SYM_SS ){
		fprintf( fp, "\tmates    = [ " );
		for( i = 0; i < stp->s_n_mates; i++ ){
			stp1 = stp->s_mates[ i ];
			fprintf( fp, "%d", stp1->s_index );
			if( i < stp->s_n_mates - 1 )
				fprintf( fp, ", " );
		}
		fprintf( fp, " ]\n" );
		fprintf( fp, "\tscopes   = [ " );
		for( i = 0; i < stp->s_n_scopes; i++ ){
			stp1 = stp->s_scopes[ i ];
			fprintf( fp, "%d", stp1->s_index );
			if( i < stp->s_n_scopes - 1 )
				fprintf( fp, ", " );
		}
		fprintf( fp, " ]\n" );
		fprintf( fp, "\tscope    = %d\n", stp->s_scope + 1 );
d272 10
d340 5
a344 6
	if( stp->s_type != SYM_SS ){
		fprintf( fp, "\tmispair  = " );
		if( stp->s_mispair == UNDEF )
			fprintf( fp, "UNDEF\n" );
		else
			fprintf( fp, "%d\n", stp->s_mispair );
d346 2
a347 1
		fprintf( fp, "\tpair     = " );
d349 3
a351 2
		fprintf( fp, "\n" );
	}
@


1.17
log
@oops. cut & pasted minglen when I needed minilen.
@
text
@d251 6
@


1.16
log
@added code to print values of minglen/maxglen & minilen/maxilen.
@
text
@d317 1
a317 1
		fprintf( fp, "%d", stp->s_minglen );
@


1.15
log
@print actual s_index, not s_index + 1 as this is a DUMP.  Added code to
dump s_next
@
text
@d295 32
@


1.14
log
@updated RM_dump_descr() to deal with s_scopes & s_in. s_in not done yet.
@
text
@d192 1
a192 1
	fprintf( fp, "descr[%3d] = {\n", stp->s_index + 1 );
d245 6
d254 1
a254 1
		fprintf( fp, "%d", stp1->s_index + 1 );
d263 1
a263 1
			fprintf( fp, "%d", stp1->s_index + 1 );
d271 1
a271 1
			fprintf( fp, "%d", stp1->s_index + 1 );
@


1.13
log
@updated RM_dump_descr() to dump s_scopes & related info.
@
text
@d245 3
a247 3
	fprintf( fp, "\tin       = " );
	if( stp->s_in ){
		stp1 = stp->s_in;
@


1.12
log
@added code to print s_proper field of STREL_T
@
text
@d262 9
@


1.11
log
@modified RM_dump_descr() to print value of new STREL_T field s_in.
@
text
@d237 3
@


1.10
log
@added code in RM_dump_descr() to print the special value UNBOUNDED (2^31-1)
as the string UNBOUNDED.
@
text
@d242 8
@


1.9
log
@print the values of the parts as is, except the the int val UNDEF get
printed as UNDEF.
@
text
@d256 2
d263 2
@


1.8
log
@added code to dump field p_dindex int RM_dump_pos().
@
text
@d255 1
a255 1
		fprintf( fp, "%d", 1 );
d260 1
a260 1
		fprintf( fp, "UNBOUNDED" );
d268 5
a272 1
	fprintf( fp, "\tmismatch = %d\n", stp->s_mismatch );
d275 5
a279 1
		fprintf( fp, "\tmispair  = %d\n", stp->s_mispair );
@


1.7
log
@added RM_dump_sites().
@
text
@d335 1
@


1.6
log
@added 1st version of RM_dump_pos
@
text
@d14 2
d20 1
d43 3
d281 1
a281 1
RM_dump_pos( fp, posp )
d283 1
d287 2
a288 1
	fprintf( fp, "\ttype     = " );
d332 2
a333 2
	fprintf( fp, "\tlineno   = %d\n", posp->p_lineno );
	fprintf( fp, "\ttag      = '%s'\n",
d335 26
a360 2
	fprintf( fp, "\tl2r      = %s\n", posp->p_l2r ? "TRUE" : "FALSE" );
	fprintf( fp, "\toffset   = %d\n", posp->p_offset );
@


1.5
log
@replaced LASTVAL with UNDEF.  Default maxlen is UNDEF which indicates
UNBOUNDED maxlen.
@
text
@d274 56
@


1.4
log
@dump the mates of a structure element.
@
text
@d248 2
a249 2
	if( stp->s_minlen == LASTVAL )
		fprintf( fp, "LASTVAL" );
d253 2
a254 2
	if( stp->s_maxlen == LASTVAL )
		fprintf( fp, "LASTVAL" );
@


1.3
log
@don't print mispair & pair info for type == ss as it is not meaningful.
split RM_dump_pairset() into RM_dump_pairset & RM_dump_pair().
@
text
@d183 2
d235 11
@


1.2
log
@added code to dump the value of a pairset.
@
text
@d16 1
d156 1
a156 5
			for( b = 0; b < pp->p_n_bases; b++ ){
				fprintf( stderr, "%c", pp->p_bases[ b ] );
				if( b < pp->p_n_bases - 1 )
					fprintf( stderr, ":" );
			}
d162 16
a177 1
} 
d251 2
a252 1
	fprintf( fp, "\tmispair  = %d\n", stp->s_mispair );
d254 4
a257 3
	fprintf( fp, "\tpair     = " );
	RM_dump_pairset( fp, stp->s_pairset );
	fprintf( fp, "\n" );
@


1.1
log
@Initial revision
@
text
@d15 1
a129 1
		fprintf( fp, "{ " );
d131 2
a132 10
		for( pp = ps->ps_pairs, i = 0; i < ps->ps_n_pairs; i++, pp++ ){
			for( b = 0; b < pp->p_n_bases; b++ ){
				fprintf( stderr, "%c", pp->p_bases[ b ] );
				if( b < pp->p_n_bases - 1 )
					fprintf( stderr, ":" );
			}
			if( i < ps->ps_n_pairs - 1 )
				fprintf( fp, ", " );
		}
		fprintf( fp, " }\n" );
d145 22
d240 4
@
