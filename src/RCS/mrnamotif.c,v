head	1.11;
access;
symbols;
locks; strict;
comment	@ * @;


1.11
date	2003.02.25.23.48.38;	author macke;	state Exp;
branches;
next	1.10;

1.10
date	2003.02.24.04.11.12;	author macke;	state Exp;
branches;
next	1.9;

1.9
date	2003.01.20.22.05.57;	author macke;	state Exp;
branches;
next	1.8;

1.8
date	2002.11.25.04.49.29;	author macke;	state Exp;
branches;
next	1.7;

1.7
date	2002.11.20.02.20.56;	author macke;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.07.18.11.15;	author macke;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.07.14.13.01;	author macke;	state Exp;
branches;
next	1.4;

1.4
date	2002.10.06.03.02.02;	author macke;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.26.20.03.28;	author macke;	state Exp;
branches;
next	1.2;

1.2
date	2002.09.13.17.44.13;	author macke;	state Exp;
branches;
next	1.1;

1.1
date	2002.09.10.03.22.17;	author macke;	state Exp;
branches;
next	;


desc
@MPI driver for rnamotif.
@


1.11
log
@added code to implement pre and/or post cmd inserted before/after
the actual rnamotif command.
pre command gets bot -fmt X and filename, post cmd gets no args
-pre causes rnamotif to read from stdin
@
text
@#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

#include "mpi.h"

#include "rmdefs.h"
#include "rnamot.h"
#include "fmap.h"

#define	MIN(a,b)	((a)<(b)?(a):(b))
#define	MAX(a,b)	((a)>(b)?(a):(b))

#define	MT_HOSTID	0
#define	MT_READY	1
#define	MT_RUN	 	2
#define	MT_RESULT	3
#define	MT_QUIT		4	/* sent from 0 -> 1,np-1	*/
#define	MT_ERROR	5	/* sent from 1,np-1 -> 0	*/

#define	GS_OFF		0
#define	GS_RUN_ZERO	1
#define	GS_RUN_ALL	2
#define	GS_ERROR	3

static	int	my_rank, n_proc, n_wproc;
static	char	hostname[ 256 ];
static	char	xhostname[ 256 ];

static	int	err;
static	char	emsg[ 1024 ];

static	char	**hosts;

#define	CMD_SIZE	1024
static	char	rncmd[ CMD_SIZE ];
static	int	s_rncmd;

static	char	*xdescr;
static	int	s_xdescr;
static	char	xdfname[ 256 ];	/* used only by r1..rnp-1	*/

static	FMAP_T	*fmap;

#define	JS_UNDEF	UNDEF
#define	JS_READY	0
#define	JS_RUNNING	1
#define	JS_DONE		2

typedef	struct	job_t	{
	struct	job_t	*j_next;	
	int	j_num;
} JOB_T;

typedef	struct	jobq_t	{
	JOB_T	*j_first;	
	JOB_T	*j_last;	
} JOBQ_T;

static	JOBQ_T	*jobqs;
static	int	n_jobqs;
static	int	*jobs;
static	int	*jidx;
static	int	s_jobs;
static	int	n_jobs;
static	int	*actjobs;

static	char	*sbuf;
static	int	s_sbuf;
static	int	rcnt, scnt;
static	char	*rbuf;
static	int	s_rbuf;

#define	WORK_SIZE	102400
static	char	work[ WORK_SIZE ];

ARGS_T	*RM_getargs( int, char *[], int );

static	int	all_init( void );
static	int	r0_init( int, char *[] );
static	FMAP_T	*get_fmap( ARGS_T * );
static	int	mk_commands( ARGS_T *,
	char [], char [], int*, char [], int *, char [] );
static	int	compile_descr( char *, int, char *, int, char * );
static	int	setup_jobs( ARGS_T *, FMAP_T * );
static	int	mk_jobqs( void );
static	int	qjob( int, int );
static	JOB_T	*dqjob( int );
static	int	r0_handle_msg( MPI_Status *, int * );
static	int	rn_handle_msg( MPI_Status *, int * );
static	int	rn_setup( char * );
static	int	rn_run( char * );
static	int	nextjob( int );
static	void	dumpjobs( FILE * );
static	void	dumpjidx( FILE *, char * );
static	void	dumpjqs( FILE *, char * );

char	*getenv();

main( int argc, char *argv[] )
{
	int	p, qbuf;
	int	gridstat = GS_OFF, done;
	MPI_Status	pstatus, rstatus;

	MPI_Init( &argc, &argv );
	MPI_Comm_rank( MPI_COMM_WORLD, &my_rank );
	MPI_Comm_size( MPI_COMM_WORLD, &n_proc );

	if( all_init() )
		err = 1;
	else if( my_rank == 0 ){
		gridstat = r0_init( argc, argv );
		s_sbuf = s_rncmd + s_xdescr;
	}

	/* If no error, then turn on the grid	*/
	MPI_Bcast( &gridstat, 1, MPI_INT, 0, MPI_COMM_WORLD );
	if( gridstat != GS_RUN_ALL ){
		if( gridstat == GS_ERROR )
			err = 1;
		goto CLEAN_UP;
	}

	MPI_Bcast( &s_sbuf, 1, MPI_INT, 0, MPI_COMM_WORLD );
	sbuf = ( char * )malloc( s_sbuf * sizeof( char ) );
	if( sbuf == NULL ){
		fprintf( stderr, "%s: can't allocate sbuf\n", xhostname );
		err = 1;
		goto CLEAN_UP;
	}

	if( my_rank == 0 ){
		strcpy( sbuf, rncmd );
		strcpy( &sbuf[ s_rncmd ], xdescr );
	}
	MPI_Bcast( sbuf, s_sbuf, MPI_CHAR, 0, MPI_COMM_WORLD );
	if( my_rank != 0 ){
		if( rn_setup( sbuf ) ){
			err = 1;
			goto CLEAN_UP;
		}
	}

	if( my_rank == 0 ){
		for( rcnt = 0, done = 0; !done; ){
			MPI_Probe( MPI_ANY_SOURCE, MPI_ANY_TAG,
				MPI_COMM_WORLD, &pstatus );

			if( r0_handle_msg( &pstatus, &done ) ){
				err = 1;
				goto CLEAN_UP;
			}
		}
	}else{
		while( !MPI_Probe( MPI_ANY_SOURCE, MPI_ANY_TAG,
			MPI_COMM_WORLD, &pstatus ) )
		{
			if( rn_handle_msg( &pstatus, &done ) ){
				err = 1;
				break;
			}
			if( done )
				break;
		}
	}

CLEAN_UP : ;

	if( my_rank == 0 ){
		if( gridstat == GS_RUN_ALL ){
			for( p = 1; p < n_proc; p++ ){
				qbuf = 0;
				MPI_Send( &qbuf, 1, MPI_INT,
					p, MT_QUIT, MPI_COMM_WORLD );
			}
		}
	}

	MPI_Finalize();

	exit( err );
}

static	int	all_init( void )
{
	int	p;
	char	*rhp, rhostname[ 256 ];
	MPI_Status	status;
	int	rval = 0;

	gethostname( hostname, sizeof( hostname ) );
	sprintf( xhostname, "%s_%d", hostname, my_rank );

	/* r0 is admin only, needs >= 1 other for work	*/
	if( n_proc < 2 ){
		fprintf( stderr,
			"%s: all_init: n_proc must be > 1\n", xhostname );
		rval = 1;
		goto CLEAN_UP;
	}else
		n_wproc = n_proc - 1;

	/* r0 needs the names of hosts in order to parcel out jobs	*/
	if( my_rank == 0 ){
		hosts = ( char ** )malloc( n_proc * sizeof( char * ) );
		if( hosts == NULL ){
			fprintf( stderr, "%s: all_init: can't allocate hosts\n",
				xhostname );
			rval = 1;
			goto CLEAN_UP;
		}
		hosts[ 0 ] = hostname;

		for( p = 1; p < n_proc; p++ ){
			MPI_Recv( rhostname, sizeof( rhostname ), MPI_CHAR,
				p, MT_HOSTID, MPI_COMM_WORLD, &status );
			rhp = strdup( rhostname );
			if( rhp == NULL ){
				fprintf( stderr,
			"%s: all_init: can't allocate rhp for host %s_%d\n",
					xhostname, rhostname, p );
				rval = 1;
				goto CLEAN_UP;
			}
			hosts[ p ] = rhp;
		}
	}else{
		MPI_Send( hostname, strlen( hostname ) + 1, MPI_CHAR,
			0, MT_HOSTID, MPI_COMM_WORLD );
	}

CLEAN_UP : ;

	return( rval );
}

static	int	r0_init( int argc, char *argv[] )
{
	ARGS_T	*args;
	char	r0cmd[ CMD_SIZE ];
	char	xdfname[ 256 ];
	int	xdfd;
	char	r0efname[ 256 ];
	int	r0efd;
	int	rval = GS_RUN_ALL;

	*xdfname = *r0efname = '\0';

	if( ( args = RM_getargs( argc, argv, TRUE ) ) == NULL ){
		rval = GS_ERROR;
		goto CLEAN_UP;
	}

	/* only get the file map if it's needed		*/
	if( !args->a_copt && !args->a_sopt && !args->a_vopt ){
		if( ( fmap = get_fmap( args ) ) == NULL ){
			rval = GS_ERROR;
			goto CLEAN_UP;
		}
	}

	rval = mk_commands( args,
		r0cmd, rncmd, &xdfd, xdfname, &r0efd, r0efname );

	if( rval == GS_ERROR )
		goto CLEAN_UP;

	if( compile_descr( r0cmd, xdfd, xdfname, r0efd, r0efname ) ){
		rval = GS_ERROR;
		goto CLEAN_UP;

	}

	if( rval == GS_RUN_ALL ){
		if( setup_jobs( args, fmap ) ){
			rval = GS_ERROR;
			goto CLEAN_UP;
		}
	}

CLEAN_UP : ;

	if( *xdfname )
		unlink( xdfname );
	if( *r0efname )
		unlink( r0efname );

	return( rval );
}

static	FMAP_T	*get_fmap( ARGS_T *args )
{
	FMAP_T	*fmap = NULL;
	int	fmt;
	int	err = 0;

	if( ( fmap = FMread_fmap( args->a_fmfname ) ) == NULL ){
		err = TRUE;
		goto CLEAN_UP;
	}
	if( !strcmp( fmap->f_format, DT_FASTN ) )
		args->a_dbfmt = DT_FASTN;
	else if( !strcmp( fmap->f_format, DT_PIR ) )
		args->a_dbfmt = DT_PIR;
	else if( !strcmp( fmap->f_format, DT_GENBANK ) )
		args->a_dbfmt = DT_GENBANK;
	else{
		fprintf( stderr, "%s: get_fmap: unknown format '%s'\n",
			xhostname, fmap->f_format );
		err = TRUE;
		goto CLEAN_UP;
	}

CLEAN_UP : ;

	if( err && fmap != NULL )
		fmap = FMfree_fmap( fmap );

	return( fmap );
}

static	int	mk_commands( ARGS_T *args, char r0cmd[], char rncmd[],
	int	*xdfd, char xdfname[], int *r0efd, char r0efname[] )
{
	char	*cp0, *cpn;
	INCDIR_T	*ip;
	char	*cdp, *e_cdp;
	int	rval = GS_RUN_ALL;

	*r0cmd = *rncmd = '\0';
	*xdfname = *r0efname = '\0';
	*xdfd = *r0efd = 0;

	cp0 = r0cmd;
	strcpy( cp0, "rnamotif" );
	cp0 += strlen( cp0 );

	/* these options produce information only; no compile; no run:	*/
	if( args->a_sopt ){
		strcpy( cp0, " -s" );
		cp0 += strlen( cp0 );
		rval = GS_RUN_ZERO;
	}
	if( args->a_vopt ){
		strcpy( cp0, " -v" );
		cp0 += strlen( cp0 );
		rval = GS_RUN_ZERO;
	}
	if( args->a_copt )
		rval = GS_RUN_ZERO;

	/* options used on r0:	*/
	strcpy( cp0, " -c" );
	cp0 += strlen( cp0 );
	if( args->a_dopt ){
		strcpy( cp0, " -d" );
		cp0 += strlen( cp0 );
	}
	if( args->a_hopt ){
		strcpy( cp0, " -h" );
		cp0 += strlen( cp0 );
	}
	sprintf( cp0, " -O%g", args->a_o_emin );
	cp0 += strlen( cp0 );
	if( args->a_popt ){
		strcpy( cp0, " -p" );
		cp0 += strlen( cp0 );
	}
	if( args->a_show_context ){
		strcpy( cp0, " -context" );
		cp0 += strlen( cp0 );
	}
	if( args->a_strict_helices ){
		strcpy( cp0, " -sh" );
		cp0 += strlen( cp0 );
	}
	for( ip = args->a_idlist; ip; ip = ip->i_next ){
		sprintf( cp0, " -I%s", ip->i_name );
		cp0 += strlen( cp0 );
	}
	for( cdp = args->a_cldefs; cdp && *cdp;  cdp = e_cdp + 2 ){
		e_cdp = strchr( cdp, ';' );
		sprintf( cp0, " -D%.*s", e_cdp - cdp, cdp );
		cp0 += strlen( cp0 );
	}
	if( !args->a_sopt && !args->a_vopt ){
		if( args->a_dfname == NULL ){
			return( GS_ERROR );
		}else{
			sprintf( cp0, " -descr %s", args->a_dfname );
			cp0 += strlen( cp0 );
		}
		if( args->a_xdfname != NULL ){
			return( GS_ERROR );
		}else{
			strcpy( xdfname, "/tmp/rmxdf_XXXXXX" );
			*xdfd = mkstemp( xdfname );
			sprintf( cp0, " -xdfname %s", xdfname );
			cp0 += strlen( cp0 );
		}
	}
	strcpy( r0efname, "/tmp/rmr0ef_XXXXXX" );
	*r0efd = mkstemp( r0efname );
	sprintf( cp0, " >& %s", r0efname );

	if( rval == GS_RUN_ZERO )
		return( rval );

	/* options used on rn:	*/
	cpn = rncmd;
	if( args->a_precmd != NULL ){
		strcpy( cpn, args->a_precmd );
		cpn += strlen( cpn );
		if( !strcmp( args->a_dbfmt, DT_FASTN ) )
			sprintf( cpn, " %s", DT_FASTN );
		else if( !strcmp( args->a_dbfmt, DT_PIR ) )
			sprintf( cpn, " %s", DT_PIR );
		else 
			sprintf( cpn, " %s", DT_GENBANK );
		cpn += strlen( cpn );
		strcpy( cpn, " %s | " );
		cpn += strlen( cpn );
	}
	strcpy( cpn, "rnamotif" );
	cpn += strlen( cpn );

	sprintf( cpn, " -O%g", args->a_o_emin );
	cpn += strlen( cpn );
	if( args->a_show_context ){
		strcpy( cpn, " -context" );
		cpn += strlen( cpn );
	}
	if( args->a_strict_helices ){
		strcpy( cpn, " -sh" );
		cpn += strlen( cpn );
	}
	strcpy( cpn, " -xdescr %s 2> /dev/null" );
	cpn += strlen( cpn );
	strcpy( cpn, " -fmt" );
	cpn += strlen( cpn );
	if( !strcmp( args->a_dbfmt, DT_FASTN ) )
		sprintf( cpn, " %s", DT_FASTN );
	else if( !strcmp( args->a_dbfmt, DT_PIR ) )
		sprintf( cpn, " %s", DT_PIR );
	else 
		sprintf( cpn, " %s", DT_GENBANK );
	cpn += strlen( cpn );
	if( args->a_precmd == NULL ){
		strcpy( cpn, " %s" );
		cpn += strlen( cpn );
	}
	if( args->a_postcmd != NULL ){
		sprintf( cpn, " | %s", args->a_postcmd );
		cpn += strlen( cpn );
	}

	s_rncmd = strlen( rncmd ) + 1;

	return( rval );
}

static	int	compile_descr( char *r0cmd,
	int xdfd, char *xdfname, int r0efd, char *r0efname )
{
	FILE	*fp = NULL;
	char	line[ 256 ];
	int	lcnt;
	int	cdlmsg;
	struct	stat	sbuf;

	system( r0cmd );

	if( ( fp = fdopen( r0efd, "r" ) ) == NULL ){
		fprintf( stderr,
			"%s: r0_init: can't read compile step errfile %s\n",
			xhostname, r0efname );
		return( 1 );
	}
	for( cdlmsg = 0, lcnt = 0; fgets( line, sizeof( line ), fp ); lcnt++ ){
		if( strstr( line, ": complete descr length: min/max = " ) )
			cdlmsg = TRUE;
		fputs( line, stderr );
	}
	fclose( fp );
	fp = NULL;
	if( lcnt > 1 || !cdlmsg )
		return( 1 );

	fstat( xdfd, &sbuf );
	s_xdescr = sbuf.st_size + 1;
	xdescr = ( char * )malloc( s_xdescr * sizeof( char * ) );
	if( xdescr == NULL ){
		fprintf( stderr, "%s: r0_init: can't allocate xdescr\n",
			xhostname );
		return( 1 );
	}
	fp = fdopen( xdfd, "r" );
	fread( xdescr, sizeof( char ), ( long )( s_xdescr - 1 ), fp );
	xdescr[ s_xdescr - 1 ] = '\0';
	fclose( fp );
	fp = NULL;

	return( 0 );
}

static	int	setup_jobs( ARGS_T *args, FMAP_T *fmap )
{
	int	*active = NULL;
	int	i, j, ji, h;
	char	*dp, *pp, *pc, *pd;
	int	dlen;
	char	dname[ 256 ];
	FM_ENTRY_T	*fme;
	int	p, p1, pcnt, pl, ph;
	char	range[ 256 ];
	int	err = 0;

	s_jobs = fmap->f_nentries;
	jobs = ( int * )calloc( ( long )s_jobs, sizeof( int ) );
	if( jobs == NULL ){
		fprintf( stderr, "%s: setup_jobs: can't allocate jobs\n",
			xhostname );
		err = TRUE;
		goto CLEAN_UP;
	}
	for( i = 0; i < s_jobs; i++ )
		jobs[ i ] = JS_UNDEF;

	active = ( int * )calloc( ( s_jobs ), sizeof( int ) );
	if( active == NULL ){
		fprintf( stderr, "%s: setup_jobs: can't allocate active\n",
			xhostname );
		err = TRUE;
		goto CLEAN_UP;
	}

	actjobs = ( int * )malloc( n_proc * sizeof( int ) );
	if( actjobs == NULL ){
		fprintf( stderr, "%s: setup_jobs: can't allocate actjobs\n",
			xhostname );
		err = TRUE;
		goto CLEAN_UP;
	}
	for( i = 0; i < n_proc; i++ )
		actjobs[ i ] = UNDEF;

	if( args->a_n_dbfname == 0 ){
		for( j = 0; j < s_jobs; j++ )
			jobs[ j ] = JS_READY; 
		n_jobs = s_jobs;
	}else{
		for( i = 0; i < args->a_n_dbfname; i++ ){
			if( FMmark_active(fmap, args->a_dbfname[ i ], active) ){
				err = TRUE;
				goto CLEAN_UP;
			}
		}
		for( n_jobs = 0, i = 0; i < s_jobs; i++ ){
			if( active[ i ] ){
				jobs[ i ] = JS_READY;
				n_jobs++;
			}
		}
	}

	jidx = ( int * )malloc( n_jobs * sizeof( int ) );
	if( jidx == NULL ){
		fprintf( stderr, "%s: setup_jobs: can't allocate jidx\n",
			xhostname );
		err = TRUE;
		goto CLEAN_UP;
	}
	for( j = i = 0; i < s_jobs; i++ ){
		if( jobs[ i ] == JS_READY ){
			jidx[ j ] = i;
			j++;
		}
	}

	if( mk_jobqs() ){
		err = TRUE;
		goto CLEAN_UP;
	}

CLEAN_UP : ;

	if( active != NULL ){
		free( active );
		active = NULL;
	}

	return( err );
}

static	int	mk_jobqs( void )
{
	int	j, ji, h;
	int	needqs;
	FM_ENTRY_T	*fme;
	int	err = 0;

	for( needqs = 0, j = 0; j < n_jobs; j++ ){
		ji =  jidx[ j ];
		fme = &fmap->f_entries[ ji ];
		if( fme->f_hosts != NULL ){
			needqs = TRUE;
			break;
		}
	}
	if( !needqs )
		return( err );

	n_jobqs = n_proc;	/* jobqs[0] is not used	*/
	jobqs = ( JOBQ_T * )calloc( ( long )n_jobqs, sizeof( JOBQ_T ) );
	if( jobqs == NULL ){
		fprintf( stderr, "%s: mk_jobqs: can't allocate jobqs\n",
			xhostname );
		err = TRUE;
		goto CLEAN_UP;
	}

	for( j = 0; j < n_jobs; j++ ){
		ji =  jidx[ j ];
		fme = &fmap->f_entries[ ji ];
		for( h = 1; h < n_proc; h++ ){
			if( strstr( fme->f_hosts, hosts[ h ] ) ){
				if( qjob( h, ji ) ){
					err = TRUE;
					goto CLEAN_UP;
				}
			}
		}
	}

CLEAN_UP : ;

	return( err );
}

static	int	qjob( int qnum, int jnum )
{
	FM_ENTRY_T	*fme;
	JOB_T	*jp;
	JOBQ_T	*jqp;

	jp = ( JOB_T * )malloc( sizeof( JOB_T ) );
	if( jp == NULL )
		return( 1 );
	jp->j_next = NULL;
	jp->j_num = jnum;
	jqp = &jobqs[ qnum ];
	if( jqp->j_first == NULL )
		jqp->j_first = jp;
	else
		jqp->j_last->j_next = jp;
	jqp->j_last = jp;
	return( 0 );
}

static	JOB_T	*dqjob( int qnum )
{
	JOB_T	*jp;

	jp = jobqs[ qnum ].j_first;
	if( jp != NULL ){
		jobqs[ qnum ].j_first = jp->j_next;
		if( jp->j_next == NULL )
			jobqs[ qnum ].j_last = NULL;
	}
	return( jp );
}

static	int	r0_handle_msg( MPI_Status *pstatus, int *done )
{
	char	sbuf[ 256 ];
	MPI_Status	rstatus;
	int	ibuf;
	int	s, j;
	int	rval = 0;

	*done = 0;
	switch( pstatus->MPI_TAG ){
	case MT_READY :
		rcnt++;

fprintf( stderr, "%s: READY: %s_%d: rcnt = %d\n",
	xhostname, hosts[ pstatus->MPI_SOURCE ], pstatus->MPI_SOURCE, rcnt );

		MPI_Recv( &ibuf, 1, MPI_INT, pstatus->MPI_SOURCE,
			MT_READY, MPI_COMM_WORLD, &rstatus );

		s = pstatus->MPI_SOURCE;
		j = actjobs[ s ];
		if( j != UNDEF ){
			jobs[ j ] = JS_DONE;
			actjobs[ s ] = UNDEF;
		}

		if( rcnt >= n_wproc + n_jobs ){
			*done = TRUE;
		}
		if( scnt < n_jobs ){

			if( ( j = nextjob( s ) ) == UNDEF )
				break;

			sprintf( sbuf, "%s/%s", fmap->f_root,
				fmap->f_entries[ j ].f_fname );
			jobs[ j ] = JS_RUNNING;
			actjobs[ s ] = j;

fprintf( stderr, "%s: RUN: search '%s' on %s_%d\n", xhostname, sbuf,
	hosts[ pstatus->MPI_SOURCE ], pstatus->MPI_SOURCE );

			MPI_Send( sbuf, strlen( sbuf ) + 1, MPI_CHAR,
				pstatus->MPI_SOURCE, MT_RUN, MPI_COMM_WORLD );
			scnt++;
		}
		break;
	case MT_RESULT :
		MPI_Recv( work, sizeof( work ), MPI_CHAR,
			pstatus->MPI_SOURCE,
			MT_RESULT, MPI_COMM_WORLD, &rstatus );
		fputs( work, stdout );
		break;

	default :
		fprintf( stderr,
			"%s: r0_handle_msg: unexpected mesg tag %d\n",
			pstatus->MPI_TAG );
		rval = 1;
		break;
	}

	return( rval );
}

static	int	rn_handle_msg( MPI_Status *pstatus, int *done )
{
	int	count;
	MPI_Status	rstatus;
	int	rval = 0;

	*done = 0;
	switch( pstatus->MPI_TAG ){
	case MT_RUN :
		MPI_Get_count( pstatus, MPI_CHAR, &count );
		if( count > s_rbuf ){
			if( rbuf != NULL )
				free( rbuf );
			s_rbuf = count;
			rbuf = ( char * )malloc( s_rbuf * sizeof( char ) );
			if( rbuf == NULL ){
				rval = 1;
				break;
			}
		}
		MPI_Recv( rbuf, s_rbuf, MPI_CHAR, 0,
			pstatus->MPI_TAG, MPI_COMM_WORLD, &rstatus );
		if( rn_run( rbuf ) ){
			rval = 1;
			break;
		}
		break;

	case MT_QUIT :
		if( *xdfname )
			unlink( xdfname );
		*done = TRUE;
		break;

	default :
		fprintf( stderr,
			"%s: rn_handle_msg: unexpected mesg tag %d\n",
			pstatus->MPI_TAG );
		rval = 1;
		break;
	}

	return( rval );
}

static	int	rn_setup( char *rbuf )
{
	char	*rp, *rp1;
	int	s_rncmd, s_xdescr;
	int	xdfd;
	FILE	*xdfp = NULL;
	int	ibuf;
	int	rval = 0;

	for( rp = rbuf; *rp; rp++ )
		;
	s_rncmd = rp - rbuf + 1;
	strcpy( rncmd, rbuf );

	for( rp1 = ++rp; *rp1; rp1++ )
		;
	s_xdescr = rp1 - rp + 1;
	xdescr = ( char * )malloc( s_xdescr * sizeof( char ) );
	if( xdescr == NULL ){
		rval = 1;
		goto CLEAN_UP;
	}
	strcpy( xdescr, rp );

	strcpy( xdfname, "/tmp/rmxdf_XXXXXX" );
	xdfd = mkstemp( xdfname );
	if( ( xdfp = fdopen( xdfd, "w" ) ) == NULL ){
		rval = 1;
		goto CLEAN_UP;
	}
	fwrite( xdescr, sizeof( char ), ( long )( s_xdescr - 1 ), xdfp );
	fclose( xdfp );
	xdfp = NULL;

	ibuf = 0;
	MPI_Send( &ibuf, 1, MPI_INT, 0, MT_READY, MPI_COMM_WORLD );

CLEAN_UP : ;

	if( xdfp != NULL ){
		fclose( xdfp );
		xdfp = NULL;
	}
	if( rval == 1 ){
		if( *xdfname )
			unlink( xdfname );
	}

	return( rval );
}

static	int	rn_run( char *fname )
{
	char	dbfname[ 256 ];
	char	*wp, *cp, cmd[ 1024 ];
	FILE	*fp = NULL;
	char	line[ 10240 ];
	int	ibuf;
	int	rval = 0;

	sprintf( cmd, rncmd, xdfname, fname );

	if( ( fp = popen( cmd, "r" ) ) == NULL ){
		fprintf( stderr, "%s: popen failed\n", xhostname );
		rval = 1;
		goto CLEAN_UP;
	}
	for( wp = work; fgets( line, sizeof( line ), fp ); ){
		strcpy( wp, line );
		wp += strlen( line );
		fgets( line, sizeof( line ), fp );
		strcpy( wp, line );
		wp += strlen( line );
		if( wp - work > .95 * WORK_SIZE ){
			MPI_Send( work, strlen( work ) + 1, MPI_CHAR,
				0, MT_RESULT, MPI_COMM_WORLD );
			wp = work;
		}
	}
	if( wp > work ){
		MPI_Send( work, strlen( work ) + 1, MPI_CHAR,
			0, MT_RESULT, MPI_COMM_WORLD );
		wp = work;
	}
	pclose( fp );
	fp = NULL;

	ibuf = 0;
	MPI_Send( &ibuf, 1, MPI_INT, 0, MT_READY, MPI_COMM_WORLD );

CLEAN_UP : ;

	if( fp != NULL ){
		pclose( fp );
		fp = NULL;
	}

	return( rval );
}

static	int	nextjob( int s )
{
	JOB_T	*jp = NULL;
	int	j, nj;

	if( jobqs == NULL ){
		nj = jidx[ scnt ];
	}else{
		for( nj = UNDEF; jobqs[ s ].j_first; ){
			jp = dqjob( s );
			j = jp->j_num;
			free( jp );
			if( jobs[ j ] == JS_READY ){
				nj = j;
				break;
			}
		}
	}
	return( nj );
}

static	void	dumpjobs( FILE *fp )
{
	int	ji, j;

	fprintf( fp, "%s: %d jobs\n", xhostname, n_jobs );
	for( ji = 0; ji < n_jobs; ji++ ){
		j = jidx[ ji ];
		fprintf( fp, "%s: job[%3d] = fme[%3d] = %s:%d\n",
			xhostname, ji, j, fmap->f_entries[ j ].f_dname,
			fmap->f_entries[ j ].f_part );
	}
}

static	void	dumpjidx( FILE *fp, char *msg )
{
	int	j;

	fprintf( fp, "jidx: %d entries: %s\n", n_jobs, msg );
	for( j = 0; j < n_jobs; j++ ){
		fprintf( fp, "jidx[%3d] = %3s, status = %d\n",
			j, fmap->f_entries[ jidx[ j ] ].f_fname,
			jobs[ jidx[ j ] ] );
	}
}

static	void	dumpjqs( FILE *fp, char *msg )
{
	int	p;
	JOB_T	*jp;

	fprintf( fp, "%d jobqs: %s\n", n_proc, msg );
	for( p = 1; p < n_proc; p++ ){
		fprintf( fp, "jobsq['%s']:\n", hosts[p] );
		for( jp = jobqs[ p ].j_first; jp; jp = jp->j_next ){
			fprintf( fp, "\t%s %d\n",
				fmap->f_entries[ jp->j_num ].f_fname,
				jobs[ jp->j_num ] );
		}
	}
}
@


1.10
log
@improved logic to allow all serial switches, -v, -s and -c to be used
from the mrnamotif cmd.  The array still gets started, but for -v, -s
no work is done (not even compile) and for -c only compile is done.
No files need be specified for any of -v, -s, -c.  No descr is required
for -v, -s.
@
text
@d415 13
d452 8
a459 2
	strcpy( cpn, " %s" );
	cpn += strlen( cpn );
@


1.9
log
@better control over the grid.  Start the grid only if all the ini
(initialization) works.  Simpler MT scheme
@
text
@d24 5
d80 1
a80 1
ARGS_T	*RM_getargs( int, char *[] );
d83 1
a83 1
static	int	r0_init( int, char *[], int, char [] );
d106 1
a106 1
	int	gridon = 0, done;
d116 2
a117 6
		if( r0_init( argc, argv, CMD_SIZE, rncmd ) )
			err = 1;
		else{
			s_sbuf = s_rncmd + s_xdescr;
			gridon = 1;
		}
d121 4
a124 3
	MPI_Bcast( &gridon, 1, MPI_INT, 0, MPI_COMM_WORLD );
	if( !gridon ){
		err = 1;
d174 1
a174 1
		if( gridon ){
d241 1
a241 1
static	int	r0_init( int argc, char *argv[], int s_rncmd, char rncmd[] )
d249 1
d253 2
a254 2
	if( ( args = RM_getargs( argc, argv ) ) == NULL ){
		err = 1;
d258 6
a263 3
	if( ( fmap = get_fmap( args ) ) == NULL ){
		err = 1;
		goto CLEAN_UP;
d266 4
a269 4
	if( mk_commands( args,
		r0cmd, rncmd, &xdfd, xdfname, &r0efd, r0efname ) )
	{
		err = 1;
a270 1
	}
d273 1
a273 1
		err = 1;
d275 1
d278 5
a282 3
	if( setup_jobs( args, fmap ) ){
		err = 1;
		goto CLEAN_UP;
d292 1
a292 1
	return( err );
d302 1
a302 1
		err = 1;
a304 1

d314 1
a314 1
		err = 1;
a329 1
	int	done = FALSE;
d332 1
d346 1
a346 1
		done = TRUE;
d351 1
a351 1
		done = TRUE;
d353 2
a354 2
	if( done )
		return( 0 );
d390 15
a404 13
	if( args->a_dfname == NULL ){
		return( 1 );
	}else{
		sprintf( cp0, " -descr %s", args->a_dfname );
		cp0 += strlen( cp0 );
	}
	if( args->a_xdfname != NULL ){
		return( 1 );
	}else{
		strcpy( xdfname, "/tmp/rmxdf_XXXXXX" );
		*xdfd = mkstemp( xdfname );
		sprintf( cp0, " -xdfname %s", xdfname );
		cp0 += strlen( cp0 );
d410 2
a411 2
	if( args->a_copt )
		return( 0 );
d444 1
a444 1
	return( 0 );
d466 1
a466 1
			cdlmsg = 1;
d508 1
a508 1
		err = 1;
d518 1
a518 1
		err = 1;
d526 1
a526 1
		err = 1;
d539 1
a539 1
				err = 1;
d555 1
a555 1
		err = 1;
d566 1
a566 1
		err = 1;
d591 1
a591 1
			needqs = 1;
d603 1
a603 1
		err = 1;
d613 1
a613 1
					err = 1;
d685 1
a685 1
			*done = 1;
d754 1
a754 1
		*done = 1;
a801 4
/*
	*work = '\0';
	MPI_Send( work, 1, MPI_CHAR, 0, MT_READY, MPI_COMM_WORLD );
*/
@


1.8
log
@incorrect termination condition on rank==0 process.  Forget
to set n_wproc, the #worker CPUs so the the boss quit early
@
text
@d17 6
a22 8
#define	MT_GETHOSTID	0
#define	MT_HOSTID	1
#define	MT_SETUP	2
#define	MT_RUN	 	3
#define	MT_READY	4
#define	MT_RESULT	5
#define	MT_QUIT		6	/* sent from 0 -> 1,np-1	*/
#define	MT_ERROR	7	/* sent from 1,np-1 -> 0	*/
d30 2
a31 1
static	int	err;
a39 1
static	char	**hosts;
a65 1
static	int	qbuf;
d87 2
a88 2
static	int	r0_handle_msg( MPI_Status * );
static	int	rn_handle_msg( MPI_Status * );
d100 2
a101 1
	int	p;
d108 1
a108 5
	gethostname( hostname, sizeof( hostname ) );
	sprintf( xhostname, "%s_%d", hostname, my_rank );

	if( n_proc < 2 ){
		fprintf( stderr, "%s: n_proc must be > 1\n", xhostname );
d110 8
a117 3
		goto CLEAN_UP;
	}else
		n_wproc = n_proc - 1;
d119 3
a121 1
	if( all_init() ){
a125 11
	if( my_rank == 0 ){
		if( r0_init( argc, argv, CMD_SIZE, rncmd ) ){
			err = 1;
			goto CLEAN_UP;
		}
		s_sbuf = s_rncmd + s_xdescr;

fprintf( stderr, "%s: n_jobs = %d\n", xhostname, n_jobs );

	}

d147 1
a147 1
		for( rcnt = 0; ; ){
d151 1
a151 1
			if( r0_handle_msg( &pstatus ) ){
d160 1
a160 1
			if( rn_handle_msg( &pstatus ) ){
d164 2
d172 6
a177 4
		for( p = 1; p < n_proc; p++ ){
			qbuf = -1;
			MPI_Send( &qbuf, 1, MPI_INT,
				p, MT_QUIT, MPI_COMM_WORLD );
d188 2
a189 2
	int	p, buf = 0;
	char	*hp, hname[ 256 ];
d193 13
d214 1
a214 10

		hp = strdup( hostname );
		if( hp == NULL ){
			fprintf( stderr,
				"%s: all_init: can't allocate hp for %s_%d\n",
				xhostname, hostname, 0 );
			rval = 1;
			goto CLEAN_UP;
		}
		hosts[ 0 ] = hp;
d217 1
a217 3
			MPI_Send( &buf, 1, MPI_INT,
				p, MT_GETHOSTID, MPI_COMM_WORLD );
			MPI_Recv( hname, sizeof( hname ), MPI_CHAR,
d219 2
a220 2
			hp = strdup( hname );
			if( hp == NULL ){
d222 2
a223 2
			"%s: all_init: can't allocate hp for host %s_%d\n",
					hname, p );
d227 1
a227 1
			hosts[ p ] = hp;
a229 2
		MPI_Recv( &buf, 1, MPI_INT,
			0, MT_GETHOSTID, MPI_COMM_WORLD, &status );
d649 1
a649 1
static	int	r0_handle_msg( MPI_Status *pstatus )
d653 1
a653 1
	int	count;
d657 1
a657 2
	/* expect MT_READY, MT_RESULT, MT_ERROR	*/

d660 1
a660 21
	case MT_ERROR :
		MPI_Get_count( pstatus, MPI_CHAR, &count );
		if( count > s_rbuf ){
			if( rbuf != NULL )
				free( rbuf );
			s_rbuf = count;
			rbuf = ( char * )malloc( s_rbuf * sizeof( char ) );
			if( rbuf == NULL ){
				fprintf( stderr,
				"%s: r0_handle_msg: can't allocate rbuf\n",
					xhostname );
				rval = 1;
				break;
			}
		}
		MPI_Recv( rbuf, s_rbuf, MPI_CHAR,
			pstatus->MPI_SOURCE,
			pstatus->MPI_TAG, MPI_COMM_WORLD, &rstatus );

		if( pstatus->MPI_TAG == MT_READY ){
			rcnt++;
d665 14
a678 6
			s = pstatus->MPI_SOURCE;
			j = actjobs[ s ];
			if( j != UNDEF ){
				jobs[ j ] = JS_DONE;
				actjobs[ s ] = UNDEF;
			}
d680 1
a680 2
			if( rcnt >= n_wproc + n_jobs ){
				rval = 1;
a681 2
			}
			if( scnt < n_jobs ){
d683 4
a686 2
				if( ( j = nextjob( s ) ) == UNDEF )
					break;
a687 5
				sprintf( sbuf, "%s/%s", fmap->f_root,
					fmap->f_entries[ j ].f_fname );
				jobs[ j ] = JS_RUNNING;
				actjobs[ s ] = j;

d691 3
a693 10
				scnt++;
				MPI_Send( sbuf, strlen( sbuf ) + 1, MPI_CHAR,
					pstatus->MPI_SOURCE,
					MT_RUN, MPI_COMM_WORLD );
			}
		}else{

fprintf( stderr, "%s: ERROR: %s\n", xhostname, rbuf );

			rval = 1;
a694 1

a696 1

a702 3
	case MT_SETUP :
	case MT_RUN :
	case MT_QUIT :
d714 1
a714 1
static	int	rn_handle_msg( MPI_Status *pstatus )
d720 1
a720 2
	/* expect MT_SETUP, MT_RUN, MT_QUIT	*/

a721 26
	case MT_QUIT :
		if( *xdfname )
			unlink( xdfname );
		rval = 1;
		break;
/*
	case MT_SETUP :
		MPI_Get_count( pstatus, MPI_CHAR, &count );
		if( count > s_rbuf ){
			if( rbuf != NULL )
				free( rbuf );
			s_rbuf = count;
			rbuf = ( char * )malloc( s_rbuf * sizeof( char ) );
			if( rbuf == NULL ){
				rval = 1;
				break;
			}
		}
		MPI_Recv( rbuf, s_rbuf, MPI_CHAR, 0,
			pstatus->MPI_TAG, MPI_COMM_WORLD, &rstatus );
		if( rn_setup( rbuf ) ){
			rval = 1;
			break;
		}
		break;
*/
d742 6
a747 4
	case MT_SETUP :
	case MT_RESULT :
	case MT_READY :
	case MT_ERROR :
d749 4
a752 1
		rval = 1;	/* create errmsg, send back to 0 */
d765 1
d793 1
d796 3
d820 1
d850 2
a851 2
	MPI_Send( cmd, strlen( cmd ) + 1, MPI_CHAR,
		0, MT_READY, MPI_COMM_WORLD );
@


1.7
log
@made the result buffer 10K instead of 256 so as to avoid splitting
a result.
fixed off by 1 error in the job count .
@
text
@d26 1
a26 1
static	int	my_rank, n_proc, n_aproc;
d117 2
a118 1
	}
d131 3
d699 1
a699 1
			if( rcnt > n_aproc + n_jobs ){
@


1.6
log
@using incorrect termination condition for the r0_handle_msg.  Fixed.
@
text
@d26 1
a26 1
static	int	my_rank, n_proc, n_wproc;
d113 1
a113 1
	if( n_proc < 1 ){
a117 1
	n_wproc = n_proc - 1;
d695 1
a695 1
			if( rcnt >= n_wproc + n_jobs ){
d869 1
a869 1
	char	line[ 256 ];
@


1.5
log
@Set up jobs via MPI_Bcast() instead of using MPI_Send().
@
text
@d26 1
a26 1
static	int	my_rank, n_proc, n_aproc;
d113 1
a113 1
	if( n_proc < 2 ){
d118 1
d696 1
a696 1
			if( rcnt > n_aproc + n_jobs ){
@


1.4
log
@redid setup_jobs() as the parsing of db-elements is now done by
FMmark_active().
@
text
@d111 1
a111 1
	sprintf( xhostname, "%s[%d]", hostname, my_rank );
d130 17
a146 4
		sbuf = ( char * )malloc( s_sbuf * sizeof( char ) );
		if( sbuf == NULL ){
			fprintf( stderr, "%s: can't allocate sbuf\n",
				xhostname );
d150 1
a150 3
		strcpy( sbuf, rncmd );
		strcpy( &sbuf[ s_rncmd ], xdescr );
		n_aproc = MIN( n_proc - 1, n_jobs );
d152 1
a152 4
		for( scnt = 0, p = 1; p <= n_aproc; p++ ){
			MPI_Send( sbuf, s_sbuf, MPI_CHAR, p,
				MT_SETUP, MPI_COMM_WORLD );
		}
a180 5
/*
	}else if( err ){
		MPI_Send( emsg, strlen( emsg ) + 1, MPI_CHAR,
			0, MT_ERROR, MPI_COMM_WORLD );
*/
d695 1
a695 1
			if( rcnt >= n_aproc + n_jobs ){
d761 1
d781 1
d802 1
@


1.3
log
@fixed rncmd to use -xdescr (correct) instead of -xdfname (wrong, but
works.)  Also send the stderr of the remote cmd to /dev/null.
@
text
@a89 1
static	int	setrange( char *, int *, int *, int );
a94 1
static	void	errmsg( char * );
d114 1
a114 2
		sprintf( emsg, "n_proc must be > 1" );
		errmsg( emsg );
d132 2
a133 1
			errmsg( "can't allocate sbuf" );
d173 1
d177 1
d195 2
a196 1
			errmsg( "all_init: can't allocate hosts" );
d203 3
a205 4
			sprintf( emsg,
				"all_init: can't allocate hp for host %s[%d]",
				hostname, p );
			errmsg( emsg );
d218 2
a219 2
				sprintf( emsg,
				"all_init: can't allocate hp for host %s[%d]",
a220 1
				errmsg( emsg );
d304 2
a305 3
		sprintf( emsg, "get_fmap: unknown format '%s'",
			fmap->f_format );
		errmsg( emsg );
d449 3
a451 3
		sprintf( emsg, "r0_init: can't read compile step errfile %s",
			r0efname );
		errmsg( emsg );
d468 2
a469 2
		sprintf( emsg, "r0_init: can't allocate xdescr" );
		errmsg( emsg );
d483 1
a492 6
	if( args->a_n_dbfname == 0 ){
		errmsg( "setup_jobs: named db file(s) required" );
		err = 1;
		goto CLEAN_UP;
	}

d496 2
a497 1
		errmsg( "setup_jobs: can't allocate jobs" );
d504 8
d514 2
a515 1
		errmsg( "setup_jobs: can't allocate actjobs" );
d527 2
a528 19
		for( n_jobs = 0, i = 0; i < args->a_n_dbfname; i++ ){
			dp = args->a_dbfname[ i ];
			if( pp = strchr( dp, ':' ) ){
				strncpy( dname, dp, pp - dp );
				dname[ pp - dp ] = '\0';
			}else
				strcpy( dname, dp );

			if( !strcmp( dname, "all" ) ){
				for( j = 0; j < s_jobs; j++ )
					jobs[ j ] = JS_READY; 
				n_jobs = s_jobs;
				break;
			}

			if(( fme=FMget_fmentry( fmap, dname, UNDEF )) == NULL){
				sprintf( emsg, "setup_jobs: unknown db '%s'",
					dp );
				errmsg( emsg );
d532 5
a536 38

			for( pcnt = 0, p1 = p = fme - fmap->f_entries; ; ){
				pcnt++;
				if( p == fmap->f_nentries - 1 )
					break;
				p++;
				fme++;
				if( strcmp( fme->f_dname, dname ) )
					break;
			}

			if( pp == NULL || pp[1] == '\0' ){
				for( p = 0; p < pcnt; p++ ){
					if( jobs[ p1 + p ] == JS_UNDEF ){
						jobs[ p1 + p ] = JS_READY;
						n_jobs++;
					}
				}
				continue;
			}

			for( ++pp; pp && *pp; ){
				if( pc = strchr( pp, ',' ) ){
					strncpy( range, pp, pc - pp );
					range[ pc - pp ] = '\0';
					pp = pc + 1;
				}else{
					strcpy( range, pp );
					pp = pc;
				}
				if( setrange( range, &pl, &ph, pcnt ) )
					return( 1 );
				for( p = pl - 1; p < ph; p++ ){
					if( jobs[ p1 + p ] == JS_UNDEF ){
						jobs[ p1 + p ] = JS_READY;
						n_jobs++;
					}
				}
d543 2
a544 2
		sprintf( emsg, "setup_jobs: can't allocate jidx" );
		errmsg( emsg );
d562 5
d591 2
a592 1
		errmsg( "mk_jobqs: can't allocate jobqs" );
a647 38
static	int	setrange( char *range, int *pl, int *ph, int pcnt )
{
	char	*rp;
	int	rng;

	rng = 0;
	rp = range;
	if( !isdigit( *rp ) && *rp != '-' ){
		errmsg( "setrange: SYNTAX: N, N-M, N-, -M, -" );
		return( 1 );
	}
	for( *pl = 0; isdigit( *rp ); rp++ )
		*pl = 10 * *pl + *rp - '0';
	if( *pl == 0 )
		*pl = 1;
	if( *rp == '-' ){
		rp++;
		rng = 1;
	}
	for( *ph = 0; isdigit( *rp ); rp++ )
		*ph = 10 * *ph + *rp - '0';
	if( *rp != '\0' ){
		errmsg( "setrange: SYNTAX: extra chars" );
		return( 1 );
	}
	if( *ph == 0 )
		*ph = rng ? pcnt : *pl;
	if( *ph > pcnt )
		*ph = pcnt;
	if( *ph < *pl ){
		sprintf( emsg, "setrange: low (%d) > hi (%d)", *pl, *ph );
		errmsg( emsg );
		return( 1 );
	}

	return( 0 );
}

d668 3
a670 1
				errmsg( "can't allocate rbuf" );
d682 2
a683 3
sprintf( emsg, "READY: %s[%d]: rcnt = %d",
	hosts[ pstatus->MPI_SOURCE ], pstatus->MPI_SOURCE, rcnt );
errmsg( emsg );
d706 1
a706 1
sprintf( emsg, "RUN: search '%s' on %s[%d]", sbuf,
a707 1
errmsg( emsg );
d716 1
a716 2
sprintf( emsg, "ERROR: %s", rbuf );
errmsg( emsg );
d734 3
a736 2
		sprintf( emsg, "unexpected mesg tag %d\n", pstatus->MPI_TAG );
		errmsg( emsg );
d869 1
a869 1
		errmsg( "popen failed" );
a924 6
}

static	void	errmsg( char *msg )
{

	fprintf( stderr, "%s: %s\n", xhostname, msg );
@


1.2
log
@replaced all uses of ->st_length with MPI_get_count().
@
text
@d420 1
a420 1
	strcpy( cpn, " -xdfname %s" );
@


1.1
log
@Initial revision
@
text
@d731 1
d740 2
a741 1
		if( pstatus->st_length > s_rbuf ){
d744 1
a744 1
			s_rbuf = pstatus->st_length;
d825 1
d838 2
a839 1
		if( pstatus->st_length > s_rbuf ){
d842 1
a842 1
			s_rbuf = pstatus->st_length;
d857 2
a858 1
		if( pstatus->st_length > s_rbuf ){
d861 1
a861 1
			s_rbuf = pstatus->st_length;
@
