head	1.62;
access;
symbols;
locks; strict;
comment	@ * @;


1.62
date	2002.08.17.19.13.30;	author macke;	state Exp;
branches;
next	1.61;

1.61
date	2002.05.27.21.41.42;	author macke;	state Exp;
branches;
next	1.60;

1.60
date	2002.05.16.04.12.53;	author macke;	state Exp;
branches;
next	1.59;

1.59
date	2002.05.14.19.04.13;	author macke;	state Exp;
branches;
next	1.58;

1.58
date	2002.04.12.02.19.11;	author macke;	state Exp;
branches;
next	1.57;

1.57
date	2002.02.07.03.11.13;	author macke;	state Exp;
branches;
next	1.56;

1.56
date	2001.12.19.21.14.42;	author macke;	state Exp;
branches;
next	1.55;

1.55
date	2001.10.29.20.05.49;	author macke;	state Exp;
branches;
next	1.54;

1.54
date	2001.10.04.03.29.43;	author macke;	state Exp;
branches;
next	1.53;

1.53
date	2001.09.11.13.22.51;	author macke;	state Exp;
branches;
next	1.52;

1.52
date	2001.08.30.23.45.08;	author macke;	state Exp;
branches;
next	1.51;

1.51
date	2001.08.23.21.57.38;	author macke;	state Exp;
branches;
next	1.50;

1.50
date	2001.08.16.20.24.51;	author macke;	state Exp;
branches;
next	1.49;

1.49
date	2001.07.30.20.02.52;	author macke;	state Exp;
branches;
next	1.48;

1.48
date	2001.06.04.03.24.11;	author macke;	state Exp;
branches;
next	1.47;

1.47
date	2001.05.29.00.15.53;	author macke;	state Exp;
branches;
next	1.46;

1.46
date	2001.05.04.19.33.06;	author macke;	state Exp;
branches;
next	1.45;

1.45
date	2000.12.18.02.10.21;	author macke;	state Exp;
branches;
next	1.44;

1.44
date	2000.11.27.18.31.20;	author macke;	state Exp;
branches;
next	1.43;

1.43
date	2000.11.27.00.20.32;	author macke;	state Exp;
branches;
next	1.42;

1.42
date	2000.11.23.01.34.55;	author macke;	state Exp;
branches;
next	1.41;

1.41
date	2000.10.29.20.54.34;	author macke;	state Exp;
branches;
next	1.40;

1.40
date	2000.10.11.22.16.12;	author macke;	state Exp;
branches;
next	1.39;

1.39
date	2000.10.09.19.39.46;	author macke;	state Exp;
branches;
next	1.38;

1.38
date	2000.10.07.18.45.43;	author macke;	state Exp;
branches;
next	1.37;

1.37
date	2000.10.07.16.50.56;	author macke;	state Exp;
branches;
next	1.36;

1.36
date	2000.10.07.06.43.20;	author macke;	state Exp;
branches;
next	1.35;

1.35
date	2000.10.05.06.12.13;	author macke;	state Exp;
branches;
next	1.34;

1.34
date	2000.09.26.23.24.40;	author macke;	state Exp;
branches;
next	1.33;

1.33
date	2000.09.13.22.49.26;	author macke;	state Exp;
branches;
next	1.32;

1.32
date	2000.09.13.22.39.17;	author macke;	state Exp;
branches;
next	1.31;

1.31
date	2000.09.11.04.05.09;	author macke;	state Exp;
branches;
next	1.30;

1.30
date	2000.09.06.21.27.46;	author macke;	state Exp;
branches;
next	1.29;

1.29
date	2000.09.06.21.00.40;	author macke;	state Exp;
branches;
next	1.28;

1.28
date	2000.09.04.18.49.40;	author macke;	state Exp;
branches;
next	1.27;

1.27
date	2000.08.31.19.52.29;	author macke;	state Exp;
branches;
next	1.26;

1.26
date	2000.04.27.21.18.42;	author macke;	state Exp;
branches;
next	1.25;

1.25
date	2000.04.27.19.55.13;	author macke;	state Exp;
branches;
next	1.24;

1.24
date	2000.04.25.00.23.11;	author macke;	state Exp;
branches;
next	1.23;

1.23
date	2000.03.28.19.13.50;	author macke;	state Exp;
branches;
next	1.22;

1.22
date	2000.03.27.19.03.05;	author macke;	state Exp;
branches;
next	1.21;

1.21
date	2000.03.17.22.03.32;	author macke;	state Exp;
branches;
next	1.20;

1.20
date	2000.03.08.03.56.05;	author macke;	state Exp;
branches;
next	1.19;

1.19
date	2000.02.10.00.13.27;	author macke;	state Exp;
branches;
next	1.18;

1.18
date	99.10.23.02.23.34;	author macke;	state Exp;
branches;
next	1.17;

1.17
date	99.10.22.18.19.39;	author macke;	state Exp;
branches;
next	1.16;

1.16
date	99.10.22.03.21.59;	author macke;	state Exp;
branches;
next	1.15;

1.15
date	99.10.19.22.28.39;	author macke;	state Exp;
branches;
next	1.14;

1.14
date	99.10.19.17.59.40;	author macke;	state Exp;
branches;
next	1.13;

1.13
date	99.10.18.19.53.26;	author macke;	state Exp;
branches;
next	1.12;

1.12
date	99.10.06.19.57.38;	author macke;	state Exp;
branches;
next	1.11;

1.11
date	99.10.03.19.17.36;	author macke;	state Exp;
branches;
next	1.10;

1.10
date	99.10.01.03.23.57;	author macke;	state Exp;
branches;
next	1.9;

1.9
date	99.09.30.18.55.09;	author macke;	state Exp;
branches;
next	1.8;

1.8
date	99.09.30.01.04.44;	author macke;	state Exp;
branches;
next	1.7;

1.7
date	99.09.28.04.53.53;	author macke;	state Exp;
branches;
next	1.6;

1.6
date	99.09.18.02.22.24;	author macke;	state Exp;
branches;
next	1.5;

1.5
date	99.09.17.21.45.06;	author macke;	state Exp;
branches;
next	1.4;

1.4
date	99.09.16.01.40.44;	author macke;	state Exp;
branches;
next	1.3;

1.3
date	99.09.15.03.34.44;	author macke;	state Exp;
branches;
next	1.2;

1.2
date	99.09.12.18.34.06;	author macke;	state Exp;
branches;
next	1.1;

1.1
date	99.09.11.19.12.07;	author macke;	state Exp;
branches;
next	;


desc
@scoring engine.
@


1.62
log
@added code that ensures that efn()/efn2() is not run on pknots or on
partial structures with out of bound refs.
@
text
@#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <math.h>

#include "rmdefs.h"
#include "rnamot.h"
#include "y.tab.h"

#define	FMTLIST		"bBdiouxXfeEgGcCsSpn%"
#define	FMTFLAGS	"'-+ #0"

#define	MIN(a,b)	((a)<(b)?(a):(b))
#define	LG(v)		(3.32192809488736234789*log10(v))

#define	ISLVAL(s)	\
	((s)==SYM_ASSIGN||(s)==SYM_PLUS_ASSIGN||(s)==SYM_MINUS_ASSIGN||\
	 (s)==SYM_PERCENT_ASSIGN||(s)==SYM_SLASH_ASSIGN||(s)==SYM_STAR_ASSIGN||\
	 (s)==SYM_PLUS_PLUS||(s)==SYM_MINUS_MINUS)

#define	ISRFLX(s)	\
	((s)==SYM_PLUS_ASSIGN||(s)==SYM_MINUS_ASSIGN||\
	 (s)==SYM_PERCENT_ASSIGN||(s)==SYM_SLASH_ASSIGN||(s)==SYM_STAR_ASSIGN)

extern	char	*rm_wdfname;
extern	int	rm_lineno;
extern	int	rm_emsg_lineno;	
extern	STREL_T	rm_descr[];
extern	int	rm_n_descr;
extern	STREL_T	*rm_lctx;
extern	int	rm_lctx_explicit;
extern	STREL_T	*rm_rctx;
extern	int	rm_rctx_explicit;
extern	int	rm_b2bc[];
extern	int	rm_efninit;
extern	int	rm_efn2init;
extern	char	rm_efndatadir[];
extern	int	rm_efndataok;
extern	int	rm_efn2dataok;
extern	int	*rm_bcseq;
extern	int	*rm_basepr;
extern	int	*rm_hstnum;
extern	int	rm_l_base;
extern	int	rm_efnusestdbp;
extern	PAIRSET_T	*rm_efnstdbp;

static	STREL_T	**rm_xdescr;
static	int	rm_n_xdescr;

extern	int	circf;	/* reg. exp. ^ kludge	*/

IDENT_T	*RM_find_id();
IDENT_T	*RM_enter_id();
NODE_T	*RM_node();

#define	LABTAB_SIZE	1000
static	int	labtab[ LABTAB_SIZE ];
static	int	nextlab;
static	int	actlab;
static	VALUE_T	v_lab;

static	int	ifstk[ 100 ];
static	int	ifstkp = 0;

static	int	loopstk[ 100 ];
static	NODE_T	*loopincrstk[ 100 ];
static	int	loopstkp = 0;

static	int	sc_comp;
static	IDENT_T	*sc_SLEN;
static	int	sc_slen;
static	char	*sc_sbuf;

#define	OP_NOOP		0	/* No Op	 	*/
#define	OP_ACPT		1	/* Accept the candidate	*/
#define	OP_RJCT		2	/* Reject the candidate */
#define	OP_MRK		3	/* Mark the stack	*/
#define	OP_CLS		4	/* Clear the stack	*/
#define	OP_FCL		5	/* Function Call	*/
#define	OP_SCL		6	/* Builtin  Call	*/
#define	OP_STRF		7	/* Str. El. Reference	*/
#define	OP_LDA		8	/* Load Address		*/
#define	OP_LOD		9	/* Load Value		*/
#define	OP_LDC		10	/* Load Constant	*/
#define	OP_STO		11	/* Store top of stack	*/
#define	OP_AND		12	/* McCarthy And		*/
#define	OP_IOR		13	/* McCarthy Or		*/
#define	OP_NOT		14	/* Not			*/
#define	OP_MAT		15	/* Match		*/
#define	OP_INS		16	/* In Pairset		*/
#define	OP_GTR		17	/* Greater Than		*/
#define	OP_GEQ		18	/* Greater or Equal	*/
#define	OP_EQU		19	/* Equal		*/
#define	OP_NEQ		20	/* Not Equal		*/
#define	OP_LEQ		21	/* Less or Equal	*/
#define	OP_LES		22	/* Less Than		*/
#define	OP_ADD		23	/* Addition		*/
#define	OP_SUB		24	/* Subtraction		*/
#define	OP_MUL		25	/* Multiplication	*/
#define	OP_DIV		26	/* Division		*/
#define	OP_MOD		27	/* Modulus		*/
#define	OP_NEG		28	/* Negate		*/
#define	OP_I_PP		29	/* use then incr (i++)	*/
#define	OP_PP_I		30	/* incr then use (++i)	*/
#define	OP_I_MM		31	/* use then decr (i--)	*/
#define	OP_MM_I		32	/* decr then use (--i)	*/
#define	OP_FJP		33	/* False Jump		*/
#define	OP_JMP		34	/* Jump			*/
#define	N_OP		35

static	char	*opnames[ N_OP ] = {
	"noop",
	"acpt",
	"rjct",
	"mrk",
	"cls",
	"fcl",
	"scl",
	"strf",
	"lda",
	"lod",
	"ldc",
	"sto",
	"and",
	"ior",
	"not",
	"mat",
	"ins",
	"gtr",
	"geq",
	"equ",
	"neq",
	"leq",
	"les",
	"add",
	"sub",
	"mul",
	"div",
	"mod",
	"neg",
	"incp",
	"pinc",
	"decp",
	"pdec",
	"fjp",
	"jmp" 
};

#define	SC_STRID	0
#define	SC_BITS		1
#define	SC_EFN		2
#define	SC_EFN2		3
#define	SC_LENGTH	4
#define	SC_LOC		5
#define	SC_MISMATCHES	6
#define	SC_MISMATCHES_1	7
#define	SC_MISMATCHES_2	8
#define	SC_MISPAIRS	9
#define	SC_PAIRED	10
#define	SC_SPRINTF	11
#define	N_SC		12

static	char	*scnames[ N_SC ] = {
	"STRID",
	"bits",
	"efn",
	"efn2",
	"length",
	"loc",
	"mismatches",	/* Kludge, depends on linear search!	*/
	"mismatches",	/* Require so dumpinst() doesn't fail	*/
	"mismatches",
	"mispairs",
	"paired",
	"sprintf"
};

typedef	struct	inst_t	{
	char	*i_filename;
	int	i_lineno;
	int	i_op;
	VALUE_T	i_val;
} INST_T;

#define	PROG_SIZE	10000
static	INST_T	prog[ PROG_SIZE ];
static	int	l_prog;

#define	MEM_SIZE	10000
static	VALUE_T	mem[ MEM_SIZE ];

static	int	pc;		/* program counter	*/
static	int	mp;		/* mark pointer		*/ 
static	int	sp;		/* stack pointer	*/
#define	ESTK_SIZE	20
static	int	estk[ ESTK_SIZE ];
static	int	esp;		/* element stack pointer*/

static	char	emsg[ 256 ];

#define	SPRINTFBUF_SIZE	10000
static	char	sprintfbuf[ SPRINTFBUF_SIZE ];
static	char	*sbp;

void	RM_action( NODE_T * );
void	RM_endaction( void );
void	RM_if( NODE_T * );
void	RM_else( void );
void	RM_endelse( void );
void	RM_endif( void );
void	RM_forinit( NODE_T * );
void	RM_fortest( NODE_T * );
void	RM_forincr( NODE_T * );
void	RM_endfor( void );
void	RM_while( NODE_T * );
void	RM_endwhile( void );
void	RM_break( NODE_T * );
void	RM_continue( NODE_T * );
void	RM_accept( void );
void	RM_reject( void );
void	RM_mark( void );
void	RM_clear( void );
void	RM_expr( int, NODE_T * );
void	RM_linkscore( void );
void	RM_dumpscore( FILE * );
int	RM_score( int, int, char [] );

static	void	fixexpr( NODE_T * );
static	void	genexpr( int, NODE_T * );
static	int	is_syscall( NODE_T * );
static	void	fix_kw_stref( NODE_T * );
static	void	fix_ix_stref( NODE_T * );
static	NODE_T	*mk_call_strid( int, NODE_T * );
static	void	fix_call( NODE_T * );
static	void	do_fcl( INST_T * );
static	void	do_scl( INST_T * );
static	int	paired( STREL_T *, int, int );
static	int	strid( int, VALUE_T * );
static	int	do_sprintf( INST_T * );
static	int	do_fmt( INST_T *, char *, int, int * );
static	void	do_strf( INST_T * );
static	void	do_lda( INST_T * );
static	void	do_lod( INST_T * );
static	void	do_ldc( INST_T * );
static	void	do_sto( INST_T * );
static	void	do_and( INST_T * );
static	void	do_ior( INST_T * );
static	void	do_not( INST_T * );
static	void	do_mat( INST_T * );
static	void	do_ins( INST_T * );
static	void	do_gtr( INST_T * );
static	void	do_geq( INST_T * );
static	void	do_equ( INST_T * );
static	void	do_neq( INST_T * );
static	void	do_leq( INST_T * );
static	void	do_les( INST_T * );
static	void	do_add( INST_T * );
static	void	do_sub( INST_T * );
static	void	do_mul( INST_T * );
static	void	do_div( INST_T * );
static	void	do_mod( INST_T * );
static	void	do_neg( INST_T * );
static	void	do_i_pp( INST_T * );
static	void	do_pp_i( INST_T * );
static	void	do_i_mm( INST_T * );
static	void	do_mm_i( INST_T * );

static	float	RM_bits( INST_T *, int, int, int, int );
static	int	setupefn( INST_T *, int, int, int, int );
static	int	setbp( INST_T *, STREL_T *, int, int, int, int, int [] );
static	void	mk_stref_name( int, char []);
static	void	addnode( int, NODE_T *, int );
static	void	addinst( NODE_T *, int, VALUE_T * );
static	void	dumpinst( FILE *, int, INST_T * );
static	void	dumpstk( FILE *, char [] );

char	*getenv();

#define	TM_MEM_SIZE	1000
typedef	struct	tm_mem_t	{
	int	t_freed;
	char	*t_id;
	int	t_pc;
	void	*t_addr;
} TM_MEM_T;
static	TM_MEM_T	tm_mem[ TM_MEM_SIZE ];
static	int	tm_n_mem;

static	char	*tm_malloc( int, char [] );
static	void	tm_free( void * );
static	void	tm_report( void );

void	RM_action( NODE_T *np )
{

	RM_mark();
	RM_expr( 0, np );
	actlab = nextlab;
	nextlab++;
	v_lab.v_type = T_INT;
	v_lab.v_value.v_ival = actlab;
	addinst( np, OP_FJP, &v_lab );
}

void	RM_endaction( void )
{

	labtab[ actlab ] = l_prog;
}

void	RM_if( NODE_T *np )
{

	RM_mark();
	RM_expr( 0, np );
	ifstk[ ifstkp ] = nextlab;
	ifstkp++;
	nextlab += 2;
	v_lab.v_type = T_INT;
	v_lab.v_value.v_ival = ifstk[ ifstkp - 1 ];
	addinst( np, OP_FJP, &v_lab );
}

void	RM_else( void )
{

	v_lab.v_type = T_INT;
	v_lab.v_value.v_ival = ifstk[ ifstkp - 1 ] + 1;
	addinst( NULL, OP_JMP, &v_lab );
	labtab[ ifstk[ ifstkp - 1 ] ] = l_prog;
}

void	RM_endelse( void )
{

	labtab[ ifstk[ ifstkp - 1 ] + 1 ] = l_prog;
	ifstkp--;
}

void	RM_endif( void )
{

	labtab[ ifstk[ ifstkp - 1 ] ] = l_prog;
	ifstkp--;
}

void	RM_forinit( NODE_T *np )
{

	loopstk[ loopstkp ] = nextlab;
	loopstkp++;
	nextlab += 3;
	RM_mark();
	RM_expr( 0, np );
	RM_clear();
}

void	RM_fortest( NODE_T *np )
{

	labtab[ loopstk[ loopstkp - 1 ] ] = l_prog;
	RM_mark();
	RM_expr( 0, np );
	v_lab.v_type = T_INT;
	v_lab.v_value.v_ival = loopstk[ loopstkp - 1 ] + 2;
	addinst( np, OP_FJP, &v_lab );
}

void	RM_forincr( NODE_T *np )
{

	loopincrstk[ loopstkp - 1 ] = np;
}

void	RM_endfor( void )
{

	labtab[ loopstk[ loopstkp - 1 ] + 1 ] = l_prog;
	RM_mark();
	RM_expr( 0, loopincrstk[ loopstkp - 1 ] );
	RM_clear();
	v_lab.v_type = T_INT;
	v_lab.v_value.v_ival = loopstk[ loopstkp - 1 ];
	addinst( NULL, OP_JMP, &v_lab );
	labtab[ loopstk[ loopstkp - 1 ] + 2 ] = l_prog;
	loopstkp--;
}

void	RM_while( NODE_T *np )
{

	loopstk[ loopstkp ] = nextlab;
	loopstkp++;
	nextlab += 3;
	labtab[ loopstk[ loopstkp -1 ] ] = l_prog;
	RM_mark();
	RM_expr( 0, np );
	v_lab.v_type = T_INT;
	v_lab.v_value.v_ival = loopstk[ loopstkp - 1 ] + 2;
	addinst( np, OP_FJP, &v_lab );
}

void	RM_endwhile( void )
{

	labtab[ loopstk[ loopstkp - 1 ] + 1 ] = l_prog;
	v_lab.v_type = T_INT;
	v_lab.v_value.v_ival = loopstk[ loopstkp - 1 ];
	addinst( NULL, OP_JMP, &v_lab );
	labtab[ loopstk[ loopstkp - 1 ] + 2 ] = l_prog;
	loopstkp--;
}

void	RM_break( NODE_T *np )
{
	int	lev;

	if( np == NULL )
		lev = 1;
	else{
		lev = np->n_val.v_value.v_ival;
		if( lev < 1 || lev > loopstkp ){
			sprintf( emsg,
				"continue level must be between 1 and %d.",
				lev );
			RM_errormsg( TRUE, emsg );
		}
	}
	v_lab.v_type = T_INT;
/*
	v_lab.v_value.v_ival = loopstk[ loopstkp - 1 ] + 1;
*/
	v_lab.v_value.v_ival = loopstk[ loopstkp - lev ] + 2;
	addinst( NULL, OP_JMP, &v_lab );
}

void	RM_continue( NODE_T *np )
{
	int	lev;

	if( np == NULL )
		lev = 1;
	else{
		lev = np->n_val.v_value.v_ival;
		if( lev < 1 || lev > loopstkp ){
			sprintf( emsg,
				"continue level must be between 1 and %d.",
				lev );
			RM_errormsg( TRUE, emsg );
		}
	}
	v_lab.v_type = T_INT;
/*
	v_lab.v_value.v_ival = loopstk[ loopstkp - lev ] + 1;
*/
	addinst( NULL, OP_JMP, &v_lab );
}

void	RM_accept( void )
{

	addinst( NULL, OP_ACPT, NULL );
}

void	RM_reject( void )
{

	addinst( NULL, OP_RJCT, NULL );
}

void	RM_mark( void )
{

	addinst( NULL, OP_MRK, NULL );
}

void	RM_clear( void )
{

	addinst( NULL, OP_CLS, 0 );
}

void	RM_expr( int lval, NODE_T *np )
{

	fixexpr( np );
	genexpr( lval, np );
}

void	RM_linkscore( void )
{
	int	i, x;
	INST_T	*ip;
	VALUE_T	v_svars;

	for( ip = prog, i = 0; i < l_prog; i++, ip++ ){
		if( ip->i_op == OP_FJP || ip->i_op == OP_JMP ){
			ip->i_val.v_value.v_ival =
				labtab[ ip->i_val.v_value.v_ival ];
		}else if( ip->i_op == OP_IOR || ip->i_op == OP_AND ){
			ip->i_val.v_value.v_ival =
				labtab[ ip->i_val.v_value.v_ival ];
		}
	}

	rm_n_xdescr = rm_n_descr;
	if( rm_lctx != NULL && rm_lctx_explicit )
		rm_n_xdescr++;
	if( rm_rctx != NULL && rm_rctx_explicit )
		rm_n_xdescr++;
	rm_xdescr = ( STREL_T ** )malloc( rm_n_xdescr * sizeof( STREL_T * ) );
	if( rm_xdescr == NULL ){
		rm_emsg_lineno = UNDEF;
		RM_errormsg( TRUE, "RM_linkscore: can't allocate rm_xdescr." );
	}
	if( rm_lctx != NULL && rm_lctx_explicit ){
		rm_xdescr[ 0 ] = rm_lctx;
		x = 1;
	}else
		x = 0;
	for( i = 0; i < rm_n_descr; i++, x++ )
		rm_xdescr[ x ] = &rm_descr[ i ];
	if( rm_rctx != NULL && rm_rctx_explicit )
		rm_xdescr[ x ] = rm_rctx;

	v_svars.v_type = T_INT;
	v_svars.v_value.v_ival = rm_n_xdescr;
	RM_enter_id( "NSE", T_INT, C_VAR, S_GLOBAL, 0, &v_svars );

	v_svars.v_type = T_INT;
	v_svars.v_value.v_ival = 0;
	sc_SLEN = RM_enter_id( "SLEN", T_INT, C_VAR, S_GLOBAL, 0, &v_svars );
}

void	RM_dumpscore( FILE *fp )
{
	INST_T	*ip;
	int	i;

	fprintf( fp, "SCORE: %4d inst.\n", l_prog );
	for( ip = prog, i = 0; i < l_prog; i++, ip++ ){
		dumpinst( fp, i, ip );
	}
}

int	RM_score( int comp, int slen, char sbuf[] )
{
	INST_T	*ip;
	int	rval;
	
	if( l_prog <= 0 )
		return( 1 );

	sc_comp = comp;
	sc_SLEN->i_val.v_value.v_ival = sc_slen = slen;
	sc_sbuf = sbuf;
	esp = sp = mp = -1;
	for( rval = 0, pc = 0; ; ){
		if( pc < 0 || pc >= l_prog ){
			sprintf( emsg, "RM_score: pc: %d: out of range 0..%d.",
				pc, l_prog - 1 );
			RM_errormsg( TRUE, emsg );
		}
		ip = &prog[ pc ];

/*
fprintf( stdout, "RM_run, pc = %4d, op = %s\n", pc, opnames[ ip->i_op ] );
dumpstk( stdout, "before op" );
*/

		pc++;
		switch( ip->i_op ){
		case OP_NOOP :
			break;

		case OP_ACPT :
			rval = 1;
			goto SCORED;
			break;
		case OP_RJCT :
			goto SCORED;
			break;

		case OP_MRK :
			sp++;
			mem[ sp ].v_type = T_INT;
			mem[ sp ].v_value.v_ival = mp;
			mp = sp;
			break;
		case OP_CLS :
			sp = mp = -1;
			break;

		case OP_FCL :
			do_fcl( ip );
			break;
		case OP_SCL :
			do_scl( ip );
			break;
		case OP_STRF :
			do_strf( ip );
			break;

		case OP_LDA :
			do_lda( ip );
			break;
		case OP_LOD :
			do_lod( ip );
			break;
		case OP_LDC :
			do_ldc( ip );
			break;
		case OP_STO :
			do_sto( ip );
			break;

		case OP_AND :
			do_and( ip );
			break;
		case OP_IOR :
			do_ior( ip );
			break;
		case OP_NOT :
			do_not( ip );
			break;

		case OP_MAT :
			do_mat( ip );
			break;
		case OP_INS :
			do_ins( ip );
			break;
		case OP_GTR :
			do_gtr( ip );
			break;
		case OP_GEQ :
			do_geq( ip );
			break;
		case OP_EQU :
			do_equ( ip );
			break;
		case OP_NEQ :
			do_neq( ip );
			break;
		case OP_LEQ :
			do_leq( ip );
			break;
		case OP_LES :
			do_les( ip );
			break;

		case OP_ADD :
			do_add( ip );
			break;
		case OP_SUB :
			do_sub( ip );
			break;
		case OP_MUL :
			do_mul( ip );
			break;
		case OP_DIV :
			do_div( ip );
			break;
		case OP_MOD :
			do_mod( ip );
			break;
		case OP_NEG :
			do_neg( ip );
			break;

		case OP_I_PP :
			do_i_pp( ip );
			break;
		case OP_PP_I :
			do_pp_i( ip );
			break;
		case OP_I_MM :
			do_i_mm( ip );
			break;
		case OP_MM_I :
			do_mm_i( ip );
			break;

		case OP_FJP :
			if( !mem[ sp ].v_value.v_ival )
				pc = ip->i_val.v_value.v_ival; 
			sp = mp = -1;
			break;
		case OP_JMP :
			pc = ip->i_val.v_value.v_ival;
			break;
		default :
			rm_wdfname = ip->i_filename; 
			rm_emsg_lineno = ip->i_lineno;
			sprintf( emsg, "RM_score: unknown op %d.", ip->i_op );
			RM_errormsg( TRUE, emsg );
			break;
		}

/*
dumpstk( stdout, "after op " );
*/

	}

SCORED : ;

#ifdef MEMDEBUG
	tm_report();
#endif
	
	return( rval );
}

static	void	fixexpr( NODE_T *np )
{

	if( np ){
		fixexpr( np->n_left );
		fixexpr( np->n_right );
		if( np->n_sym == SYM_KW_STREF ){
			fix_kw_stref( np );
		}else if( np->n_sym == SYM_IX_STREF ){
			fix_ix_stref( np );
		}else if( np->n_sym == SYM_CALL ){
			fix_call( np );
		}
	}
}

static	void	genexpr( int lval, NODE_T *np )
{
	int	l_andor;

	if( np ){
		if( np->n_sym == SYM_CALL ){
			addinst( np, OP_MRK, NULL );
		}else if( np->n_sym == SYM_IN ){
			addinst( np, OP_MRK, NULL );
		}

		genexpr( ISLVAL( np->n_sym ), np->n_left );

		if( ISRFLX( np->n_sym ) )
			genexpr( 0, np->n_left );

		if( np->n_sym == SYM_OR || np->n_sym == SYM_AND ){
			l_andor = nextlab;
			nextlab++;
			addnode( lval, np, l_andor );
			genexpr( 0, np->n_right );
			labtab[ l_andor ] = l_prog;
		}else{
			genexpr( 0, np->n_right );
			addnode( lval, np, 0 );
		}

		if( np->n_sym == SYM_KW_STREF || np->n_sym == SYM_IX_STREF ){
			addinst( np, OP_STRF, NULL );
		}
	}
}

static	int	is_syscall( NODE_T *np )
{
	int	i;
	char	*sp;

	sp = np->n_val.v_value.v_pval;
	for( i = 0; i < N_SC; i++ ){
		if( !strcmp( sp, scnames[ i ] ) )
			return( i );
	}
	return( UNDEF );
}

static	void	fix_kw_stref( NODE_T *np )
{
	int	sel;
	NODE_T	*n_id, *n_index, *n_tag, *n_pos, *n_len;
	NODE_T	*np1, *np2, *np3;
	char	*ip;
	VALUE_T	v_expr;

	sel = np->n_left->n_sym;
	n_id = n_index = n_tag = n_pos = n_len = NULL;
	for( np1 = np->n_right; np1; np1 = np1->n_right ){
		np2 = np1->n_left;
		np3 = np2->n_left;
		if( np3->n_sym == SYM_IDENT ){
			ip = np3->n_val.v_value.v_pval;
			if( !strcmp( ip, "index" ) ){
				if( n_index != NULL ){
					rm_wdfname = n_index->n_filename;
					rm_emsg_lineno = n_index->n_lineno;
					RM_errormsg( TRUE,
	"fix_kw_stref: index parameter may not appear more than once." );
				}else
					n_index = np2->n_right;
			}else if( !strcmp( ip, "tag" ) ){
				if( n_tag != NULL ){
					rm_wdfname = n_tag->n_filename;
					rm_emsg_lineno = n_tag->n_lineno;
					RM_errormsg( TRUE,
	"fix_kw_stref: tag parameter may not appear more than once." );
				}else
					n_tag = np2->n_right;
			}else if( !strcmp( ip, "pos" ) ){
				if( n_pos != NULL ){
					rm_wdfname = n_pos->n_filename;
					rm_emsg_lineno = n_pos->n_lineno;
					RM_errormsg( TRUE,
		"fix_kw_stref: pos parameter may not appear more than once." );
				}else
					n_pos = np2->n_right;
			}else if( !strcmp( ip, "len" ) ){
				if( n_len != NULL ){
					rm_wdfname = n_len->n_filename;
					rm_emsg_lineno = n_len->n_lineno;
					RM_errormsg( TRUE,
		"fix_kw_stref: len parameter may not appear more than once." );
				}else
					n_len = np2->n_right;
			}else{
				rm_wdfname = np3->n_filename;
				rm_emsg_lineno = np3->n_lineno;
				sprintf( emsg,
				"fix_kw_stref: unknown parameter: '%s'.",
					ip );
				RM_errormsg( TRUE, emsg );
			}
		}
	}

	rm_wdfname = np->n_filename;
	rm_emsg_lineno = np->n_lineno;
	if( n_index == NULL && n_tag == NULL ||
		n_index != NULL && n_tag != NULL )
	{
		rm_wdfname = np->n_filename;
		rm_emsg_lineno = np->n_lineno;
		RM_errormsg( TRUE,
		"fix_kw_stref: one of index= or tag= required for stref()." );
	}else
		n_id = n_index != NULL ? n_index : n_tag;

	np1 = mk_call_strid( sel, n_id );

	/* build the 3 parms to stref	*/
	if( n_len == NULL ){
		v_expr.v_type = T_INT;
		v_expr.v_value.v_ival = UNDEF;
		np3 = RM_node( SYM_INT, &v_expr, 0, 0 );
	}else
		np3 = n_len;
	np2 = RM_node( SYM_LIST, 0, np3, NULL );
	if( n_pos == NULL ){
		v_expr.v_type = T_INT;
/*
		v_expr.v_value.v_ival = 1;
*/
		v_expr.v_value.v_ival = UNDEF;
		np3 = RM_node( SYM_INT, &v_expr, 0, 0 );
	}else
		np3 = n_pos;
	np2 = RM_node( SYM_LIST, 0, np3, np2 );
	np1 = RM_node( SYM_LIST, 0, np1, np2 );
	np->n_right = np1;
}

static	void	fix_ix_stref( NODE_T *np )
{
	int	sel;
	NODE_T	*n_id, *n_pos, *n_len;
	NODE_T	*np1, *np2, *np3;
	VALUE_T	v_expr;

	sel = np->n_left->n_sym;
	n_id = n_pos = n_len = NULL;
	np1 = np->n_right;
	np2 = np1->n_left; 

	n_id = np2;
	if( np1->n_right != NULL ){
		np1 = np1->n_right;
		n_pos = np1->n_left; 
		if( np1->n_right != NULL ){
			np1 = np1->n_right;
			n_len = np1->n_left; 
		}
	}

	np1 = mk_call_strid( sel, n_id );

	/* build the 3 parms to stref	*/
	if( n_len == NULL ){
		v_expr.v_type = T_INT;
		v_expr.v_value.v_ival = UNDEF;
		np3 = RM_node( SYM_INT, &v_expr, 0, 0 );
	}else
		np3 = n_len;
	np2 = RM_node( SYM_LIST, 0, np3, NULL );
	if( n_pos == NULL ){
		v_expr.v_type = T_INT;
		v_expr.v_value.v_ival = UNDEF;
		np3 = RM_node( SYM_INT, &v_expr, 0, 0 );
	}else
		np3 = n_pos;
	np2 = RM_node( SYM_LIST, 0, np3, np2 );
	np1 = RM_node( SYM_LIST, 0, np1, np2 );
	np->n_right = np1;
}

static	NODE_T	*mk_call_strid( int strel, NODE_T *n_id )
{
	NODE_T	*np1, *np2, *np3;
	VALUE_T	v_expr;

	np2 = RM_node( SYM_LIST, 0, n_id, NULL );

	v_expr.v_type = T_INT;
	v_expr.v_value.v_ival = strel;
	np3 = RM_node( SYM_INT, &v_expr, 0, 0 );
	np2 = RM_node( SYM_LIST, 0, np3, np2 );

/*
	v_expr.v_type = T_STRING;
	v_expr.v_value.v_pval = "STRID";
*/
	v_expr.v_type = T_INT;
	v_expr.v_value.v_ival = SC_STRID;

	np3 = RM_node( SYM_IDENT, &v_expr, 0, 0 );
	np1 = RM_node( SYM_CALL, 0, np3, np2 );
	return( np1 );
}

static	void	fix_call( NODE_T *np )
{
	int	sc, pcnt;
	NODE_T	*np1, *np2, *np3;

	sc = is_syscall( np );

	np->n_val.v_type = T_INT;
	np->n_val.v_value.v_ival = sc;

	switch( sc ){
	case SC_STRID :
		rm_wdfname = np->n_filename;
		rm_emsg_lineno = np->n_lineno;
		RM_errormsg( TRUE,
			"fix_call: STRID can not be called by user." );
		break;
	case SC_BITS :
	case SC_EFN :
	case SC_EFN2 :
		for( pcnt = 0, np1 = np->n_right; np1; np1 = np1->n_right )
			pcnt++;
		if( pcnt != 2 ){
			rm_wdfname = np->n_filename;
			rm_emsg_lineno = np->n_lineno;
			sprintf( emsg,
				"fix_call: function '%s' has 2 parameters.",
				 scnames[ sc ] );
			RM_errormsg( TRUE, emsg );
		}
		np1 = np->n_right;
		np2 = np1->n_right;

		np1 = np1->n_left;
		np2 = np2->n_left;

		if( np1->n_sym != SYM_KW_STREF && np1->n_sym != SYM_IX_STREF ){
			rm_wdfname = np1->n_filename;
			rm_emsg_lineno = np1->n_lineno;
			sprintf( emsg,
			"fix_call: function '%s' takes only strel arguments.",
				scnames[ sc ] );
			RM_errormsg( TRUE, emsg );
		}else{
			np1 = np1->n_right;
			for( np3 = np1; np3->n_right ; np3 = np3->n_right )
				;
		}
		if( np2->n_sym != SYM_KW_STREF && np2->n_sym != SYM_IX_STREF ){
			rm_wdfname = np2->n_filename;
			rm_emsg_lineno = np2->n_lineno;
			sprintf( emsg,
			"fix_call: function '%s' takes only strel arguments.",
				scnames[ sc ] );
			RM_errormsg( TRUE, emsg );
		}else
			np2 = np2->n_right;

		np3->n_right = np2;
		np->n_right = np1;
		break;
	case SC_LENGTH :
		break;
	case SC_LOC :
		for( pcnt = 0, np1 = np->n_right; np1; np1 = np1->n_right )
			pcnt++;
		if( pcnt != 1 ){
			rm_wdfname = np->n_filename;
			rm_emsg_lineno = np->n_lineno;
			sprintf( emsg,
				"fix_call: function '%s' has 1 parameters.",
				 scnames[ sc ] );
			RM_errormsg( TRUE, emsg );
		}
		np1 = np->n_right;
		np1 = np1->n_left;
		if( np1->n_sym != SYM_KW_STREF && np1->n_sym != SYM_IX_STREF ){
			rm_wdfname = np1->n_filename;
			rm_emsg_lineno = np1->n_lineno;
			sprintf( emsg,
			"fix_call: function '%s' takes only strel arguments.",
				scnames[ sc ] );
			RM_errormsg( TRUE, emsg );
		}else
			np1 = np1->n_right;
		np->n_right = np1;
		break;
	case SC_MISMATCHES :	/* 1 or 2 parms */
		for( pcnt = 0, np1 = np->n_right; np1; np1 = np1->n_right )
			pcnt++;
/*
		if( pcnt < 1 || pcnt > 2 ){
			rm_wdfname = np->n_filename;
			rm_emsg_lineno = np->n_lineno;
			sprintf( emsg,
				"fix_call: function '%s' has 1 parameter.",
				 scnames[ sc ] );
			RM_errormsg( TRUE, emsg );
		}
		np1 = np->n_right;
		np1 = np1->n_left;
		np1 = np1->n_right;
		np->n_right = np1;
*/
		if( pcnt == 1 ){
			np1 = np->n_right;
			np1 = np1->n_left;
			np1 = np1->n_right;
			np->n_right = np1;
			np->n_val.v_value.v_ival = SC_MISMATCHES_1;
		}else if( pcnt == 2 ){
			np->n_val.v_value.v_ival = SC_MISMATCHES_2;
		}else{
			rm_wdfname = np->n_filename;
			rm_emsg_lineno = np->n_lineno;
			sprintf( emsg,
				"fix_call: function '%s' has 1 parameter.",
				 scnames[ sc ] );
			RM_errormsg( TRUE, emsg );
		}
		break;
	case SC_MISPAIRS :
	case SC_PAIRED :
		for( pcnt = 0, np1 = np->n_right; np1; np1 = np1->n_right )
			pcnt++;
		if( pcnt != 1 ){
			rm_wdfname = np->n_filename;
			rm_emsg_lineno = np->n_lineno;
			sprintf( emsg,
				"fix_call: function '%s' has 1 parameter.",
				 scnames[ sc ] );
			RM_errormsg( TRUE, emsg );
		}
		np1 = np->n_right;
		np1 = np1->n_left;
		np1 = np1->n_right;
		np->n_right = np1;
		break;
	case SC_SPRINTF :
		break;
	default :
		rm_wdfname = np->n_filename;
		rm_emsg_lineno = np->n_lineno;
		RM_errormsg( TRUE, "fix_call: unknown syscall." );
		break;
	}
}

static	void	do_fcl( INST_T *ip )
{

	rm_wdfname = ip->i_filename;
	rm_emsg_lineno = ip->i_lineno;
	RM_errormsg( TRUE, "do_fcl: Unimplemented instruction." );
}

static	void	do_scl( INST_T *ip )
{
	char	*cp, *pp;
	VALUE_T	*v_id;
	int	i, stype, idx, pos, len, size;
	int	idx2, pos2;
	static	int	eb_size = 0;
	static	char	*expbuf = NULL;
	char	*e_expbuf;
	int	n_mm;
	STREL_T	*stp, *stp2;
	IDENT_T	*idp;
	float	rval;

	switch( ip->i_val.v_value.v_ival ){
	case SC_STRID :
		v_id = &mem[ sp  ];
		stype = mem[ sp - 1 ].v_value.v_ival;
		sp = mp;
		mp = mem[ mp ].v_value.v_ival;
		mem[ sp ].v_type = T_INT;
		idx = mem[ sp ].v_value.v_ival = strid( stype, v_id );
		if( v_id->v_type == T_STRING )
			tm_free( v_id->v_value.v_pval );
		esp++;
		estk[ esp ] = idx;
		break;

	case SC_BITS :
		idx  = mem[ sp - 5 ].v_value.v_ival;
		if( idx < 0 || idx >= rm_n_xdescr ){
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			sprintf( emsg, 
		"do_scl: bits: 1st descr index must be between 1 and %d.",
				rm_n_xdescr );
			RM_errormsg( TRUE, emsg );
		}
		stp = rm_xdescr[ idx ];
		pos = mem[ sp - 4 ].v_value.v_ival;
		if( pos == UNDEF )
			pos = 1;
		else if( pos < 0 ){
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			RM_errormsg( TRUE, "do_scl: bits: pos1 must be > 0." );
		}else if( stp->s_matchlen == 0 ){
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			RM_errormsg( TRUE,
	"do_scl: bits: descr1 must have match len > 0." );
		}else if( pos > stp->s_matchlen ){
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			sprintf( emsg, "do_scl: bits: pos1 must be <= %d.",
				stp->s_matchlen );
			RM_errormsg( TRUE, emsg );
		}
		pos--;
		len  = mem[ sp - 3 ].v_value.v_ival;

		idx2 = mem[ sp - 2 ].v_value.v_ival;
		if( idx2 < 0 || idx2 >= rm_n_xdescr ){
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			sprintf( emsg, 
		"do_scl: bits: 2nd descr index must be between 1 and %d.",
				rm_n_xdescr );
			RM_errormsg( TRUE, emsg );
		}else if( idx >= idx2 ){
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			RM_errormsg( TRUE, 
		"do_scl: bits: 2nd descr index must follow 1st descr.",
				rm_n_descr );
			RM_errormsg( TRUE, emsg );
		}
		stp2 = rm_xdescr[ idx2 ];
		pos2 = mem[ sp - 1 ].v_value.v_ival;
		if( pos2 == UNDEF )
			pos2 = stp2->s_matchlen;
		else if( pos2 < 0 ){
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			RM_errormsg( TRUE, "do_scl: bits: pos2 must be > 0." );
		}else if( stp2->s_matchlen == 0 ){
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			RM_errormsg( TRUE,
	"do_scl: bits: descr2 must have match len > 0." );
		}else if( pos > stp2->s_matchlen ){
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			sprintf( emsg, "do_scl: bits: pos2 must be <= %d.",
				stp2->s_matchlen );
			RM_errormsg( TRUE, emsg );
		}
		pos2--;

		rval = RM_bits( ip, idx, pos, idx2, pos2 );
		sp = mp;
		mp = mem[ mp ].v_value.v_ival;
		mem[ sp ].v_type = T_FLOAT;
		mem[ sp ].v_value.v_dval = rval;
		break;

	case SC_EFN :
		if( !rm_efninit ){
			rm_efninit = 1;
			idp = RM_find_id( "windowsize" );
			if( RM_allocefnds( idp->i_val.v_value.v_ival ) )
				rm_efndataok = 0;
			else{
				idp = RM_find_id( "efn_datadir" );
				cp = ( char * )idp->i_val.v_value.v_pval;
				if( cp == NULL || *cp == '\0' ){
					if( ( cp = getenv( "EFNDATA" ) ) )
						strcpy( rm_efndatadir, cp );
				}else
					strcpy( rm_efndatadir, cp );
				idp = RM_find_id( "efn_usestdbp" );
				rm_efnusestdbp = idp->i_val.v_value.v_ival;
				rm_efndataok = RM_getefndata();
			}
		}

		idx  = mem[ sp - 5 ].v_value.v_ival;
		if( idx < 0 || idx >= rm_n_xdescr ){
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			sprintf( emsg, 
		"do_scl: efn: 1st descr index must be between 1 and %d.",
				rm_n_xdescr );
			RM_errormsg( TRUE, emsg );
		}
		stp = rm_xdescr[ idx ];
		pos = mem[ sp - 4 ].v_value.v_ival;
		if( pos == UNDEF )
			pos = 1;
		else if( pos < 0 ){
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			RM_errormsg( TRUE, "do_scl: efn: pos1 must be > 0." );
		}else if( stp->s_matchlen == 0 ){
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			RM_errormsg( TRUE,
	"do_scl: efn: descr1 must have match len > 0." );
		}else if( pos > stp->s_matchlen ){
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			sprintf( emsg, "do_scl: efn: pos1 must be <= %d.",
				stp->s_matchlen );
			RM_errormsg( TRUE, emsg );
		}
		pos--;
		len  = mem[ sp - 3 ].v_value.v_ival;

		idx2 = mem[ sp - 2 ].v_value.v_ival;
		if( idx2 < 0 || idx2 >= rm_n_xdescr ){
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			sprintf( emsg, 
		"do_scl: efn: 2nd descr index must be between 1 and %d.",
				rm_n_xdescr );
			RM_errormsg( TRUE, emsg );
		}else if( idx >= idx2 ){
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			RM_errormsg( TRUE, 
		"do_scl: efn: 2nd descr index must follow 1st descr.",
				rm_n_descr );
			RM_errormsg( TRUE, emsg );
		}
		stp2 = rm_xdescr[ idx2 ];
		pos2 = mem[ sp - 1 ].v_value.v_ival;
		if( pos2 == UNDEF )
			pos2 = stp2->s_matchlen;
		else if( pos2 < 0 ){
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			RM_errormsg( TRUE, "do_scl: efn: pos2 must be > 0." );
		}else if( stp2->s_matchlen == 0 ){
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			RM_errormsg( TRUE,
	"do_scl: efn: descr2 must have match len > 0." );
		}else if( pos > stp2->s_matchlen ){
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			sprintf( emsg, "do_scl: efn: pos2 must be <= %d.",
				stp2->s_matchlen );
			RM_errormsg( TRUE, emsg );
		}
		pos2--;
		if( setupefn( ip, idx, pos, idx2, pos2 ) ){
			RM_initst();
			rval = 0.01 * RM_efn( 0, rm_l_base, 1 );
		}else
			rval = EFN_INFINITY;
		sp = mp;
		mp = mem[ mp ].v_value.v_ival;
		mem[ sp ].v_type = T_FLOAT;
		mem[ sp ].v_value.v_dval = rval;
		break;

	case SC_EFN2 :
		if( !rm_efn2init ){
			rm_efn2init = 1;
			idp = RM_find_id( "windowsize" );
			if( RM_allocefnds( idp->i_val.v_value.v_ival ) )
				rm_efndataok = 0;
			else{
				idp = RM_find_id( "efn_datadir" );
				cp = ( char * )idp->i_val.v_value.v_pval;
				if( cp == NULL || *cp == '\0' ){
					if( ( cp = getenv( "EFNDATA" ) ) )
						strcpy( rm_efndatadir, cp );
				}else
					strcpy( rm_efndatadir, cp );
				idp = RM_find_id( "efn_usestdbp" );
				rm_efnusestdbp = idp->i_val.v_value.v_ival;
				rm_efn2dataok = RM_getefn2data();
			}
		}

		idx  = mem[ sp - 5 ].v_value.v_ival;
		if( idx < 0 || idx >= rm_n_xdescr ){
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			sprintf( emsg, 
		"do_scl: efn2: 1st descr index must be between 1 and %d.",
				rm_n_xdescr );
			RM_errormsg( TRUE, emsg );
		}
		stp = rm_xdescr[ idx ];
		pos = mem[ sp - 4 ].v_value.v_ival;
		if( pos == UNDEF )
			pos = 1;
		else if( pos < 0 ){
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			RM_errormsg( TRUE, "do_scl: efn2: pos1 must be > 0." );
		}else if( stp->s_matchlen == 0 ){
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			RM_errormsg( TRUE,
	"do_scl: efn2: descr1 must have match len > 0." );
		}else if( pos > stp->s_matchlen ){
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			sprintf( emsg, "do_scl: efn2: pos1 must be <= %d.",
				stp->s_matchlen );
			RM_errormsg( TRUE, emsg );
		}
		pos--;
		len  = mem[ sp - 3 ].v_value.v_ival;

		idx2 = mem[ sp - 2 ].v_value.v_ival;
		if( idx2 < 0 || idx2 >= rm_n_xdescr ){
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			sprintf( emsg, 
		"do_scl: efn2: 2nd descr index must be between 1 and %d.",
				rm_n_xdescr );
			RM_errormsg( TRUE, emsg );
		}else if( idx >= idx2 ){
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			RM_errormsg( TRUE, 
		"do_scl: efn2: 2nd descr index must follow 1st descr.",
				rm_n_descr );
			RM_errormsg( TRUE, emsg );
		}
		stp2 = rm_xdescr[ idx2 ];
		pos2 = mem[ sp - 1 ].v_value.v_ival;
		if( pos2 == UNDEF )
			pos2 = stp2->s_matchlen;
		else if( pos2 < 0 ){
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			RM_errormsg( TRUE, "do_scl: efn2: pos2 must be > 0." );
		}else if( stp2->s_matchlen == 0 ){
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			RM_errormsg( TRUE,
	"do_scl: efn2: descr2 must have match len > 0." );
		}else if( pos > stp2->s_matchlen ){
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			sprintf( emsg, "do_scl: efn2: pos2 must be <= %d.",
				stp2->s_matchlen );
			RM_errormsg( TRUE, emsg );
		}
		pos2--;
		if( setupefn( ip, idx, pos, idx2, pos2 ) ){
			RM_initst();
			rval = 0.01 * RM_efn2();
		}else
			rval = EFN_INFINITY;
		sp = mp;
		mp = mem[ mp ].v_value.v_ival;
		mem[ sp ].v_type = T_FLOAT;
		mem[ sp ].v_value.v_dval = rval;
		break;

	case SC_LENGTH :
		cp = mem[ sp ].v_value.v_pval;
		len = strlen( cp );
		tm_free( cp );
		sp = mp;
		mp = mem[ mp ].v_value.v_ival;
		mem[ sp ].v_type = T_INT;
		mem[ sp ].v_value.v_ival = len;
		break; 

	case SC_LOC :
		idx  = mem[ sp - 2 ].v_value.v_ival;
		if( idx < 0 || idx >= rm_n_xdescr ){
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			sprintf( emsg, 
		"do_scl: loc: descr index must be between 1 and %d.",
				rm_n_xdescr );
			RM_errormsg( TRUE, emsg );
		}
		stp = rm_xdescr[ idx ];
		pos = mem[ sp - 1 ].v_value.v_ival;
		if( pos == UNDEF )
			pos = 1;
		else if( pos < 0 ){
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			RM_errormsg( TRUE, "do_scl: loc: pos must be > 0." );
		}else if( stp->s_matchlen == 0 ){
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			RM_errormsg( TRUE,
	"do_scl: loc: descr must have match len > 0." );
		}else if( pos > stp->s_matchlen ){
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			sprintf( emsg, "do_scl: loc: pos must be <= %d.",
				stp->s_matchlen );
			RM_errormsg( TRUE, emsg );
		}
		pos--;
		len  = mem[ sp ].v_value.v_ival;
		sp = mp;
		mp = mem[ mp ].v_value.v_ival;
		mem[ sp ].v_type = T_INT;
		mem[ sp ].v_value.v_ival = stp->s_matchoff + 1;
		break;

/*
	case SC_MISMATCHES :
*/
	case SC_MISMATCHES_1 :
		idx = mem[ sp - 2 ].v_value.v_ival;
		if( idx < 0 || idx >= rm_n_xdescr ){
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			sprintf( emsg, 
		"do_scl: mismatches: descr index must be between 1 and %d.",
				rm_n_xdescr );
			RM_errormsg( TRUE, emsg );
		}
		stp = rm_xdescr[ idx ];
		sp = mp;
		mp = mem[ mp ].v_value.v_ival;
		mem[ sp ].v_type = T_INT;
		mem[ sp ].v_value.v_ival = stp->s_n_mismatches;
		break;

	case SC_MISMATCHES_2 :
		pp = mem[ sp ].v_value.v_pval;
		size = RE_BPC * strlen( pp );
		if( size > eb_size ){
			if( expbuf != NULL ){
				free( expbuf );
				expbuf = NULL;
			}
			eb_size = size;
			expbuf = ( char * )malloc( eb_size * sizeof( char ) );
			if( expbuf == NULL ){
				rm_wdfname = ip->i_filename;
				rm_emsg_lineno = ip->i_lineno;
				RM_errormsg( TRUE,
					"do_scl: can't alloc expbuf" );
			}
		}
		e_expbuf = &expbuf[ eb_size ];
		compile( pp, expbuf, e_expbuf, '\0' );
		cp = mem[ sp - 1 ].v_value.v_pval;

		circf = *pp == '^';
		mm_step( cp, expbuf, eb_size, &n_mm );
/*
fprintf( stderr, "mm2: cp = '%s', pp = '%s', n_mm = %d, \n", cp, pp, n_mm );
*/
		tm_free( pp );
		tm_free( cp );
		sp = mp;
		mp = mem[ mp ].v_value.v_ival;
		mem[ sp ].v_type = T_INT;
		mem[ sp ].v_value.v_ival = n_mm;
		break;

	case SC_MISPAIRS :
		idx = mem[ sp - 2 ].v_value.v_ival;
		if( idx < 0 || idx >= rm_n_xdescr ){
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			sprintf( emsg, 
		"do_scl: mispairs: descr index must be between 1 and %d.",
				rm_n_xdescr );
			RM_errormsg( TRUE, emsg );
		}
		stp = rm_xdescr[ idx ];
		sp = mp;
		mp = mem[ mp ].v_value.v_ival;
		mem[ sp ].v_type = T_INT;
		mem[ sp ].v_value.v_ival = stp->s_n_mispairs;
		break;

	case SC_PAIRED :
		idx = mem[ sp - 2 ].v_value.v_ival;
		if( idx < 0 || idx >= rm_n_xdescr ){
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			sprintf( emsg, 
		"do_scl: paired: descr index must be between 1 and %d.",
				rm_n_xdescr );
			RM_errormsg( TRUE, emsg );
		}
		stp = rm_xdescr[ idx ];
		
		pos = mem[ sp - 1 ].v_value.v_ival;
		if( pos < 1 || pos > stp->s_matchlen ){
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			sprintf( emsg, 
		"do_scl: paired: pos must be between 1 and %d.",
				stp->s_matchlen );
			RM_errormsg( TRUE, emsg );
		}
		pos--;

		len = mem[ sp ].v_value.v_ival;
		if( len == 0 ){
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			sprintf( emsg, "do_scl: paired: len must be > 0." );
			RM_errormsg( TRUE, emsg );
		}else if( len < 0 )
			len = stp->s_matchlen - pos;
		else
			len = MIN( stp->s_matchlen - pos, len );
		sp = mp;
		mp = mem[ mp ].v_value.v_ival;
		mem[ sp ].v_type = T_INT;
		mem[ sp ].v_value.v_ival = paired( stp, pos, len );
		break;

	case SC_SPRINTF :
		do_sprintf( ip );
		cp = ( char * )malloc( strlen( sprintfbuf ) + 1 );
		if( cp == NULL ){
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			RM_errormsg( TRUE, "do_strf: can't allocate cp1." );
		}
		strcpy( cp, sprintfbuf );
		for( i = sp; i > mp; i-- ){
			if( mem[ i ].v_type == T_STRING )
				tm_free( mem[ i ].v_value.v_pval );
		}
		sp = mp;
		mp = mem[ mp ].v_value.v_ival;
		mem[ sp ].v_type = T_STRING;
		mem[ sp ].v_value.v_pval = cp;
		break;

	default :
		rm_wdfname = ip->i_filename;
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( TRUE, "do_scl: undefined syscall." );
		break;
	}
}

static	int	paired( STREL_T *stp, int pos, int len )
{
	STREL_T	*stp1, *stp2, *stp3, *stp4;
	int	i, mlen;
	int	p1, p2, p3, p4;
	int	b1, b2, b3, b4;

	mlen = stp->s_matchlen;
	switch( stp->s_n_mates ){
	case 1 : 
		if( stp->s_index < stp->s_mates[ 0 ]->s_index )
			stp1 = stp;
		else
			stp1 = stp->s_mates[ 0 ];
		stp2 = stp1->s_mates[ 0 ];
		p1 = stp1->s_matchoff;
		p2 = stp2->s_matchoff + mlen - 1;
		for( i = 0; i < len; i++ ){
			b1 = sc_sbuf[ p1 + pos + i ];
			b2 = sc_sbuf[ p2 - pos - i ];
			if( !RM_paired( stp1->s_pairset, b1, b2 ) )
				return( 0 );
		}
		return( 1 );
		break;
	case 2 :
		if( stp->s_index < stp->s_mates[ 0 ]->s_index )
			stp1 = stp;
		else
			stp1 = stp->s_mates[ 0 ];
		stp2 = stp1->s_mates[ 0 ];
		stp3 = stp1->s_mates[ 1 ];
		p1 = stp1->s_matchoff;
		p2 = stp2->s_matchoff + mlen - 1;
		p3 = stp3->s_matchoff;
		for( i = 0; i < len; i++ ){
			b1 = sc_sbuf[ p1 + pos + i ];
			b2 = sc_sbuf[ p2 - pos - i ];
			b3 = sc_sbuf[ p3 + pos + i ];
			if( !RM_triple( stp1->s_pairset, b1, b2, b3 ) )
				return( 0 );
		}
		return( 1 );
		break;
	case 3 :
		if( stp->s_index < stp->s_mates[ 0 ]->s_index )
			stp1 = stp;
		else
			stp1 = stp->s_mates[ 0 ];
		stp2 = stp1->s_mates[ 0 ];
		stp3 = stp1->s_mates[ 1 ];
		stp4 = stp1->s_mates[ 2 ];
		p1 = stp1->s_matchoff;
		p2 = stp2->s_matchoff + mlen - 1;
		p3 = stp3->s_matchoff;
		p4 = stp4->s_matchoff + mlen - 1;
		for( i = 0; i < len; i++ ){
			b1 = sc_sbuf[ p1 + pos + i ];
			b2 = sc_sbuf[ p2 - pos - i ];
			b3 = sc_sbuf[ p3 + pos + i ];
			b4 = sc_sbuf[ p4 - pos - i ];
			if( !RM_quad( stp1->s_pairset, b1, b2, b3, b4 ) )
				return( 0 );
		}
		return( 1 );
		break;
	default :
		rm_emsg_lineno = stp->s_lineno;
		RM_errormsg( TRUE,
			"paired() does not accept descr type 'ss'." );
		return( 0 );
		break;
	}
}

static	int	strid( int stype, VALUE_T *v_id )
{
	int	s, idx;
	STREL_T	*stp;
	char	*tag, name1[ 20 ], name2[ 20 ];

	if( v_id->v_type == T_INT ){
		idx = v_id->v_value.v_ival;
/*
		if( idx < 1 || idx > rm_n_descr ){
*/
		if( idx < 1 || idx > rm_n_xdescr ){
			rm_emsg_lineno = UNDEF;
			sprintf( emsg,
				"strid: index (%d) out of range: 1 .. %d.",
				idx, rm_n_xdescr );
			RM_errormsg( TRUE, emsg );
		}
		idx--;
/*
		stp = &rm_descr[ idx ];
*/
		stp = rm_xdescr[ idx ];
		if( stype != SYM_SE ){
			if( stp->s_type != stype ){
				mk_stref_name( stype, name1 );
				mk_stref_name( stp->s_type, name2 );
				rm_emsg_lineno = UNDEF;
				sprintf( emsg,
			"strid: descr type mismatch: is %s should be %s.",
					name1, name2 );
				RM_errormsg( TRUE, emsg );
			}
		}
	}else if( v_id->v_type == T_STRING ){
		tag = v_id->v_value.v_pval;
/*
		stp = rm_descr;
		for( idx = UNDEF, s = 0; s < rm_n_descr; s++, stp++ ){ 
*/
		for( idx = UNDEF, s = 0; s < rm_n_xdescr; s++ ){ 
			stp = rm_xdescr[ s ];
			if( stp->s_tag == NULL )
				continue;
			else if( !strcmp( stp->s_tag, tag ) ){
				if( stp->s_type == stype ){
					idx = s;
					break;
				}else if(stp->s_type==SYM_SS && stype==SYM_SE){ 
					idx = s;
					break;
				}
			}
		}
		if( idx == UNDEF ){
			rm_emsg_lineno = UNDEF;
			sprintf( emsg, "strid: no such descr '%s'.", tag );
			RM_errormsg( TRUE, emsg );
		}
	}
	return( idx );
}

static	int	do_sprintf( INST_T *ip )
{
	int	c_arg, n_args;
	char	*fstr;
	char	fmt[ 256 ];
	char	*fp, *pp, *epp;
	int	rval = 0;

	n_args = sp - mp;
	fstr = mem[ mp + 1 ].v_value.v_pval;
	sbp = sprintfbuf;
	for( c_arg = 0, fp = fstr; pp = strchr( fp, '%' ); ){
		strncpy( sbp, fp, pp - fp );
		sbp[ pp - fp ] = '\0';
		sbp += strlen( sbp );
		epp = strpbrk( &pp[ 1 ], FMTLIST );
		strncpy( fmt, pp, epp - pp + 1 );
		fmt[ epp - pp + 1 ] = '\0';
		if( rval = do_fmt( ip, fmt, n_args, &c_arg ) )
			break;
		fp = epp + 1;
	}
	strcpy( sbp, fp );
	return( rval );
}

static	int	do_fmt( INST_T *ip, char *fmt, int n_args, int *c_arg )
{
	int	l_fmt, nprt;
	int	type;
	char	work[ 256 ];
	char	posp[ 20 ], flags[ 20 ], width[ 20 ], prec[ 20 ], size[ 20 ];
	char	*efp, *sp;
	char	*dot, *star, *dollar;
	char	*wp;
	int	u_arg, r_arg;
	int	w_ind, u_wid, r_wid, p_ind, u_prec, r_prec;
	int	i_argc, u_argc;
	VALUE_T	*v_arg, *v_wid, *v_prec;
	int	rval = 0;

	nprt = 0;
	w_ind = 0; u_wid = 0;
	p_ind = 0; u_prec = 0; 
	i_argc = 0;

	l_fmt = strlen( fmt );
	efp = &fmt[ l_fmt - 1 ];
	type = *efp--;

	sp = size;
	if( *efp == 'h' || *efp == 'l' || *efp == 'L' )
		*sp++ = *efp--;
	if( *efp == 'l' )
		*sp++ = *efp--;
	*sp = '\0';

	strncpy( work, &fmt[ 1 ], efp - &fmt[ 1 ] + 1 );
	work[ efp - &fmt[ 1 ] + 1 ] = '\0';

	if( dot = strchr( work, '.' ) ){
		strcpy( prec, dot );
		*dot = '\0'; 
		if( prec[ 1 ] == '*' ){
			p_ind = 1;
			if( isdigit( prec[ 2 ] ) )
				u_prec = atoi( &prec[ 2 ] );
			else{
				u_prec = -1;
				i_argc++;
			}
		}
	}else
		*prec = '\0';

	if( star = strchr( work, '*' ) ){
		w_ind = 1;
		strcpy( width, star );
		*star = '\0';
		if( isdigit( width[ 1 ] ) ) 
			u_wid = atoi( &width[ 1 ] );
		else{
			u_wid = -1;
			i_argc++;
		}
		if( dollar = strchr( work, '$' ) ){
			dollar++;
			strncpy( posp, work, dollar - work );
			posp[ dollar - work ] = '\0'; 
			strcpy( flags, dollar );
		}else{
			*posp = '\0';
			strcpy( flags, work );
		}
	}else if( dollar = strchr( work, '$' ) ){
		dollar++;
		strncpy( posp, work, dollar - work );
		posp[ dollar - work ] = '\0'; 
		wp = dollar + strspn( dollar, FMTFLAGS );
		strncpy( flags, dollar, wp - dollar );
		flags[ wp - dollar ] = '\0';
		strcpy( width, wp );
	}else{
		*posp = '\0';
		wp = work + strspn( work, FMTFLAGS );
		strncpy( flags, work, wp - work );
		flags[ wp - work ] = '\0';
		strcpy( width, wp );
	}

	u_arg = *posp ? atoi( posp ) : -1 - i_argc;

	if( w_ind && p_ind ){
		if( u_wid == -1 && u_prec == -1 )
			u_prec = -2;
	}

	v_arg = NULL;
	r_arg = u_arg < 0 ? *c_arg - u_arg : u_arg;
	if( r_arg < 1 || r_arg >= n_args ){
		rm_wdfname = ip->i_filename;
		rm_emsg_lineno = ip->i_lineno;
		sprintf( emsg, "do_fmt: No such argument (%d).", r_arg );
		RM_errormsg( FALSE, emsg );
		rval = 1;
		goto DONE;
	}else
		v_arg = &mem[ mp + r_arg + 1 ];

	v_wid = NULL;
	r_wid = u_wid < 0 ? *c_arg - u_wid : u_wid;
	if( r_wid < 0 || r_wid >= n_args ){
		rm_wdfname = ip->i_filename;
		rm_emsg_lineno = ip->i_lineno;
		sprintf( emsg, "do_fmt: No such width argument (%d).", r_wid );
		RM_errormsg( FALSE, emsg );
		rval = 1;
		goto DONE;
	}else if( r_wid != 0 ){
		v_wid = &mem[ mp + r_wid + 1 ];
		if( v_wid->v_type != T_INT ){
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			RM_errormsg( FALSE, "do_fmt: Ind. width must be int." );
			rval = 1;
			goto DONE;
		}
	}

	v_prec = NULL;
	r_prec = u_prec < 0 ? *c_arg - u_prec : u_prec;
	if( r_prec < 0 || r_prec >= n_args ){
		rm_wdfname = ip->i_filename;
		rm_emsg_lineno = ip->i_lineno;
		sprintf( emsg,
			"do_fmt: No such prec. argument (%d).", r_prec );
		RM_errormsg( FALSE, emsg );
		rval = 1;
		goto DONE;
	}else if( r_prec != 0 ){
		v_wid = &mem[ mp + r_prec + 1 ];
		if( v_prec->v_type != T_INT ){
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			RM_errormsg( FALSE, "do_fmt: Ind. prec. must be int." );
			rval = 1;
			goto DONE;
		}
	}

	u_argc = 1;
	u_argc += r_wid != 0 ? 1 : 0;
	u_argc += r_prec != 0 ? 1 : 0;

	*c_arg += *posp ? i_argc : i_argc + 1;

	switch( type ){
	case 'b' :
	case 'B' :
	case 'e' :
	case 'E' :
	case 'f' :
	case 'g' :
	case 'G' :
		if( v_arg->v_type != T_FLOAT ){
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			sprintf( emsg,
				"do_fmt: '%c' format requires float arg.",
				type );
			RM_errormsg( FALSE, emsg );
			rval = 1;
			goto DONE;
		}	
		switch( u_argc ){
		case 1 :
			nprt = sprintf( sbp, fmt, v_arg->v_value.v_dval );
			break;
		case 2 :
			nprt = sprintf( sbp, fmt,
				v_wid ? v_wid->v_value.v_ival
					: v_prec->v_value.v_ival,
				v_arg->v_value.v_dval );
			break;
		case 3 :
			nprt = sprintf( sbp, fmt,
				v_wid->v_value.v_ival, v_prec->v_value.v_ival,
				v_arg->v_value.v_dval );
			break;
		default :
			break;
		}
		break;
	case 'd' :
	case 'i' :
		if( v_arg->v_type != T_INT ){
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			sprintf( emsg,
				"do_fmt: '%c' format requires int arg.",
				type );
			RM_errormsg( FALSE, emsg );
			rval = 1;
			goto DONE;
		}	
		switch( u_argc ){
		case 1 :
			nprt = sprintf( sbp, fmt, v_arg->v_value.v_ival );
			break;
		case 2 :
			nprt = sprintf( sbp, fmt,
				v_wid ? v_wid->v_value.v_ival
					: v_prec->v_value.v_ival,
				v_arg->v_value.v_ival );
			break;
		case 3 :
			nprt = sprintf( sbp, fmt,
				v_wid->v_value.v_ival, v_prec->v_value.v_ival,
				v_arg->v_value.v_ival );
			break;
		default :
			break;
		}
		break;
	case 'o' :
	case 'u' :
	case 'x' :
	case 'X' :
		if( v_arg->v_type != T_INT ){
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			sprintf( emsg,
				"do_fmt: '%c' format requires int arg.",
				type );
			RM_errormsg( FALSE, emsg );
			rval = 1;
			goto DONE;
		}	
		switch( u_argc ){
		case 1 :
			nprt = sprintf( sbp, fmt,
				( unsigned )v_arg->v_value.v_ival );
			break;
		case 2 :
			nprt = sprintf( sbp, fmt,
				v_wid ? v_wid->v_value.v_ival
					: v_prec->v_value.v_ival,
				( unsigned )v_arg->v_value.v_ival );
			break;
		case 3 :
			nprt = sprintf( sbp, fmt,
				v_wid->v_value.v_ival, v_prec->v_value.v_ival,
				( unsigned )v_arg->v_value.v_ival );
			break;
		default :
			break;
		}
		break;
	case 's' :
	case 'S' :
		if( v_arg->v_type != T_STRING ){
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			sprintf( emsg,
				"do_fmt: '%c' format requires string/seq arg.",
				type );
			RM_errormsg( FALSE, emsg );
			rval = 1;
			goto DONE;
		}	
		switch( u_argc ){
		case 1 :
			nprt = sprintf( sbp, fmt,
				v_arg->v_value.v_pval );
			break;
		case 2 :
			nprt = sprintf( sbp, fmt,
				v_wid ? v_wid->v_value.v_ival
					: v_prec->v_value.v_ival,
				v_arg->v_value.v_pval );
			break;
		case 3 :
			nprt = sprintf( sbp, fmt,
				v_wid->v_value.v_ival, v_prec->v_value.v_ival,
				v_arg->v_value.v_pval );
			break;
		default :
			break;
		}
		break;
	case 'n' :
		if( v_arg->v_type == T_INT )
			v_arg->v_value.v_ival = nprt;
		else if( v_arg->v_type == T_FLOAT )
			v_arg->v_value.v_dval = nprt;
		else{
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			sprintf( emsg, "do_fmt: '%c' format requires int arg.",
				type );
			RM_errormsg( FALSE, emsg );
			rval = 1;
			goto DONE;
		}
		break;
	case '%' :
		*sbp = '%';
		sbp[ 1 ] = '\0';
		nprt++;
		break;
	case 'c' :
	case 'C' :
	case 'p' :
	default :
		rm_wdfname = ip->i_filename;
		rm_emsg_lineno = ip->i_lineno;
		sprintf( emsg, "do_fmt: '%c' unsupported format.", type );
		RM_errormsg( FALSE, emsg );
		rval = 1;
		goto DONE;
		break;
	}

DONE : ;

	sbp += nprt;
	*sbp = '\0';

	return( rval );
}

static	void	do_strf( INST_T *ip )
{
	int	index;
	int	pos;
	int	len;
	STREL_T	*stp;
	char	*cp;

	len   = mem[ sp     ].v_value.v_ival;
	pos   = mem[ sp - 1 ].v_value.v_ival;
	index = mem[ sp - 2 ].v_value.v_ival;
	if( index < 0 || index >= rm_n_xdescr ){
		rm_wdfname = ip->i_filename;
		rm_emsg_lineno = ip->i_lineno;;
		sprintf( emsg, "do_strf: no such descriptor %d.", index );
		RM_errormsg( TRUE, emsg );
	}
	stp = rm_xdescr[ index ];
	if( pos == UNDEF )
		pos = 1;
	else if( pos < 0 ){
		rm_wdfname = ip->i_filename;
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( TRUE, "do_strf: pos must be > 0." );
	}else if( stp->s_matchlen == 0 ){
		pos = 1;	
	}else if( pos > stp->s_matchlen ){
		rm_wdfname = ip->i_filename;
		rm_emsg_lineno = ip->i_lineno;
		sprintf( emsg, "do_strf: pos must be <= %d.\n",
			stp->s_matchlen );
		RM_errormsg( TRUE, emsg );
	}
	pos--;
	if( len == 0 ){ 
		rm_wdfname = ip->i_filename;
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( TRUE, "do_strf: len must be > 0." );
	}else if( len == UNDEF )	/* rest of string */
		len = stp->s_matchlen - pos;
	else
		len = MIN( stp->s_matchlen - pos, len );
	cp = ( char * )tm_malloc( ( len + 1 ) * sizeof( char ), "do_strf" );
	if( cp == NULL ){
		rm_wdfname = ip->i_filename;
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( TRUE, "do_strf: can't allocate cp." );
		exit( 1 );
	}
	strncpy( cp, &sc_sbuf[ stp->s_matchoff + pos ], len );
	cp[ len ] = '\0';
	sp -= 2; 
	mem[ sp ].v_type = T_STRING;
	mem[ sp ].v_value.v_pval = cp; 
	esp--;
}

static	void	do_lda( INST_T *ip )
{
	VALUE_T	*v_top;
	IDENT_T	*idp;

	sp++;
	v_top = &mem[ sp ];
	idp = RM_find_id( ip->i_val.v_value.v_pval );
	if( idp == NULL ){
		idp = RM_enter_id( ip->i_val.v_value.v_pval, T_UNDEF, C_VAR,
			S_GLOBAL, 1, NULL );
		v_top->v_type = T_UNDEF;
		v_top->v_value.v_pval = idp;
	}else if( !idp->i_reinit ){
		rm_wdfname = ip->i_filename;
		rm_emsg_lineno = ip->i_lineno;
		sprintf( emsg, "do_lda: variable '%s' is readonly.", 
			idp->i_name );
		RM_errormsg( TRUE, emsg );
	}else{
		v_top->v_type = T_IDENT;
		v_top->v_value.v_pval = idp;
	}
}

static	void	do_lod( INST_T *ip )
{
	VALUE_T	*v_top;
	IDENT_T	*idp;
	char	*cp;

	sp++;
	v_top = &mem[ sp ];
	idp = RM_find_id( ip->i_val.v_value.v_pval );
	if( idp == NULL ){
		rm_wdfname = ip->i_filename;
		rm_emsg_lineno = ip->i_lineno;
		sprintf( emsg, "do_lod: variable '%s' is undefined.",
			ip->i_val.v_value.v_pval );
		RM_errormsg( TRUE, emsg );
	}else{
		switch( idp->i_type ){
		case T_UNDEF :
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			sprintf( emsg,
				"do_lod: variable '%s' is undefined.",
				idp->i_name );
			RM_errormsg( TRUE, emsg );
			break;
		case T_INT :
			v_top->v_type = T_INT;
			v_top->v_value.v_ival = idp->i_val.v_value.v_ival;
			break;
		case T_FLOAT :
			v_top->v_type = T_FLOAT;
			v_top->v_value.v_dval = idp->i_val.v_value.v_dval;
			break;
		case T_STRING :
			cp = ( char * )tm_malloc(
				strlen(idp->i_val.v_value.v_pval)+1, "do_lod" );
			if( cp == NULL ){
				rm_wdfname = ip->i_filename;
				rm_emsg_lineno = ip->i_lineno;
				RM_errormsg( TRUE,
					"do_lod: can't allocate cp." );
			}
			strcpy( cp, idp->i_val.v_value.v_pval );
			v_top->v_type = T_STRING;
			v_top->v_value.v_pval = cp;
			break;
		default :
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			RM_errormsg( TRUE, "do_lod: type mismatch." );
			break;
		}
	}
}

static	void	do_ldc( INST_T *ip )
{
	VALUE_T	*v_top;
	char	*cp;
	int	idx;

	sp++;
	v_top = &mem[ sp ];
	switch( ip->i_val.v_type ){
	case T_INT :
		v_top->v_type = T_INT;
		v_top->v_value.v_ival = ip->i_val.v_value.v_ival;
		break;
	case T_FLOAT :
		v_top->v_type = T_FLOAT;
		v_top->v_value.v_dval = ip->i_val.v_value.v_dval;
		break;
	case T_STRING :
		v_top->v_type = T_STRING;
		cp = ( char * )tm_malloc(
			strlen( ip->i_val.v_value.v_pval ) + 1, "do_ldc" );
		if( cp == NULL ){
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			RM_errormsg( TRUE, "do_ldc: can't allocate cp." );
		}
		strcpy( cp, ip->i_val.v_value.v_pval );
		v_top->v_value.v_pval = cp;
		break;
	case	T_POS :
		v_top->v_type = T_INT;
		idx = estk[ esp ];
		v_top->v_value.v_ival = rm_descr[ idx ].s_matchlen;
		
		break;
	case 	T_PAIRSET :
		v_top->v_type = T_PAIRSET;
		v_top->v_value.v_pval = ip->i_val.v_value.v_pval;
		break;
	default :
		rm_wdfname = ip->i_filename;
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( TRUE, "do_ldc: type mismatch." );
		break;
	}
}

static	void	do_sto( INST_T *ip )
{
	VALUE_T	*v_tm1, *v_top;
	int	t_tm1, t_top;
	IDENT_T	*idp;
	char	*cp;

	v_top = &mem[ sp ];
	t_top = v_top->v_type;
	sp--;
	v_tm1 = &mem[ sp ];
	idp = v_tm1->v_value.v_pval;
	t_tm1 = idp->i_type;
	
	switch( T_IJ( t_tm1, t_top ) ){
	case T_IJ( T_UNDEF, T_INT ):
		v_tm1->v_type = T_INT;
		idp->i_type = T_INT;
		idp->i_val.v_type = T_INT;
		idp->i_val.v_value.v_ival = v_top->v_value.v_ival;
		break;
	case T_IJ( T_UNDEF, T_FLOAT ):
		v_tm1->v_type = T_FLOAT;
		idp->i_type = T_FLOAT;
		idp->i_val.v_type = T_FLOAT;
		idp->i_val.v_value.v_dval = v_top->v_value.v_dval;
		break;
	case T_IJ( T_UNDEF, T_STRING ):
		cp = ( char * )tm_malloc(
			strlen( v_top->v_value.v_pval ) + 1, "do_sto: US" );
		if( cp == NULL ){
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			RM_errormsg( TRUE,
				"do_sto: can't allocate new string." );
		}
		strcpy( cp, v_top->v_value.v_pval );
		idp->i_type = T_STRING;
		idp->i_val.v_type = T_STRING;
		idp->i_val.v_value.v_pval = cp;
		tm_free( v_top->v_value.v_pval );
		break;
	case T_IJ( T_INT, T_INT ) :
		idp->i_val.v_value.v_ival = v_top->v_value.v_ival;
		break;
	case T_IJ( T_INT, T_FLOAT ) :
		idp->i_val.v_value.v_ival = v_top->v_value.v_dval;
		break;
	case T_IJ( T_FLOAT, T_INT ) :
		idp->i_val.v_value.v_dval = v_top->v_value.v_ival;
		break;
	case T_IJ( T_FLOAT, T_FLOAT ) :
		idp->i_val.v_value.v_dval = v_top->v_value.v_dval;
		break;
	case T_IJ( T_STRING, T_STRING ) :
		cp = ( char * )tm_malloc(
			strlen( v_top->v_value.v_pval ) + 1, "do_sto: SS" );
		if( cp == NULL ){
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			RM_errormsg( TRUE,
				"do_sto: can't allocate new string." );
		}
		strcpy( cp, v_top->v_value.v_pval );
		tm_free( idp->i_val.v_value.v_pval );
		idp->i_val.v_value.v_pval = cp;
		tm_free( v_top->v_value.v_pval );
		break;
	default :
		rm_wdfname = ip->i_filename;
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( TRUE, "do_sto: type mismatch." );
		break;
	}
}

static	void	do_and( INST_T *ip )
{
	VALUE_T	*v_top;
	int	t_top, rv;
	char	*cp;

	v_top = &mem[ sp ];
	t_top = v_top->v_type;

	switch( t_top ){
	case T_INT :
		rv = v_top->v_value.v_ival = v_top->v_value.v_ival != 0;
		break;
	case T_FLOAT :
		rv = v_top->v_value.v_ival = v_top->v_value.v_dval != 0.0;
		break;
	case T_STRING :
/*
		rv = v_top->v_value.v_ival =
			*( char * )v_top->v_value.v_pval != '\0';
*/
		cp = ( char * )v_top->v_value.v_pval;
		rv = v_top->v_value.v_ival =
			*( char * )v_top->v_value.v_pval != '\0';
		tm_free( cp );
		break;
	default :
		rm_wdfname = ip->i_filename;
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( TRUE, "do_and: type mismatch." );
		break;
	}
	if( !rv )
		pc = ip->i_val.v_value.v_ival;
}

static	void	do_ior( INST_T *ip )
{
	VALUE_T	*v_top;
	int	t_top, rv;
	char	*cp;

	v_top = &mem[ sp ];
	t_top = v_top->v_type;

	switch( t_top ){
	case T_INT :
		rv = v_top->v_value.v_ival = v_top->v_value.v_ival != 0;
		break;
	case T_FLOAT :
		rv = v_top->v_value.v_ival = v_top->v_value.v_dval != 0.0;
		break;
	case T_STRING :
/*
		rv = v_top->v_value.v_ival =
			*( char * )v_top->v_value.v_pval != '\0';
*/
		cp = ( char * )v_top->v_value.v_pval;
		rv = v_top->v_value.v_ival =
			*( char * )v_top->v_value.v_pval != '\0';
		tm_free( cp );
		break;
	default :
		rm_wdfname = ip->i_filename;
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( TRUE, "do_ior: type mismatch." );
		break;
	}
	if( rv )
		pc = ip->i_val.v_value.v_ival;
}

static	void	do_not( INST_T *ip )
{
	VALUE_T	*v_top;
	int	t_top;

	v_top = &mem[ sp ];
	t_top = v_top->v_type;

	switch( t_top ){
	case T_INT :
		v_top->v_value.v_ival = !( v_top->v_value.v_ival != 0 );
		break;
	case T_FLOAT :
		v_top->v_value.v_ival = !( v_top->v_value.v_dval != 0.0 );
		break;
	case T_STRING :
		v_top->v_value.v_ival =
			!( *( char * )v_top->v_value.v_pval != '\0' );
		break;
	default :
		rm_wdfname = ip->i_filename;
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( TRUE, "do_not: type mismatch." );
		break;
	}
}

static	void	do_mat( INST_T *ip )
{
	VALUE_T	*v_tm1, *v_top;
	int	t_tm1, t_top;
	char	*s_tm1, *s_top;
/*
#define	EXPBUF_SIZE	256
	static	char	expbuf[ EXPBUF_SIZE ];
*/
	char	*expbuf;
	int	expbuf_size;

	v_top = &mem[ sp ];
	t_top = v_top->v_type;
	sp--;
	v_tm1 = &mem[ sp ];
	t_tm1 = v_tm1->v_type;
	v_tm1->v_type = T_INT;

	switch( T_IJ( t_tm1, t_top ) ){
	case T_IJ( T_STRING, T_STRING ) :
		s_tm1 = v_tm1->v_value.v_pval;
		s_top = v_top->v_value.v_pval;
/*
		compile( s_top, expbuf, &expbuf[ EXPBUF_SIZE ], '\0' );
*/
		expbuf_size = RE_BPC * strlen( s_top );
		expbuf = ( char * )malloc( expbuf_size * sizeof( char ) );
		compile( s_top, expbuf, &expbuf[ expbuf_size ], '\0' );
		v_tm1->v_value.v_ival = step( s_tm1, expbuf );
		tm_free( expbuf );
		tm_free( s_top );
		tm_free( s_tm1 );
		break;
	default :
		rm_wdfname = ip->i_filename;
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( TRUE, "do_mat: type mismatch." );
		break;
	}
}

static	void	do_ins( INST_T *ip )
{
	VALUE_T	*v_bases[ 4 ], *v_top;
	char	*s_bases[ 4 ];
	int	l0, l_bases[ 4 ];
	int	i, n_bases;
	int	rv;
	PAIRSET_T	*ps_top;

	n_bases = sp - mp - 1;
	if( n_bases < 2 || n_bases > 4 ){
		rm_wdfname = ip->i_filename;
		rm_emsg_lineno = ip->i_lineno;
		sprintf( emsg, "do_ins: pair has %d bases, requires %d-%d.",
			n_bases, 2, 4 );
		RM_errormsg( TRUE, emsg );
	}

	v_top = &mem[ sp ];
	if( v_top->v_type != T_PAIRSET ){
		rm_wdfname = ip->i_filename;
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( TRUE,
			"do_ins: rhs of \"in\" must have type pairset." );
	}
	ps_top = v_top->v_value.v_pval;
	for( l0 = UNDEF, i = 0; i < n_bases; i++ ){
		v_bases[ i ] = &mem[ mp + 1 + i ];
		if( v_bases[ i ]->v_type != T_STRING ){
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			RM_errormsg( TRUE,
				"do_ins: pair elements must be type string." );
		}
		l_bases[ i ] = strlen( v_bases[ i ]->v_value.v_pval );
		if( l0 == UNDEF )
			l0 = l_bases[ i ]; 
		else if( l_bases[ i ] != l0 ){
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			RM_errormsg( TRUE,
		"do_ins: all pair elements must have the same length." );
		}
		s_bases[ i ] = v_bases[ i ]->v_value.v_pval;
	}

	switch( n_bases ){
	case 2 :
		for( rv = 1, i = 0; i < l0; i++ ){
			if( !RM_paired( ps_top, s_bases[0][i], s_bases[1][i] ) )
			{
				rv = 0;
				break;
			}
		}
		break;
	case 3 :
		for( rv = 1, i = 0; i < l0; i++ ){
			if( !RM_triple( ps_top,
				s_bases[0][i], s_bases[1][i], s_bases[2][i] ) )
			{
				rv = 0;
				break;
			}
		}
		break;
	case 4 :
		for( rv = 1, i = 0; i < l0; i++ ){
			if( !RM_quad( ps_top,
				s_bases[0][i], s_bases[1][i],
				s_bases[2][i], s_bases[3][i] ) )
			{
				rv = 0;
				break;
			}
		}
		break;
	}

	for( i = 0; i < n_bases; i++ ){
		tm_free( mem[ mp + 1 + i ].v_value.v_pval );
	}

	sp = mp;
	mp = mem[ mp ].v_value.v_ival;
	mem[ sp ].v_type = T_INT;
	mem[ sp ].v_value.v_ival = rv;
}

static	void	do_gtr( INST_T *ip )
{
	VALUE_T	*v_tm1, *v_top;
	int	t_tm1, t_top;
	char	*s_tm1, *s_top;

	v_top = &mem[ sp ];
	t_top = v_top->v_type;
	sp--;
	v_tm1 = &mem[ sp ];
	t_tm1 = v_tm1->v_type;
	v_tm1->v_type = T_INT;
	
	switch( T_IJ( t_tm1, t_top ) ){
	case T_IJ( T_INT, T_INT ) :
		v_tm1->v_value.v_ival =
			v_tm1->v_value.v_ival > v_top->v_value.v_ival;
		break;
	case T_IJ( T_INT, T_FLOAT ) :
		v_tm1->v_value.v_ival =
			v_tm1->v_value.v_ival > v_top->v_value.v_dval;
		break;
	case T_IJ( T_FLOAT, T_INT ) :
		v_tm1->v_value.v_ival =
			v_tm1->v_value.v_dval > v_top->v_value.v_ival;
		break;
	case T_IJ( T_FLOAT, T_FLOAT ) :
		v_tm1->v_value.v_ival =
			v_tm1->v_value.v_dval > v_top->v_value.v_dval;
		break;
	case T_IJ( T_STRING, T_STRING ) :
		s_tm1 = v_tm1->v_value.v_pval;
		s_top = v_top->v_value.v_pval;
		v_tm1->v_value.v_ival = strcmp( s_tm1, s_top ) > 0;
		tm_free( s_top );
		tm_free( s_tm1 );
		break;
	default :
		rm_wdfname = ip->i_filename;
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( TRUE, "do_gtr: type mismatch." );
		break;
	}
}

static	void	do_geq( INST_T *ip )
{
	VALUE_T	*v_tm1, *v_top;
	int	t_tm1, t_top;
	char	*s_tm1, *s_top;

	v_top = &mem[ sp ];
	t_top = v_top->v_type;
	sp--;
	v_tm1 = &mem[ sp ];
	t_tm1 = v_tm1->v_type;
	v_tm1->v_type = T_INT;
	
	switch( T_IJ( t_tm1, t_top ) ){
	case T_IJ( T_INT, T_INT ) :
		v_tm1->v_value.v_ival =
			v_tm1->v_value.v_ival >= v_top->v_value.v_ival;
		break;
	case T_IJ( T_INT, T_FLOAT ) :
		v_tm1->v_value.v_ival =
			v_tm1->v_value.v_ival >= v_top->v_value.v_dval;
		break;
	case T_IJ( T_FLOAT, T_INT ) :
		v_tm1->v_value.v_ival =
			v_tm1->v_value.v_dval >= v_top->v_value.v_ival;
		break;
	case T_IJ( T_FLOAT, T_FLOAT ) :
		v_tm1->v_value.v_ival =
			v_tm1->v_value.v_dval >= v_top->v_value.v_dval;
		break;
	case T_IJ( T_STRING, T_STRING ) :
		s_tm1 = v_tm1->v_value.v_pval;
		s_top = v_top->v_value.v_pval;
		v_tm1->v_value.v_ival = strcmp( s_tm1, s_top ) >= 0;
		tm_free( s_top );
		tm_free( s_tm1 );
		break;
	default :
		rm_wdfname = ip->i_filename;
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( TRUE, "do_geq: type mismatch." );
		exit( 1 );
		break;
	}
}

static	void	do_equ( INST_T *ip )
{
	VALUE_T	*v_tm1, *v_top;
	int	t_tm1, t_top;
	char	*s_tm1, *s_top;

	v_top = &mem[ sp ];
	t_top = v_top->v_type;
	sp--;
	v_tm1 = &mem[ sp ];
	t_tm1 = v_tm1->v_type;
	v_tm1->v_type = T_INT;
	
	switch( T_IJ( t_tm1, t_top ) ){
	case T_IJ( T_INT, T_INT ) :
		v_tm1->v_value.v_ival =
			v_tm1->v_value.v_ival == v_top->v_value.v_ival;
		break;
	case T_IJ( T_INT, T_FLOAT ) :
		v_tm1->v_value.v_ival =
			v_tm1->v_value.v_ival == v_top->v_value.v_dval;
		break;
	case T_IJ( T_FLOAT, T_INT ) :
		v_tm1->v_value.v_ival =
			v_tm1->v_value.v_dval == v_top->v_value.v_ival;
		break;
	case T_IJ( T_FLOAT, T_FLOAT ) :
		v_tm1->v_value.v_ival =
			v_tm1->v_value.v_dval == v_top->v_value.v_dval;
		break;
	case T_IJ( T_STRING, T_STRING ) :
		s_tm1 = v_tm1->v_value.v_pval;
		s_top = v_top->v_value.v_pval;
		v_tm1->v_value.v_ival = strcmp( s_tm1, s_top ) == 0;
		tm_free( s_top );
		tm_free( s_tm1 );
		break;
	default :
		rm_wdfname = ip->i_filename;
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( TRUE, "do_equ: type mismatch." );
		break;
	}
}

static	void	do_neq( INST_T *ip )
{
	VALUE_T	*v_tm1, *v_top;
	int	t_tm1, t_top;
	char	*s_tm1, *s_top;

	v_top = &mem[ sp ];
	t_top = v_top->v_type;
	sp--;
	v_tm1 = &mem[ sp ];
	t_tm1 = v_tm1->v_type;
	v_tm1->v_type = T_INT;
	
	switch( T_IJ( t_tm1, t_top ) ){
	case T_IJ( T_INT, T_INT ) :
		v_tm1->v_value.v_ival =
			v_tm1->v_value.v_ival != v_top->v_value.v_ival;
		break;
	case T_IJ( T_INT, T_FLOAT ) :
		v_tm1->v_value.v_ival =
			v_tm1->v_value.v_ival != v_top->v_value.v_dval;
		break;
	case T_IJ( T_FLOAT, T_INT ) :
		v_tm1->v_value.v_ival =
			v_tm1->v_value.v_dval != v_top->v_value.v_ival;
		break;
	case T_IJ( T_FLOAT, T_FLOAT ) :
		v_tm1->v_value.v_ival =
			v_tm1->v_value.v_dval != v_top->v_value.v_dval;
		break;
	case T_IJ( T_STRING, T_STRING ) :
		s_tm1 = v_tm1->v_value.v_pval;
		s_top = v_top->v_value.v_pval;
		v_tm1->v_value.v_ival = strcmp( s_tm1, s_top ) != 0;
		tm_free( s_top );
		tm_free( s_tm1 );
		break;
	default :
		rm_wdfname = ip->i_filename;
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( TRUE, "do_neq: type mismatch." );
		break;
	}
}

static	void	do_leq( INST_T *ip )
{
	VALUE_T	*v_tm1, *v_top;
	int	t_tm1, t_top;
	char	*s_tm1, *s_top;

	v_top = &mem[ sp ];
	t_top = v_top->v_type;
	sp--;
	v_tm1 = &mem[ sp ];
	t_tm1 = v_tm1->v_type;
	v_tm1->v_type = T_INT;
	
	switch( T_IJ( t_tm1, t_top ) ){
	case T_IJ( T_INT, T_INT ) :
		v_tm1->v_value.v_ival =
			v_tm1->v_value.v_ival <= v_top->v_value.v_ival;
		break;
	case T_IJ( T_INT, T_FLOAT ) :
		v_tm1->v_value.v_ival =
			v_tm1->v_value.v_ival <= v_top->v_value.v_dval;
		break;
	case T_IJ( T_FLOAT, T_INT ) :
		v_tm1->v_value.v_ival =
			v_tm1->v_value.v_dval <= v_top->v_value.v_ival;
		break;
	case T_IJ( T_FLOAT, T_FLOAT ) :
		v_tm1->v_value.v_ival =
			v_tm1->v_value.v_dval <= v_top->v_value.v_dval;
		break;
	case T_IJ( T_STRING, T_STRING ) :
		s_tm1 = v_tm1->v_value.v_pval;
		s_top = v_top->v_value.v_pval;
		v_tm1->v_value.v_ival = strcmp( s_tm1, s_top ) <= 0;
		tm_free( s_top );
		tm_free( s_tm1 );
		break;
	default :
		rm_wdfname = ip->i_filename;
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( TRUE, "do_leq: type mismatch." );
		break;
	}
}

static	void	do_les( INST_T *ip )
{
	VALUE_T	*v_tm1, *v_top;
	int	t_tm1, t_top;
	char	*s_tm1, *s_top;

	v_top = &mem[ sp ];
	t_top = v_top->v_type;
	sp--;
	v_tm1 = &mem[ sp ];
	t_tm1 = v_tm1->v_type;
	v_tm1->v_type = T_INT;
	
	switch( T_IJ( t_tm1, t_top ) ){
	case T_IJ( T_INT, T_INT ) :
		v_tm1->v_value.v_ival =
			v_tm1->v_value.v_ival < v_top->v_value.v_ival;
		break;
	case T_IJ( T_INT, T_FLOAT ) :
		v_tm1->v_value.v_ival =
			v_tm1->v_value.v_ival < v_top->v_value.v_dval;
		break;
	case T_IJ( T_FLOAT, T_INT ) :
		v_tm1->v_value.v_ival =
			v_tm1->v_value.v_dval < v_top->v_value.v_ival;
		break;
	case T_IJ( T_FLOAT, T_FLOAT ) :
		v_tm1->v_value.v_ival =
			v_tm1->v_value.v_dval < v_top->v_value.v_dval;
		break;
	case T_IJ( T_STRING, T_STRING ) :
		s_tm1 = v_tm1->v_value.v_pval;
		s_top = v_top->v_value.v_pval;
		v_tm1->v_value.v_ival = strcmp( s_tm1, s_top ) < 0;
		tm_free( s_top );
		tm_free( s_tm1 );
		break;
	default :
		rm_wdfname = ip->i_filename;
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( TRUE, "do_les: type mismatch." );
		break;
	}
}

static	void	do_add( INST_T *ip )
{
	VALUE_T	*v_tm1, *v_top;
	int	t_tm1, t_top;
	char	*s_tm1, *s_top;
	char	*cp;

	v_top = &mem[ sp ];
	t_top = v_top->v_type;
	sp--;
	v_tm1 = &mem[ sp ];
	t_tm1 = v_tm1->v_type;
	
	switch( T_IJ( t_tm1, t_top ) ){
	case T_IJ( T_INT, T_INT ) :
		v_tm1->v_value.v_ival += v_top->v_value.v_ival;
		break;
	case T_IJ( T_INT, T_FLOAT ) :
		v_tm1->v_value.v_ival += v_top->v_value.v_dval;
		break;
	case T_IJ( T_FLOAT, T_INT ) :
		v_tm1->v_value.v_dval += v_top->v_value.v_ival;
		break;
	case T_IJ( T_FLOAT, T_FLOAT ) :
		v_tm1->v_value.v_dval += v_top->v_value.v_dval;
		break;
	case T_IJ( T_STRING, T_STRING ) :
		s_tm1 = v_tm1->v_value.v_pval;
		s_top = v_top->v_value.v_pval;
		cp = ( char * )tm_malloc(
			strlen( s_tm1 ) + strlen( s_top ) + 1, "do_add" );
		if( cp == NULL ){
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			RM_errormsg( TRUE,
				"do_add: can't allocate new string." );
		}
		strcpy( cp, s_tm1 );
		strcat( cp, s_top );
		v_tm1->v_value.v_pval = cp;
		tm_free( s_top );
		tm_free( s_tm1 );
		break;
	default :
		rm_wdfname = ip->i_filename;
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( TRUE, "do_add: type mismatch." );
		break;
	}
}

static	void	do_sub( INST_T *ip )
{
	VALUE_T	*v_tm1, *v_top;
	int	t_tm1, t_top;

	v_top = &mem[ sp ];
	t_top = v_top->v_type;
	sp--;
	v_tm1 = &mem[ sp ];
	t_tm1 = v_tm1->v_type;
	
	switch( T_IJ( t_tm1, t_top ) ){
	case T_IJ( T_INT, T_INT ) :
		v_tm1->v_value.v_ival -= v_top->v_value.v_ival;
		break;
	case T_IJ( T_INT, T_FLOAT ) :
		v_tm1->v_value.v_ival -= v_top->v_value.v_dval;
		break;
	case T_IJ( T_FLOAT, T_INT ) :
		v_tm1->v_value.v_dval -= v_top->v_value.v_ival;
		break;
	case T_IJ( T_FLOAT, T_FLOAT ) :
		v_tm1->v_value.v_dval -= v_top->v_value.v_dval;
		break;
	default :
		rm_wdfname = ip->i_filename;
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( TRUE, "do_sub: type mismatch." );
		break;
	}
}

static	void	do_mul( INST_T *ip )
{
	VALUE_T	*v_tm1, *v_top;
	int	t_tm1, t_top;

	v_top = &mem[ sp ];
	t_top = v_top->v_type;
	sp--;
	v_tm1 = &mem[ sp ];
	t_tm1 = v_tm1->v_type;
	
	switch( T_IJ( t_tm1, t_top ) ){
	case T_IJ( T_INT, T_INT ) :
		v_tm1->v_value.v_ival *= v_top->v_value.v_ival;
		break;
	case T_IJ( T_INT, T_FLOAT ) :
		v_tm1->v_value.v_ival *= v_top->v_value.v_dval;
		break;
	case T_IJ( T_FLOAT, T_INT ) :
		v_tm1->v_value.v_dval *= v_top->v_value.v_ival;
		break;
	case T_IJ( T_FLOAT, T_FLOAT ) :
		v_tm1->v_value.v_dval *= v_top->v_value.v_dval;
		break;
	default :
		rm_wdfname = ip->i_filename;
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( TRUE, "do_mul: type mismatch." );
		break;
	}
}

static	void	do_div( INST_T *ip )
{
	VALUE_T	*v_tm1, *v_top;
	int	t_tm1, t_top;

	v_top = &mem[ sp ];
	t_top = v_top->v_type;
	sp--;
	v_tm1 = &mem[ sp ];
	t_tm1 = v_tm1->v_type;
	
	switch( T_IJ( t_tm1, t_top ) ){
	case T_IJ( T_INT, T_INT ) :
		v_tm1->v_value.v_ival /= v_top->v_value.v_ival;
		break;
	case T_IJ( T_INT, T_FLOAT ) :
		v_tm1->v_value.v_ival /= v_top->v_value.v_dval;
		break;
	case T_IJ( T_FLOAT, T_INT ) :
		v_tm1->v_value.v_dval /= v_top->v_value.v_ival;
		break;
	case T_IJ( T_FLOAT, T_FLOAT ) :
		v_tm1->v_value.v_dval /= v_top->v_value.v_dval;
		break;
	default :
		rm_wdfname = ip->i_filename;
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( TRUE, "do_div: type mismatch." );
		break;
	}
}

static	void	do_mod( INST_T *ip )
{
	VALUE_T	*v_tm1, *v_top;
	int	t_tm1, t_top;

	v_top = &mem[ sp ];
	t_top = v_top->v_type;
	sp--;
	v_tm1 = &mem[ sp ];
	t_tm1 = v_tm1->v_type;
	
	switch( T_IJ( t_tm1, t_top ) ){
	case T_IJ( T_INT, T_INT ) :
		v_tm1->v_value.v_ival %= v_top->v_value.v_ival;
		break;
	default :
		rm_wdfname = ip->i_filename;
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( TRUE, "do_mod: type mismatch." );
		break;
	}
}

static	void	do_neg( INST_T *ip )
{
	VALUE_T	*v_top;
	int	t_top;

	v_top = &mem[ sp ];
	t_top = v_top->v_type;
	
	switch( t_top ){
	case T_INT :
		v_top->v_value.v_ival = -v_top->v_value.v_ival;
		break;
	case T_FLOAT :
		v_top->v_value.v_dval = -v_top->v_value.v_dval;
		break;
	default :
		rm_wdfname = ip->i_filename;
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( TRUE, "do_neg: type mismatch." );
		break;
	}
}

static	void	do_i_pp( INST_T *ip )
{
	VALUE_T	*v_top;
	int	t_top;
	IDENT_T	*idp;

	v_top = &mem[ sp ];
	idp = v_top->v_value.v_pval;
	t_top = idp->i_type;
	
	switch( t_top ){
	case T_UNDEF :
		rm_wdfname = ip->i_filename;
		rm_emsg_lineno = ip->i_lineno;
		sprintf( emsg, "do_i_pp: variable '%s' is undefined.",
			idp->i_name );
		RM_errormsg( TRUE, emsg );
		break;
	case T_INT :
		v_top->v_value.v_ival = ( idp->i_val.v_value.v_ival )++;
		break;
	default :
		rm_wdfname = ip->i_filename;
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( TRUE, "do_i_pp: type mismatch." );
		break;
	}
}

static	void	do_pp_i( INST_T *ip )
{
	VALUE_T	*v_top;
	int	t_top;
	IDENT_T	*idp;

	v_top = &mem[ sp ];
	idp = v_top->v_value.v_pval;
	t_top = idp->i_type;
	
	switch( t_top ){
	case T_UNDEF :
		rm_wdfname = ip->i_filename;
		rm_emsg_lineno = ip->i_lineno;
		sprintf( emsg, "do_pp_i: variable '%s' is undefined.",
			idp->i_name );
		RM_errormsg( TRUE, emsg );
		break;
	case T_INT :
		v_top->v_value.v_ival = ++( idp->i_val.v_value.v_ival );
		break;
	default :
		rm_wdfname = ip->i_filename;
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( TRUE, "do_pp_i: type mismatch." );
		break;
	}
}

static	void	do_i_mm( INST_T *ip )
{
	VALUE_T	*v_top;
	int	t_top;
	IDENT_T	*idp;

	v_top = &mem[ sp ];
	idp = v_top->v_value.v_pval;
	t_top = idp->i_type;
	
	switch( t_top ){
	case T_UNDEF :
		rm_wdfname = ip->i_filename;
		rm_emsg_lineno = ip->i_lineno;
		sprintf( emsg, "do_i_mm: variable '%s' is undefined.",
			idp->i_name );
		RM_errormsg( TRUE, emsg );
		break;
	case T_INT :
		v_top->v_value.v_ival = ( idp->i_val.v_value.v_ival )--;
		break;
	default :
		rm_wdfname = ip->i_filename;
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( TRUE, "do_i_mm: type mismatch." );
		exit( 1 );
		break;
	}
}

static	void	do_mm_i( INST_T *ip )
{
	VALUE_T	*v_top;
	int	t_top;
	IDENT_T	*idp;

	v_top = &mem[ sp ];
	idp = v_top->v_value.v_pval;
	t_top = idp->i_type;
	
	switch( t_top ){
	case T_UNDEF :
		rm_wdfname = ip->i_filename;
		rm_emsg_lineno = ip->i_lineno;
		sprintf( emsg, "do_mm_i: variable '%s' is undefined.",
			idp->i_name );
		RM_errormsg( TRUE, emsg );
		break;
	case T_INT :
		v_top->v_value.v_ival = --( idp->i_val.v_value.v_ival );
		break;
	default :
		rm_wdfname = ip->i_filename;
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( TRUE, "do_mm_i: type mismatch." );
		break;
	}
}

static	float	RM_bits( INST_T *ip, int idx, int pos, int idx2, int pos2 )
{
	STREL_T	*stp, *stp2;
	int	i, start, stop;
	char	*bp;
	int	bc, bi, bn, len;
	int	bindex[ 4 ];
	int	bvec[ 4 ];
	double	bits;

	stp = rm_xdescr[ idx ];
	stp2 = rm_xdescr[ idx2 ];
	start = stp->s_matchoff + pos;
	stop = stp2->s_matchoff + pos2;
	len = stop - start + 1;

	for( i = 0; i < 4; i++ ){
		bindex[ i ] = UNDEF;
		bvec[ i ] = 0;
	}

	for( i = 0; i < 4; i++ ){
		bindex[ i ] = UNDEF;
		bvec[ i ] = 0;
	}

	for( bn = 0, bp = &sc_sbuf[ start ], i = start; i <= stop; i++, bp++ ){
		if( ( bc = rm_b2bc[ *bp ] ) != BCODE_N ){
			if( ( bi = bindex[ bc ] ) == UNDEF )
				bi = bindex[ bc ] = bn++;
			bvec[ bi ]++;
				
		}
	}

	for( bits = 0.0, i = 0; i < 4; i++ ){
		if( bvec[ i ] != 0 )
			bits += bvec[ i ] * LG( 1.0 * bvec[ i ] / len );
	}
	bits /= -len;

	return( bits );
}

static	int	setupefn( INST_T *ip, int idx, int pos, int idx2, int pos2 )
{
	int	i, p, inc;
	int	off, off5, len;
	STREL_T	*stp, *stp5, *stp3;
	char	*bp;

	stp5 = rm_xdescr[ idx ];
	off5 = stp5->s_matchoff;
	stp3 = rm_xdescr[ idx2 ];
	for( len = 0, stp = stp5, i = idx; i <= idx2; i++, stp++ ){
		len += stp->s_matchlen;
	}
	len -= pos;
	len -= stp3->s_matchlen - ( pos2 + 1 );
	if( sc_comp ){
		off = sc_slen - stp5->s_matchoff + pos;
		inc = -1;
	}else{
		off = stp5->s_matchoff + 1 + pos;
		inc = 1;
	}

	i = 0;
	bp = &sc_sbuf[ stp5->s_matchoff + pos ];
	for( p = pos; p < stp5->s_matchlen; p++, i++ ){
		rm_bcseq[ i ] = rm_b2bc[ *bp++ ];
		if( stp5->s_type == SYM_H5 ){
			if( !setbp( ip, stp5, p, i, off5, len, rm_basepr ) ){
				return( 0 );
			}
		}else if( stp5->s_type == SYM_H3 ){	/* treat as ss() */
			rm_basepr[ i ] = UNDEF;
		}else if( stp5->s_type == SYM_SS ){
			rm_basepr[ i ] = UNDEF;
		}else{
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			RM_errormsg( TRUE, 
		"setupefn: efn()/efn2() only works on h5/ss/h3 elements." );
			return( 0 );
		} 
		rm_hstnum[ i ] = off + i * inc;
	}
	for( stp = &rm_descr[ stp5->s_index + 1 ]; stp < stp3; stp++ ){
		bp = &sc_sbuf[ stp->s_matchoff ];
		for( p = 0; p < stp->s_matchlen; p++, i++ ){
			rm_bcseq[ i ] = rm_b2bc[ *bp++ ];
			if( stp->s_type == SYM_H5 ){
				if( !setbp( ip,
					stp, p, i, off5, len, rm_basepr ) )
				{
					return( 0 );
				}
			}else if( stp->s_type == SYM_H3 ){
				if( !setbp( ip,
					stp, p, i, off5, len, rm_basepr ) )
				{
					return( 0 );
				}
			}else if( stp->s_type == SYM_SS ){
				rm_basepr[ i ] = UNDEF;
			}else{
				rm_wdfname = ip->i_filename;
				rm_emsg_lineno = ip->i_lineno;
				RM_errormsg( TRUE, 
		"setupefn: efn()/efn2() only works on h5/ss/h3 elements." );
				return( 0 );
			}
			rm_hstnum[ i ] = off + i * inc;
		}
	}
	bp = &sc_sbuf[ stp3->s_matchoff ];
	for( p = 0; p <= pos2; p++, i++ ){
		rm_bcseq[ i ] = rm_b2bc[ *bp++ ];
		if( stp3->s_type == SYM_H5 ){	/* treat as ss() */
			rm_basepr[ i ] = UNDEF;
		}else if( stp3->s_type == SYM_H3 ){
			if( !setbp( ip, stp3, p, i, off5, len, rm_basepr ) ){
				return( 0 );
			}
		}else if( stp3->s_type == SYM_SS ){
			rm_basepr[ i ] = UNDEF;
		}else{
			rm_wdfname = ip->i_filename;
			rm_emsg_lineno = ip->i_lineno;
			RM_errormsg( TRUE, 
		"setupefn: efn()/efn2() only works on h5/ss/h3 elements." );
			return( 0 );
		} 
		rm_hstnum[ i ] = off + i * inc;
	}
	rm_l_base = len - 1;

	return( 1 );
}

static	int	setbp( INST_T *ip, STREL_T *stp, int p, int i, int off, int len,
	int basepr[] )
{
	STREL_T	*stp1;
	int	p1;
	int	bp, bp1;
	int	b, b1;
	PAIRSET_T	*ps;

	if( !stp->s_attr[ SA_PROPER ] ){
		rm_wdfname = ip->i_filename;
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( TRUE, 
			"setbp: efn()/efn2() does not work on pknots." );
		return( 0 );
	}
	bp = p + stp->s_matchoff - off;
	b = sc_sbuf[ p + stp->s_matchoff ];

	stp1 = stp->s_mates[ 0 ];
	p1 = stp1->s_matchlen - p - 1;
	bp1 = p1 + stp1->s_matchoff - off;
	b1 = sc_sbuf[ p1 + stp1->s_matchoff ];

	if( bp1 < 0 || bp1 >= len ){
		rm_wdfname = ip->i_filename;
		rm_emsg_lineno = ip->i_lineno;
		sprintf( emsg, "setbp: out of bounds bp: %4d.%4d\n", bp, bp1 ); 
		RM_errormsg( TRUE, emsg );
		return( 0 );
	}else{
		ps = rm_efnusestdbp ? rm_efnstdbp : stp->s_pairset;
		basepr[ i ] = RM_paired( ps, b, b1 ) ? bp1 : UNDEF;
	}

	return( 1 );
}

static	void	mk_stref_name( int sym, char name[] )
{

	switch( sym ){
	case SYM_SE :
		strcpy( name, "se" );
		break;

	case SYM_SS :
		strcpy( name, "ss" );
		break;

	case SYM_H5 :
		strcpy( name, "h5" );
		break;
	case SYM_H3 :
		strcpy( name, "h3" );
		break;

	case SYM_P5 :
		strcpy( name, "p5" );
		break;
	case SYM_P3 :
		strcpy( name, "p3" );
		break;

	case SYM_T1 :
		strcpy( name, "t1" );
		break;
	case SYM_T2 :
		strcpy( name, "t2" );
		break;
	case SYM_T3 :
		strcpy( name, "t3" );
		break;

	case SYM_Q1 :
		strcpy( name, "q1" );
		break;
	case SYM_Q2 :
		strcpy( name, "q2" );
		break;
	case SYM_Q3 :
		strcpy( name, "q3" );
		break;
	case SYM_Q4 :
		strcpy( name, "q4" );
		break;

	default :
		sprintf( name, " ?%d? ", sym );
		break;
	}
}

static	void	addnode( int lval, NODE_T *np, int l_andor )
{
	VALUE_T	v_node;

	rm_wdfname = np->n_filename;
	rm_emsg_lineno = np->n_lineno;
	switch( np->n_sym ){

	case SYM_CALL :
		v_node.v_type = T_INT;
		v_node.v_value.v_ival = np->n_val.v_value.v_ival;
		addinst( np, OP_SCL, &v_node );
		break;
	case SYM_LIST :
		break;
	case SYM_KW_STREF :
	case SYM_IX_STREF :
		break;

	case SYM_PARMS :
		break;
	case SYM_DESCR :
		break;
	case SYM_SITES :
		break;

	case SYM_CTX :
	case SYM_SS :
	case SYM_H5 :
	case SYM_H3 :
	case SYM_P5 :
	case SYM_P3 :
	case SYM_T1 :
	case SYM_T2 :
	case SYM_T3 :
	case SYM_Q1 :
	case SYM_Q2 :
	case SYM_Q3 :
	case SYM_Q4 :
	case SYM_SE :
		break;

	case SYM_ELSE :
		break;
	case SYM_FOR :
		break;
	case SYM_IF :
		break;
	case SYM_WHILE :
		break;

	case SYM_IDENT :
		if( lval ){
			addinst( np, OP_LDA, &np->n_val );
		}else{
			addinst( np, OP_LOD, &np->n_val );
		}
		break;
	case SYM_INT :
		addinst( np, OP_LDC, &np->n_val );
		break;
	case SYM_FLOAT :
		addinst( np, OP_LDC, &np->n_val );
		break;
	case SYM_STRING :
		addinst( np, OP_LDC, &np->n_val );
		break;
	case SYM_DOLLAR :
		v_node.v_type = T_POS;
		v_node.v_value.v_pval = NULL;
		addinst( np, OP_LDC, &v_node );
		break;
	case SYM_PAIRSET :
		addinst( np, OP_LDC, &np->n_val );
		break;

	case SYM_ASSIGN :
		addinst( np, OP_STO, NULL );
		break;

	case SYM_PLUS_ASSIGN :
		addinst( np, OP_ADD, NULL );
		addinst( np, OP_STO, NULL );
		break;
	case SYM_MINUS_ASSIGN :
		addinst( np, OP_SUB, NULL );
		addinst( np, OP_STO, NULL );
		break;
	case SYM_PERCENT_ASSIGN :
		addinst( np, OP_MOD, NULL );
		addinst( np, OP_STO, NULL );
		break;
	case SYM_STAR_ASSIGN :
		addinst( np, OP_MUL, NULL );
		addinst( np, OP_STO, NULL );
		break;
	case SYM_SLASH_ASSIGN :
		addinst( np, OP_DIV, NULL );
		addinst( np, OP_STO, NULL );
		break;

	case SYM_AND :
		v_lab.v_type = T_INT;
		v_lab.v_value.v_ival = l_andor;
		addinst( np, OP_AND, &v_lab );
		break;
	case SYM_OR :
		v_lab.v_type = T_INT;
		v_lab.v_value.v_ival = l_andor;
		addinst( np, OP_IOR, &v_lab );
		break;
	case SYM_NOT :
		addinst( np, OP_NOT, NULL );
		break;

	case SYM_EQUAL :
		addinst( np, OP_EQU, NULL );
		break;
	case SYM_NOT_EQUAL :
		addinst( np, OP_NEQ, NULL );
		break;
	case SYM_GREATER :
		addinst( np, OP_GTR, NULL );
		break;
	case SYM_GREATER_EQUAL :
		addinst( np, OP_GEQ, NULL );
		break;
	case SYM_LESS :
		addinst( np, OP_LES, NULL );
		break;
	case SYM_LESS_EQUAL :
		addinst( np, OP_LEQ, NULL );
		break;

	case SYM_MATCH :
		addinst( np, OP_MAT, NULL );
		break;
	case SYM_DONT_MATCH :
		addinst( np, OP_MAT, NULL );
		addinst( np, OP_NOT, NULL );
		break;
	case SYM_IN :
		addinst( np, OP_INS, NULL );
		break;

	case SYM_PLUS :
		addinst( np, OP_ADD, NULL );
		break;
	case SYM_MINUS :
		addinst( np, OP_SUB, NULL );
		break;
	case SYM_PERCENT :
		addinst( np, OP_MOD, NULL );
		break;
	case SYM_STAR :
		addinst( np, OP_MUL, NULL );
		break;
	case SYM_SLASH :
		addinst( np, OP_DIV, NULL );
		break;
	case SYM_NEGATE :
		addinst( np, OP_NEG, NULL );
		break;

	case SYM_COLON :
		break;

	case SYM_MINUS_MINUS :
		if( np->n_left ){
			addinst( np, OP_I_MM, NULL );
		}else{
			addinst( np, OP_MM_I, NULL );
		}
		break;
	case SYM_PLUS_PLUS :
		if( np->n_left ){
			addinst( np, OP_I_PP, NULL );
		}else{
			addinst( np, OP_PP_I, NULL );
		}
		break;

	case SYM_LPAREN :
		break;
	case SYM_RPAREN :
		break;
	case SYM_LCURLY :
		break;
	case SYM_RCURLY :
		break;
	case SYM_COMMA :
		break;
	case SYM_SEMICOLON :
		break;
	case SYM_ERROR :
		RM_errormsg( TRUE, "addnode: SYM_ERROR." );
		break;
	default :
		sprintf( emsg, "addnode: Unknown symbol %d\n", np->n_sym );
		RM_errormsg( TRUE, emsg );
		break;
	}
}

static	void	addinst( NODE_T *np, int op, VALUE_T *vp )
{
	INST_T	*ip;
	char	*sp;

	if( pc >= PROG_SIZE ){
		RM_errormsg( TRUE, "addinst: program size exceeded." );
	}else{
		ip = &prog[ l_prog ];
		l_prog++;
		if( np != NULL ){
			ip->i_filename = np->n_filename;
			ip->i_lineno = np->n_lineno;
		}else{
			ip->i_filename = " -- No File -- ";
			ip->i_lineno = UNDEF;
		}
		ip->i_op = op;
		if( vp == NULL ){
			ip->i_val.v_type = T_UNDEF;
			ip->i_val.v_value.v_ival = 0;
		}else{
			ip->i_val.v_type = vp->v_type;
			if( vp->v_type == T_INT )
				ip->i_val.v_value.v_ival = vp->v_value.v_ival;
			else if( vp->v_type == T_FLOAT )
				ip->i_val.v_value.v_dval = vp->v_value.v_dval;
			else if( vp->v_type==T_STRING || vp->v_type==T_IDENT ){
				sp = ( char * )malloc( 
					strlen( vp->v_value.v_pval ) + 1 );
				if( sp == NULL ){
					RM_errormsg( TRUE,
						"addinst: can't allocate sp." );
				}
				strcpy( sp, vp->v_value.v_pval );
				ip->i_val.v_value.v_pval = sp;
			}else if( vp->v_type == T_PAIRSET ){
				ip->i_val.v_value.v_pval = vp->v_value.v_pval;
			}
		}
	}
}

static	void	dumpinst( FILE *fp, int i, INST_T * ip )
{
	VALUE_T	*vp;
	
	if( ip->i_op < 0 || ip->i_op >= N_OP ){
		rm_wdfname = ip->i_filename;
		rm_emsg_lineno = ip->i_lineno;
		sprintf( emsg, "dumpinst: bad op %d\n", ip->i_op );
		RM_errormsg( TRUE, emsg );
	}

	fprintf( fp, "%5d ", i );
	fprintf( fp, "  %s", opnames[ ip->i_op ] );
	switch( ip->i_op ){
	case OP_NOOP :
	case OP_ACPT :
	case OP_RJCT :
	case OP_MRK :
	case OP_CLS :
		break;

	case OP_FCL :
	case OP_SCL :
		break;
	case OP_STRF :
		break;

	case OP_LDA :
	case OP_LOD :
		break;

	case OP_LDC :
		break;

	case OP_STO :
		break;

	case OP_AND :
	case OP_IOR :
		break;

	case OP_NOT :
		break;

	case OP_MAT :
	case OP_INS :
	case OP_GTR :
	case OP_GEQ :
	case OP_EQU :
	case OP_NEQ :
	case OP_LEQ :
	case OP_LES :
		break;

	case OP_ADD :
	case OP_SUB :
	case OP_MUL :
	case OP_DIV :
	case OP_MOD :
		break;

	case OP_NEG :
		break;

	case OP_I_PP :
	case OP_PP_I :
	case OP_I_MM :
	case OP_MM_I :
		break;

	case OP_FJP :
	case OP_JMP :
		break;
	}
	vp = &ip->i_val;
	if( ip->i_op == OP_LDA || ip->i_op == OP_LOD ){
		fprintf( fp, " %s", vp->v_value.v_pval );
	}else if( ip->i_op == OP_SCL ){
		fprintf( fp, " %s", scnames[ vp->v_value.v_ival ] );
	}else if( vp->v_type == T_INT ){
		fprintf( fp, " %d", vp->v_value.v_ival );
	}else if( vp->v_type == T_FLOAT ) 
		fprintf( fp, " %f", vp->v_value.v_dval );
	else if( vp->v_type == T_STRING )
		fprintf( fp, " \"%s\"", vp->v_value.v_pval );
	else if( vp->v_type == T_POS )
		fprintf( fp, " $" );
	else if( vp->v_type == T_IDENT )
		fprintf( fp, " %s", vp->v_value.v_pval );
	else if( vp->v_type == T_PAIRSET ){
		fprintf( fp, " " );
		RM_dump_pairset( fp, vp->v_value.v_pval );
	}
	fprintf( fp, "\n" );
}

static	void	dumpstk( FILE *fp, char msg[] )
{
	int	i;
	VALUE_T	*vp;

	fprintf( fp, "%s: sp = %5d, mp = %5d\n", msg, sp, mp );
	for( vp = mem, i = 0; i <= sp; i++, vp++ ){
		fprintf( fp, "  mem[%4d]: ", i );
		switch( vp->v_type ){
		case T_UNDEF :
			fprintf( fp, "U " );
			break;
		case T_INT :
			fprintf( fp, "I %6d", vp->v_value.v_ival );
			break;
		case T_FLOAT :
			fprintf( fp, "F %8.3lf", vp->v_value.v_dval );
			break;
		case T_STRING :
			fprintf( fp, "S \"%s\"", vp->v_value.v_pval );
			break;
		case T_PAIRSET :
			fprintf( fp, "Pr" );
			break;
		case T_POS :
			fprintf( fp, "Ps" );
			break;
		case T_IDENT :
			fprintf( fp, "Id" );
			break;
		default :
			fprintf( fp, "? " );
			break;
		}
		fprintf( fp, "\n" );
	}
}

static	char	*tm_malloc( int size, char id[] )
{
	char	*ptr;

	ptr = ( char * )malloc( size * sizeof( char ) );
#ifdef	MEMDEBUG
	if( tm_n_mem < TM_MEM_SIZE ){
		tm_mem[ tm_n_mem ].t_freed = 0;
		tm_mem[ tm_n_mem ].t_id = id;
		tm_mem[ tm_n_mem ].t_pc = pc - 1;
		tm_mem[ tm_n_mem ].t_addr = ptr;
		tm_n_mem++;
	}
#endif
	return( ptr );
}

static	void	tm_free( void *ptr )
{
#ifdef	MEMDEBUG
	int	i;
#endif

	free( ptr );
#ifdef	MEMDEBUG
	for( i = 0;i < tm_n_mem; i++ ){
		if( tm_mem[ i ].t_addr == ptr ){
			tm_mem[ i ].t_freed = 1;
		}
	}
#endif
}

static	void	tm_report( void )
{
	int	i;
	static	int	cnt = 0;

	for( i = 0; i < tm_n_mem; i++ ){
		fprintf( stderr, "tm_mem[%4d]:", i );
		fprintf( stderr, " addr = %8p, freed = %d, pc = %4d, id = %s\n",
			tm_mem[i].t_addr, tm_mem[i].t_freed,
			tm_mem[i].t_pc, tm_mem[i].t_id );
	}
	cnt++;
	if( cnt > 1 )
		exit( 1 );
}
@


1.61
log
@added new r/o variable SLEN holding the len of the current
sequence.  Can be use in the score section.
@
text
@d270 1
a270 1
static	int	setbp( STREL_T *, int, int, int, int, int [] );
d3217 2
a3218 1
			if( !setbp( stp5, p, i, off5, len, rm_basepr ) ){
d3228 1
a3228 1
			"setupefn: efn() only works on h5/ss/h3 elements." );
d3238 4
a3241 1
				if( !setbp( stp, p, i, off5, len, rm_basepr ) ){
d3244 4
a3247 1
				if( !setbp( stp, p, i, off5, len, rm_basepr ) ){
d3255 1
a3255 1
			"setupefn: efn() only works on h5/ss/h3 elements." );
d3267 2
a3268 1
			if( !setbp( stp3, p, i, off5, len, rm_basepr ) ){
d3276 1
a3276 1
			"setupefn: efn() only works on h5/ss/h3 elements." );
d3286 1
a3286 1
static	int	setbp( STREL_T *stp, int p, int i, int off, int len,
d3295 7
d3311 4
a3314 1
fprintf( stderr, "out of bounds bp: %4d.%4d\n", bp, bp1 ); 
@


1.60
log
@converted the 0,1 in RM_errormsg to FALSE,TRUE
@
text
@d70 1
d529 4
d555 1
a555 1
	sc_slen = slen;
@


1.59
log
@added new include file, rmdefs.h.  Defines UNDEF, FALSE, TRUE; only UNDEF
used now.
@
text
@d425 1
a425 1
			RM_errormsg( 1, emsg );
d448 1
a448 1
			RM_errormsg( 1, emsg );
d513 1
a513 1
		RM_errormsg( 1, "RM_linkscore: can't allocate rm_xdescr." );
d557 1
a557 1
			RM_errormsg( 1, emsg );
d691 1
a691 1
			RM_errormsg( 1, emsg );
d791 1
a791 1
					RM_errormsg( 1,
d799 1
a799 1
					RM_errormsg( 1,
d807 1
a807 1
					RM_errormsg( 1,
d815 1
a815 1
					RM_errormsg( 1,
d825 1
a825 1
				RM_errormsg( 1, emsg );
d837 1
a837 1
		RM_errormsg( 1,
d947 2
a948 1
		RM_errormsg( 1, "fix_call: STRID can not be called by user." );
d961 1
a961 1
			RM_errormsg( 1, emsg );
d975 1
a975 1
			RM_errormsg( 1, emsg );
d987 1
a987 1
			RM_errormsg( 1, emsg );
d1005 1
a1005 1
			RM_errormsg( 1, emsg );
d1015 1
a1015 1
			RM_errormsg( 1, emsg );
d1030 1
a1030 1
			RM_errormsg( 1, emsg );
d1051 1
a1051 1
			RM_errormsg( 1, emsg );
d1064 1
a1064 1
			RM_errormsg( 1, emsg );
d1076 1
a1076 1
		RM_errormsg( 1, "fix_call: unknown syscall." );
d1086 1
a1086 1
	RM_errormsg( 1, "do_fcl: Unimplemented instruction." );
d1125 1
a1125 1
			RM_errormsg( 1, emsg );
d1134 1
a1134 1
			RM_errormsg( 1, "do_scl: bits: pos1 must be > 0." );
d1138 1
a1138 1
			RM_errormsg( 1,
d1145 1
a1145 1
			RM_errormsg( 1, emsg );
d1157 1
a1157 1
			RM_errormsg( 1, emsg );
d1161 1
a1161 1
			RM_errormsg( 1, 
d1164 1
a1164 1
			RM_errormsg( 1, emsg );
d1173 1
a1173 1
			RM_errormsg( 1, "do_scl: bits: pos2 must be > 0." );
d1177 1
a1177 1
			RM_errormsg( 1,
d1184 1
a1184 1
			RM_errormsg( 1, emsg );
d1222 1
a1222 1
			RM_errormsg( 1, emsg );
d1231 1
a1231 1
			RM_errormsg( 1, "do_scl: efn: pos1 must be > 0." );
d1235 1
a1235 1
			RM_errormsg( 1,
d1242 1
a1242 1
			RM_errormsg( 1, emsg );
d1254 1
a1254 1
			RM_errormsg( 1, emsg );
d1258 1
a1258 1
			RM_errormsg( 1, 
d1261 1
a1261 1
			RM_errormsg( 1, emsg );
d1270 1
a1270 1
			RM_errormsg( 1, "do_scl: efn: pos2 must be > 0." );
d1274 1
a1274 1
			RM_errormsg( 1,
d1281 1
a1281 1
			RM_errormsg( 1, emsg );
d1322 1
a1322 1
			RM_errormsg( 1, emsg );
d1331 1
a1331 1
			RM_errormsg( 1, "do_scl: efn2: pos1 must be > 0." );
d1335 1
a1335 1
			RM_errormsg( 1,
d1342 1
a1342 1
			RM_errormsg( 1, emsg );
d1354 1
a1354 1
			RM_errormsg( 1, emsg );
d1358 1
a1358 1
			RM_errormsg( 1, 
d1361 1
a1361 1
			RM_errormsg( 1, emsg );
d1370 1
a1370 1
			RM_errormsg( 1, "do_scl: efn2: pos2 must be > 0." );
d1374 1
a1374 1
			RM_errormsg( 1,
d1381 1
a1381 1
			RM_errormsg( 1, emsg );
d1413 1
a1413 1
			RM_errormsg( 1, emsg );
d1422 1
a1422 1
			RM_errormsg( 1, "do_scl: loc: pos must be > 0." );
d1426 1
a1426 1
			RM_errormsg( 1,
d1433 1
a1433 1
			RM_errormsg( 1, emsg );
d1454 1
a1454 1
			RM_errormsg( 1, emsg );
d1476 2
a1477 1
				RM_errormsg( 1, "do_scl: can't alloc expbuf" );
d1505 1
a1505 1
			RM_errormsg( 1, emsg );
d1522 1
a1522 1
			RM_errormsg( 1, emsg );
d1533 1
a1533 1
			RM_errormsg( 1, emsg );
d1542 1
a1542 1
			RM_errormsg( 1, emsg );
d1559 1
a1559 1
			RM_errormsg( 1, "do_strf: can't allocate cp1." );
d1575 1
a1575 1
		RM_errormsg( 1, "do_scl: undefined syscall." );
d1648 2
a1649 1
		RM_errormsg( 1, "paired() does not accept descr type 'ss'." );
d1671 1
a1671 1
			RM_errormsg( 1, emsg );
d1686 1
a1686 1
				RM_errormsg( 1, emsg );
d1712 1
a1712 1
			RM_errormsg( 1, emsg );
d1841 1
a1841 1
		RM_errormsg( 0, emsg );
d1853 1
a1853 1
		RM_errormsg( 0, emsg );
d1861 1
a1861 1
			RM_errormsg( 0, "do_fmt: Ind. width must be int." );
d1874 1
a1874 1
		RM_errormsg( 0, emsg );
d1882 1
a1882 1
			RM_errormsg( 0, "do_fmt: Ind. prec. must be int." );
d1908 1
a1908 1
			RM_errormsg( 0, emsg );
d1939 1
a1939 1
			RM_errormsg( 0, emsg );
d1972 1
a1972 1
			RM_errormsg( 0, emsg );
d2004 1
a2004 1
			RM_errormsg( 0, emsg );
d2038 1
a2038 1
			RM_errormsg( 0, emsg );
d2055 1
a2055 1
		RM_errormsg( 0, emsg );
d2084 1
a2084 1
		RM_errormsg( 1, emsg );
d2092 1
a2092 1
		RM_errormsg( 1, "do_strf: pos must be > 0." );
d2100 1
a2100 1
		RM_errormsg( 1, emsg );
d2106 1
a2106 1
		RM_errormsg( 1, "do_strf: len must be > 0." );
d2115 1
a2115 1
		RM_errormsg( 1, "do_strf: can't allocate cp." );
d2144 1
a2144 1
		RM_errormsg( 1, emsg );
d2165 1
a2165 1
		RM_errormsg( 1, emsg );
d2174 1
a2174 1
			RM_errormsg( 1, emsg );
d2190 2
a2191 1
				RM_errormsg( 1, "do_lod: can't allocate cp." );
d2200 1
a2200 1
			RM_errormsg( 1, "do_lod: type mismatch." );
d2230 1
a2230 1
			RM_errormsg( 1, "do_ldc: can't allocate cp." );
d2248 1
a2248 1
		RM_errormsg( 1, "do_ldc: type mismatch." );
d2286 2
a2287 1
			RM_errormsg( 1, "do_sto: can't allocate new string." );
d2313 2
a2314 1
			RM_errormsg( 1, "do_sto: can't allocate new string." );
d2324 1
a2324 1
		RM_errormsg( 1, "do_sto: type mismatch." );
d2358 1
a2358 1
		RM_errormsg( 1, "do_and: type mismatch." );
d2394 1
a2394 1
		RM_errormsg( 1, "do_ior: type mismatch." );
d2423 1
a2423 1
		RM_errormsg( 1, "do_not: type mismatch." );
d2465 1
a2465 1
		RM_errormsg( 1, "do_mat: type mismatch." );
d2485 1
a2485 1
		RM_errormsg( 1, emsg );
d2492 1
a2492 1
		RM_errormsg( 1,
d2501 1
a2501 1
			RM_errormsg( 1,
d2510 1
a2510 1
			RM_errormsg( 1,
d2599 1
a2599 1
		RM_errormsg( 1, "do_gtr: type mismatch." );
d2644 1
a2644 1
		RM_errormsg( 1, "do_geq: type mismatch." );
d2690 1
a2690 1
		RM_errormsg( 1, "do_equ: type mismatch." );
d2735 1
a2735 1
		RM_errormsg( 1, "do_neq: type mismatch." );
d2780 1
a2780 1
		RM_errormsg( 1, "do_leq: type mismatch." );
d2825 1
a2825 1
		RM_errormsg( 1, "do_les: type mismatch." );
d2864 2
a2865 1
			RM_errormsg( 1, "do_add: can't allocate new string." );
d2876 1
a2876 1
		RM_errormsg( 1, "do_add: type mismatch." );
d2908 1
a2908 1
		RM_errormsg( 1, "do_sub: type mismatch." );
d2940 1
a2940 1
		RM_errormsg( 1, "do_mul: type mismatch." );
d2972 1
a2972 1
		RM_errormsg( 1, "do_div: type mismatch." );
d2995 1
a2995 1
		RM_errormsg( 1, "do_mod: type mismatch." );
d3018 1
a3018 1
		RM_errormsg( 1, "do_neg: type mismatch." );
d3039 1
a3039 1
		RM_errormsg( 1, emsg );
d3047 1
a3047 1
		RM_errormsg( 1, "do_i_pp: type mismatch." );
d3068 1
a3068 1
		RM_errormsg( 1, emsg );
d3076 1
a3076 1
		RM_errormsg( 1, "do_pp_i: type mismatch." );
d3097 1
a3097 1
		RM_errormsg( 1, emsg );
d3105 1
a3105 1
		RM_errormsg( 1, "do_i_mm: type mismatch." );
d3127 1
a3127 1
		RM_errormsg( 1, emsg );
d3135 1
a3135 1
		RM_errormsg( 1, "do_mm_i: type mismatch." );
d3221 1
a3221 1
			RM_errormsg( 1, 
d3242 1
a3242 1
				RM_errormsg( 1, 
d3262 1
a3262 1
			RM_errormsg( 1, 
d3551 1
a3551 1
		RM_errormsg( 1, "addnode: SYM_ERROR." );
d3555 1
a3555 1
		RM_errormsg( 1, emsg );
d3566 1
a3566 1
		RM_errormsg( 1, "addinst: program size exceeded." );
d3591 1
a3591 1
					RM_errormsg( 1,
d3611 1
a3611 1
		RM_errormsg( 1, emsg );
@


1.58
log
@added new score builtin "loc()" which takes a single str-el
arg and returns the location of the 5' most nt of the current
match.  The el must match an non-empty element.  The value
is always with respect to the _current_ 5' end which is reversed
when the comp-seq is searched.
@
text
@d6 1
@


1.57
log
@1. set NSE to rm_n_xdescr as well as making it RO.
2. fixed bug in indexing of implied context descr's.
@
text
@d152 8
a159 7
#define	SC_MISMATCHES	5
#define	SC_MISMATCHES_1	6
#define	SC_MISMATCHES_2	7
#define	SC_MISPAIRS	8
#define	SC_PAIRED	9
#define	SC_SPRINTF	10
#define	N_SC		11
d167 1
d994 24
d1403 38
a2075 3
/*
	if( index < 0 || index >= rm_n_descr ){
*/
a2081 3
/*
	stp = &rm_descr[ index ];
*/
@


1.56
log
@removed unused variables that were left over from commented out code.
Removed the commented out code as well.
@
text
@d30 1
d32 1
d503 1
a503 1
	if( rm_lctx != NULL )
d505 1
a505 1
	if( rm_rctx != NULL )
d512 1
a512 1
	if( rm_lctx != NULL ){
d519 1
a519 1
	if( rm_rctx != NULL )
d523 2
a524 2
	v_svars.v_value.v_ival = rm_n_descr;
	RM_enter_id( "NSE", T_INT, C_VAR, S_GLOBAL, 1, &v_svars );
@


1.55
log
@added code to support efn2(), extended energy model that considers
coaxial stacking of helices in m-way junctions.
@
text
@a1052 2
	char	*cp;
	int	len;
a1056 11
/*
	if( !strcmp( ip->i_val.v_value.v_pval, "length" ) ){
		cp = mem[ sp ].v_value.v_pval;
		len = strlen( cp );
		tm_free( cp );
		mem[ mp ].v_type = T_INT;
		mem[ mp ].v_value.v_ival = len;
		sp = mp;
		mp = mem[ mp ].v_value.v_ival;
	}
*/
a3290 1
	int	sc;
a3296 8
/*
		if( ( sc = is_syscall( np ) ) != UNDEF ){
			v_node.v_type = T_INT;
			v_node.v_value.v_ival = sc;
			addinst( np, OP_SCL, &v_node );
		}else
			addinst( np, OP_FCL, &np->n_val );
*/
d3298 1
a3298 4
/*
		v_node.v_value.v_ival = sc = is_syscall( np );
*/
		v_node.v_value.v_ival = sc = np->n_val.v_value.v_ival;
@


1.54
log
@fixed bug in setupefn() that used rm_descr[] instead of
rm_xdescr[] to get the elements correspsonding to idx, idx2.
@
text
@d33 1
d36 1
d148 9
a156 8
#define	SC_LENGTH	3
#define	SC_MISMATCHES	4
#define	SC_MISMATCHES_1	5
#define	SC_MISMATCHES_2	6
#define	SC_MISPAIRS	7
#define	SC_PAIRED	8
#define	SC_SPRINTF	9
#define	N_SC		10
d162 1
d946 1
d1270 100
@


1.53
log
@added an overloaded version of mismatches(): mismatches( str, pat )
where str is a string and pat a pattern.  compiles the pattern and
then does a mm_step() on it returning the number of mismatches.
@
text
@d3031 1
a3031 1
	stp5 = &rm_descr[ idx ];
d3033 1
a3033 1
	stp3 = &rm_descr[ idx2 ];
@


1.52
log
@Oops! The macro LG() for bits should have used log10() instead
of log().  Fixed.
@
text
@d45 2
d148 6
a153 4
#define	SC_MISPAIRS	5
#define	SC_PAIRED	6
#define	SC_SPRINTF	7
#define	N_SC		8
d160 2
d912 1
d915 4
d930 4
d985 34
a1018 1
	case SC_MISMATCHES :
d1051 4
d1064 1
d1069 1
a1069 1
	char	*cp;
d1071 1
a1071 1
	int	i, stype, idx, pos, len;
d1073 4
d1283 1
d1285 2
d1303 33
d3206 1
d3213 7
@


1.51
log
@added new builtin, bits(), which computes the compostional complexity
of the selected sequence.
@
text
@d13 1
a13 1
#define	LG(v)		(3.32192809488736234789*log(v))
@


1.50
log
@fixed bug that failed to use rm_xdescr[] when checking the validity
of the index to the various attribute syscalls.
@
text
@d4 1
d13 1
d142 8
a149 7
#define	SC_EFN		1
#define	SC_LENGTH	2
#define	SC_MISMATCHES	3
#define	SC_MISPAIRS	4
#define	SC_PAIRED	5
#define	SC_SPRINTF	6
#define	N_SC		7	
d153 1
d252 1
d925 1
d1038 78
d1152 1
a1152 1
			RM_errormsg( 1, "efn: pos1 must be > 0." );
d1191 1
a1191 1
			RM_errormsg( 1, "efn: pos2 must be > 0." );
d2885 44
@


1.49
log
@added/modified code to handle new structure element, ctx,
for context.
@
text
@d1053 1
a1053 1
		if( idx < 0 || idx >= rm_n_descr ){
d1058 1
a1058 1
				rm_n_descr );
d1061 1
a1061 1
		stp = &rm_descr[ idx ];
d1085 1
a1085 1
		if( idx2 < 0 || idx2 >= rm_n_descr ){
d1090 1
a1090 1
				rm_n_descr );
d1100 1
a1100 1
		stp2 = &rm_descr[ idx2 ];
d1144 1
a1144 1
		if( idx < 0 || idx >= rm_n_descr ){
d1149 1
a1149 1
				rm_n_descr );
d1152 1
a1152 1
		stp = &rm_descr[ idx ];
d1161 1
a1161 1
		if( idx < 0 || idx >= rm_n_descr ){
d1166 1
a1166 1
				rm_n_descr );
d1169 1
a1169 1
		stp = &rm_descr[ idx ];
d1178 1
a1178 1
		if( idx < 0 || idx >= rm_n_descr ){
d1183 1
a1183 1
				rm_n_descr );
d1186 1
a1186 1
		stp = &rm_descr[ idx ];
@


1.48
log
@fixed bug that underallocated the buffer for regexp matches.
@
text
@d27 2
d40 3
d471 1
a471 1
	int	i;
d484 21
d1324 1
d1326 2
d1331 1
a1331 1
				idx, rm_n_descr );
d1335 1
d1337 2
d1352 1
d1355 3
a1366 10
/*
				}else{
					mk_stref_name( stype, name1 );
					mk_stref_name( stp->s_type, name2 );
					rm_emsg_lineno = UNDEF;
					sprintf( emsg,
				"strid: ambiguous descr reference: %s vs %s.",
						name1, name2 );
					RM_errormsg( 1, emsg );
*/
d1741 1
d1743 2
d1750 1
d1752 2
d3005 1
@


1.47
log
@fixed bug that had continue stmt skip to the test in for() loops
instead of the increment.  Added code to permit break L, or continue L
where L is an integer indicating the number of loops to break out of
or continue.  Default is 1.  < 1 or > Nest level is an error.
@
text
@d2065 1
d2068 3
d2083 1
d2085 4
d2090 1
@


1.46
log
@removed unused vars.
@
text
@d192 2
a193 2
void	RM_break( void );
void	RM_continue( void );
d380 1
d388 1
a388 1
void	RM_break( void )
d390 1
d392 11
d404 1
d406 2
d411 1
a411 1
void	RM_continue( void )
d413 1
d415 15
a429 2
	v_lab.v_type = T_INT;
	v_lab.v_value.v_ival = loopstk[ loopstkp - 1 ];
@


1.45
log
@added file info to each instruction (INST_T). Need as the source ofc
the instructions can be in several files now.
@
text
@a437 1
	IDENT_T	*idp;
d957 1
a957 1
	int	idx2, pos2, len2;
a1064 1
		len2 = mem[ sp     ].v_value.v_ival;
@


1.44
log
@added some error recovery to do_sprintf().
@
text
@d22 1
d154 1
d247 1
a247 1
static	void	addinst( int, int, VALUE_T * );
d276 1
a276 1
	addinst( np->n_lineno, OP_FJP, &v_lab );
d295 1
a295 1
	addinst( np->n_lineno, OP_FJP, &v_lab );
d303 1
a303 1
	addinst( UNDEF, OP_JMP, &v_lab );
d340 1
a340 1
	addinst( np->n_lineno, OP_FJP, &v_lab );
d358 1
a358 1
	addinst( UNDEF, OP_JMP, &v_lab );
d374 1
a374 1
	addinst( np->n_lineno, OP_FJP, &v_lab );
d382 1
a382 1
	addinst( UNDEF, OP_JMP, &v_lab );
d392 1
a392 1
	addinst( UNDEF, OP_JMP, &v_lab );
d400 1
a400 1
	addinst( UNDEF, OP_JMP, &v_lab );
d406 1
a406 1
	addinst( UNDEF, OP_ACPT, NULL );
d412 1
a412 1
	addinst( UNDEF, OP_RJCT, NULL );
d418 1
a418 1
	addinst( UNDEF, OP_MRK, NULL );
d424 1
a424 1
	addinst( UNDEF, OP_CLS, 0 );
d613 1
d657 1
a657 1
			addinst( np->n_lineno, OP_MRK, NULL );
d659 1
a659 1
			addinst( np->n_lineno, OP_MRK, NULL );
d679 1
a679 1
			addinst( np->n_lineno, OP_STRF, NULL );
d714 1
d722 1
d730 1
d738 1
d745 1
d755 1
d760 1
d861 1
d869 1
d883 1
d895 1
d915 1
d930 1
d999 2
a1000 1
			rm_emsg_lineno = UNDEF;
d1011 1
d1015 1
d1020 1
d1031 1
d1038 1
d1050 1
d1054 1
d1059 1
d1091 2
a1092 1
			rm_emsg_lineno = UNDEF;
d1108 2
a1109 1
			rm_emsg_lineno = UNDEF;
d1125 2
a1126 1
			rm_emsg_lineno = UNDEF;
d1136 2
a1137 1
			rm_emsg_lineno = UNDEF;
d1147 2
a1148 1
			rm_emsg_lineno = UNDEF;
d1165 1
d1181 2
a1182 1
		rm_emsg_lineno = UNDEF;
d1445 1
d1457 1
d1466 1
d1477 1
d1487 1
d1510 1
d1541 1
d1574 1
d1606 1
d1641 1
d1659 1
d1688 1
d1697 1
d1703 1
d1711 1
d1720 1
d1747 1
d1768 2
a1769 1
		rm_emsg_lineno = UNDEF;
d1776 2
a1777 1
			rm_emsg_lineno = UNDEF;
d1795 2
a1796 1
				rm_emsg_lineno = UNDEF;
d1804 1
d1834 1
d1852 1
d1890 2
a1891 1
			rm_emsg_lineno = UNDEF;
d1916 2
a1917 1
			rm_emsg_lineno = UNDEF;
d1926 1
d1960 1
d1996 1
d2025 1
d2057 1
d2075 1
d2084 1
d2093 1
d2102 1
d2191 1
d2236 1
d2282 1
d2327 1
d2372 1
d2417 1
d2456 2
a2457 1
			rm_emsg_lineno = UNDEF;
d2467 1
d2499 1
d2531 1
d2563 1
d2586 1
d2609 1
d2628 1
d2638 1
d2657 1
d2667 1
d2686 1
d2696 1
d2716 1
d2726 1
d2768 1
d2789 1
d2809 1
d2910 1
d2918 1
a2918 1
			addinst( np->n_lineno, OP_SCL, &v_node );
d2920 1
a2920 1
			addinst( np->n_lineno, OP_FCL, &np->n_val );
d2961 1
a2961 1
			addinst( np->n_lineno, OP_LDA, &np->n_val );
d2963 1
a2963 1
			addinst( np->n_lineno, OP_LOD, &np->n_val );
d2967 1
a2967 1
		addinst( np->n_lineno, OP_LDC, &np->n_val );
d2970 1
a2970 1
		addinst( np->n_lineno, OP_LDC, &np->n_val );
d2973 1
a2973 1
		addinst( np->n_lineno, OP_LDC, &np->n_val );
d2978 1
a2978 1
		addinst( np->n_lineno, OP_LDC, &v_node );
d2981 1
a2981 1
		addinst( np->n_lineno, OP_LDC, &np->n_val );
d2985 1
a2985 1
		addinst( np->n_lineno, OP_STO, NULL );
d2989 2
a2990 2
		addinst( np->n_lineno, OP_ADD, NULL );
		addinst( np->n_lineno, OP_STO, NULL );
d2993 2
a2994 2
		addinst( np->n_lineno, OP_SUB, NULL );
		addinst( np->n_lineno, OP_STO, NULL );
d2997 2
a2998 2
		addinst( np->n_lineno, OP_MOD, NULL );
		addinst( np->n_lineno, OP_STO, NULL );
d3001 2
a3002 2
		addinst( np->n_lineno, OP_MUL, NULL );
		addinst( np->n_lineno, OP_STO, NULL );
d3005 2
a3006 2
		addinst( np->n_lineno, OP_DIV, NULL );
		addinst( np->n_lineno, OP_STO, NULL );
d3012 1
a3012 1
		addinst( np->n_lineno, OP_AND, &v_lab );
d3017 1
a3017 1
		addinst( np->n_lineno, OP_IOR, &v_lab );
d3020 1
a3020 1
		addinst( np->n_lineno, OP_NOT, NULL );
d3024 1
a3024 1
		addinst( np->n_lineno, OP_EQU, NULL );
d3027 1
a3027 1
		addinst( np->n_lineno, OP_NEQ, NULL );
d3030 1
a3030 1
		addinst( np->n_lineno, OP_GTR, NULL );
d3033 1
a3033 1
		addinst( np->n_lineno, OP_GEQ, NULL );
d3036 1
a3036 1
		addinst( np->n_lineno, OP_LES, NULL );
d3039 1
a3039 1
		addinst( np->n_lineno, OP_LEQ, NULL );
d3043 1
a3043 1
		addinst( np->n_lineno, OP_MAT, NULL );
d3046 2
a3047 2
		addinst( np->n_lineno, OP_MAT, NULL );
		addinst( np->n_lineno, OP_NOT, NULL );
d3050 1
a3050 1
		addinst( np->n_lineno, OP_INS, NULL );
d3054 1
a3054 1
		addinst( np->n_lineno, OP_ADD, NULL );
d3057 1
a3057 1
		addinst( np->n_lineno, OP_SUB, NULL );
d3060 1
a3060 1
		addinst( np->n_lineno, OP_MOD, NULL );
d3063 1
a3063 1
		addinst( np->n_lineno, OP_MUL, NULL );
d3066 1
a3066 1
		addinst( np->n_lineno, OP_DIV, NULL );
d3069 1
a3069 1
		addinst( np->n_lineno, OP_NEG, NULL );
d3077 1
a3077 1
			addinst( np->n_lineno, OP_I_MM, NULL );
d3079 1
a3079 1
			addinst( np->n_lineno, OP_MM_I, NULL );
d3084 1
a3084 1
			addinst( np->n_lineno, OP_I_PP, NULL );
d3086 1
a3086 1
			addinst( np->n_lineno, OP_PP_I, NULL );
d3112 1
a3112 1
static	void	addinst( int ln, int op, VALUE_T *vp )
d3122 7
a3128 1
		ip->i_lineno = ln;
d3160 2
a3161 1
		rm_emsg_lineno = UNDEF;
@


1.43
log
@sprintf() is working.  New score is being reported; old score is stil in
parameter list of RM_score().  No error processing.
@
text
@a56 1
static	double	*sc_score;
d199 1
a199 1
int	RM_score( int, int, char [], double * );
d212 2
a213 2
static	int	do_sprintf( void );
static	int	do_fmt( char *, int, int * );
a450 10
/*
	v_svars.v_type = T_FLOAT;
	v_svars.v_value.v_dval = 0.0;
	idp = RM_enter_id( "SCORE", T_FLOAT, C_VAR, S_GLOBAL, 1, &v_svars );

	v_svars.v_type = T_UNDEF;
	v_svars.v_value.v_pval = NULL;
	idp = RM_enter_id( "SCORE", T_UNDEF, C_VAR, S_GLOBAL, 1, &v_svars );
*/
	sc_score = &idp->i_val.v_value.v_dval;
d464 1
a464 1
int	RM_score( int comp, int slen, char sbuf[], double *score )
a468 1
	*score = 0.0;
a494 3
/*
			*score = *sc_score;
*/
a623 3
/*
	*score = *sc_score;
*/
d1132 1
a1132 1
		do_sprintf();
d1293 1
a1293 1
static	int	do_sprintf( void )
d1311 2
a1312 1
		rval |= do_fmt( fmt, n_args, &c_arg );
d1319 1
a1319 1
static	int	do_fmt( char *fmt, int n_args, int *c_arg )
d1334 1
d1413 5
a1417 1
		/* ERROR */
d1424 5
a1428 1
		/* ERROR */
d1432 4
a1435 1
			/* ERROR */
d1442 6
a1447 1
		/* ERROR */
d1451 4
a1454 1
			/* ERROR */
a1463 2
	nprt = 0;

d1473 7
a1479 1
			/* ERROR */
d1503 7
a1509 1
			/* ERROR */
d1535 7
a1541 1
			/* ERROR */
d1566 7
a1572 1
			/* ERROR */
d1600 6
a1605 1
			/* ERROR */
d1609 2
a1610 1
		*sbp++ = '%';
d1617 5
a1621 5

/*
	ERROR: "pf.$: type  '%c', unsupported\n"
*/

d1625 2
d1628 1
d1721 1
a1721 1
			idp->i_name );
@


1.42
log
@about 1/2 way to having sprintf() in.  Need to activate error checking,
clean-up after formatting (avoid mem-leak) and save the results.  Redefine
SCORE as T_UNDEF and set the format to %8d %8.3f or %8s depending on its
value.
@
text
@d213 1
a213 1
static	char	*do_sprintf( void );
d452 1
d456 5
d507 1
d509 1
d639 1
d641 1
d959 1
a959 1
	int	stype, idx, pos, len;
d1150 11
a1160 1
		cp = do_sprintf();
d1163 1
a1163 1
		mem[ sp ].v_type = T_INT;
d1311 1
a1311 1
static	char	*do_sprintf( void )
d1317 1
a1320 3

fprintf( stderr, "do_sprintf.1: %d args, fstr = '%s'\n", n_args, fstr );

d1329 1
a1329 1
		do_fmt( fmt, n_args, &c_arg );
d1333 1
a1333 4

fprintf( stderr, "do_sprintf.2: sprintfbuf =   '%s'\n", sprintfbuf );

	return( NULL );
d1349 1
d1596 1
a1596 1
	return( 0 );
d1793 3
a1795 3
		idp->i_type = T_INT;
		idp->i_val.v_type = T_INT;
		idp->i_val.v_value.v_ival = v_top->v_value.v_ival;
@


1.41
log
@added string concatenation (+, +=).
@
text
@d8 3
d134 8
a141 7
#define	SC_EFN		0
#define	SC_LENGTH	1
#define	SC_MISMATCHES	2
#define	SC_MISPAIRS	3
#define	SC_PAIRED	4
#define	SC_STRID	5
#define	N_SC		6	
d144 1
d150 1
a150 1
	"STRID"
d175 4
d213 2
d858 4
d920 1
a920 3
	case SC_STRID :
		rm_emsg_lineno = np->n_lineno;
		RM_errormsg( 1, "fix_call: STRID can not be called by user." );
d956 13
d1060 1
d1070 1
d1086 1
d1102 1
d1139 2
a1140 3
	case SC_STRID :
		v_id = &mem[ sp  ];
		stype = mem[ sp - 1 ].v_value.v_ival;
d1144 1
a1144 5
		idx = mem[ sp ].v_value.v_ival = strid( stype, v_id );
		if( v_id->v_type == T_STRING )
			tm_free( v_id->v_value.v_pval );
		esp++;
		estk[ esp ] = idx;
d1289 292
@


1.40
log
@fixed memory leak that lost the memory holding the string in
stref using a tag (h5['h1'])
@
text
@d1989 2
d2011 15
d2489 1
d2843 1
d2845 1
@


1.39
log
@added call to RM_initst() which is required for recursive version of
RM_efn().
@
text
@d461 1
d471 1
a471 1
	for( pc = 0; ; ){
d491 2
a492 1
			return( 1 );
d495 1
a495 1
			return( 0 );
d618 2
d621 6
d924 1
a924 1
		free( cp );
d1037 1
a1037 1
		free( cp );
d1116 2
d1304 1
a1304 1
	cp = ( char * )malloc( ( len + 1 ) * sizeof( char ) );
d1374 2
a1375 2
			cp = ( char * )
				malloc( strlen(idp->i_val.v_value.v_pval) + 1 );
d1411 2
a1412 1
		cp = ( char * )malloc( strlen( ip->i_val.v_value.v_pval ) + 1 );
d1465 2
a1466 1
		cp = ( char * )malloc( strlen( v_top->v_value.v_pval ) + 1 );
d1475 1
a1475 1
		free( v_top->v_value.v_pval );
d1490 2
a1491 1
		cp = ( char * )malloc( strlen( v_top->v_value.v_pval ) + 1 );
d1497 1
a1497 1
		free( idp->i_val.v_value.v_pval );
d1499 1
a1499 1
		free( v_top->v_value.v_pval );
d1532 1
a1532 1
		free( cp );
d1567 1
a1567 1
		free( cp );
d1625 2
a1626 2
		free( s_top );
		free( s_tm1 );
d1711 1
a1711 1
		free( mem[ mp + 1 + i ].v_value.v_pval );
d1754 2
a1755 2
		free( s_top );
		free( s_tm1 );
d1798 2
a1799 2
		free( s_top );
		free( s_tm1 );
d1843 2
a1844 2
		free( s_top );
		free( s_tm1 );
d1887 2
a1888 2
		free( s_top );
		free( s_tm1 );
d1931 2
a1932 2
		free( s_top );
		free( s_tm1 );
d1975 2
a1976 2
		free( s_top );
		free( s_tm1 );
d2811 1
d2819 1
d2828 1
d2834 1
@


1.38
log
@removed no longer used versions of mk_call_strid() and strid(); renamed
mk_call_strid1() and strid1() to mk_call_strid() and strid()
@
text
@d1015 1
@


1.37
log
@fixed incorrect prototype of (unused) function.
@
text
@d198 1
a198 2
static	NODE_T	*mk_call_strid( NODE_T *, NODE_T *, int );
static	NODE_T	*mk_call_strid1( int, NODE_T * );
d203 1
a203 2
static	int	strid( int, int, char * );
static	int	strid1( int, VALUE_T * );
d744 1
a744 1
	np1 = mk_call_strid1( sel, n_id );
d790 1
a790 4
/*
	np1 = mk_call_strid( n_tag, n_index, np->n_left->n_sym );
*/
	np1 = mk_call_strid1( sel, n_id );
a801 3
/*
		v_expr.v_value.v_ival = 1;
*/
d811 1
a811 127
static	NODE_T	*mk_call_strid( NODE_T *n_tag, NODE_T *n_index, int strel )
{
	NODE_T	*np1, *np2, *np3;
	VALUE_T	v_expr;
	int	k_tag, k_index;
	char	*v_tag;
	int	v_index;
	int	d, d_tag, d_index;
	STREL_T	*stp;

	k_tag = 0;
	v_tag = NULL;
	d_tag = UNDEF;
	k_index = 0;
	v_index = UNDEF;
	d_index = UNDEF;

	if( n_tag != NULL ){
		if( n_tag->n_sym == SYM_STRING ){
			k_tag = 1;
			v_tag = n_tag->n_val.v_value.v_pval;
		}
	}else{
		k_tag = 1;
		v_tag = NULL;
	}

	if( n_index != NULL ){
		if( n_index->n_sym == SYM_INT ){
			k_index = 1;
			v_index = n_index->n_val.v_value.v_ival;
		}
	}else{
		k_index = 1;
		v_index = UNDEF;
	}

	if( k_tag && k_index ){
		if( v_tag != NULL ){
			stp = rm_descr;
			for( d = 0; d < rm_n_descr; d++, stp++ ){
				if( stp->s_type == strel ){
					if( stp->s_tag == NULL )
						continue;
					else if( !strcmp( stp->s_tag, v_tag ) ){
						d_tag = d;
						break;
					}
				}
			}
			if( d_tag == UNDEF ){
				rm_emsg_lineno = n_tag->n_lineno;
				sprintf( emsg,
				"mk_call_strid: no such tag: '%s'.", v_tag );
				RM_errormsg( 1, emsg );
			}
		}
		if( v_index != UNDEF ){
			rm_emsg_lineno = n_index->n_lineno;
			if( v_index < 1 || v_index > rm_n_descr ){
				sprintf( emsg,
			"mk_call_strid: index must be between 1 and %d.",
					rm_n_descr );
				RM_errormsg( 1, emsg );
			}else
				d_index = v_index;
			if( rm_descr[ d_index - 1 ].s_type != strel ){
				sprintf( emsg,
		"mk_call_strid: strel with index= %d has wrong type.",
					v_index );
				RM_errormsg( 1, emsg );
			}
		}
		if( d_tag == UNDEF && d_index == UNDEF ){
			rm_emsg_lineno = n_tag->n_lineno;
			RM_errormsg( 1,
		"mk_call_strid: tag and index both have invalid values." );
		}else if( d_tag != UNDEF && d_index == UNDEF ){
			v_expr.v_type = T_INT;
			v_expr.v_value.v_ival = d_tag;
			np1 = RM_node( SYM_INT, &v_expr, 0, 0 );
			return( np1 );
		}else if( d_tag == UNDEF && d_index != UNDEF ){
			v_expr.v_type = T_INT;
			v_expr.v_value.v_ival = d_index - 1;
			np1 = RM_node( SYM_INT, &v_expr, 0, 0 );
			return( np1 );
		}else if( d_tag == d_index - 1 ){
			v_expr.v_type = T_INT;
			v_expr.v_value.v_ival = d_index;
			np1 = RM_node( SYM_INT, &v_expr, 0, 0 );
			return( np1 );
		}else{
			rm_emsg_lineno = n_tag->n_lineno;
			RM_errormsg( 1,
		"mk_call_strid: tag and index values are inconsistant." );
		}
	}

	if( n_tag == NULL ){
		v_expr.v_type = T_STRING;
		v_expr.v_value.v_pval = "";
		n_tag = RM_node( SYM_STRING, &v_expr, 0, 0 );
	}
	np2 = RM_node( SYM_LIST, 0, n_tag, NULL );

	if( n_index == NULL ){
		v_expr.v_type = T_INT;
		v_expr.v_value.v_ival = UNDEF;
		n_index = RM_node( SYM_INT, &v_expr, 0, 0 );
	}
		np3 = n_index;
	np2 = RM_node( SYM_LIST, 0, n_index, np2 );

	v_expr.v_type = T_INT;
	v_expr.v_value.v_ival = strel;
	np3 = RM_node( SYM_INT, &v_expr, 0, 0 );
	np2 = RM_node( SYM_LIST, 0, np3, np2 );

	v_expr.v_type = T_STRING;
	v_expr.v_value.v_pval = "STRID";
	np3 = RM_node( SYM_IDENT, &v_expr, 0, 0 );
	np1 = RM_node( SYM_CALL, 0, np3, np2 );
	return( np1 );
}

static	NODE_T	*mk_call_strid1( int strel, NODE_T *n_id )
d1104 1
a1104 1
		idx = mem[ sp ].v_value.v_ival = strid1( stype, v_id );
d1190 1
a1190 68
static	int	strid( int stype, int idx, char *tag )
{
	int	s, t_idx;
	STREL_T	*stp;
	char	name1[ 20 ], name2[ 20 ];

	if( *tag == '\0' ){
		if( idx < 1 || idx > rm_n_descr ){
			rm_emsg_lineno = UNDEF;
			sprintf( emsg,
				"strid: index (%d) out of range: 1 .. %d.",
				idx, rm_n_descr );
			RM_errormsg( 1, emsg );
		}
		idx--;
		stp = &rm_descr[ idx ];
		if( stype != SYM_SE ){
			if( stp->s_type != stype ){
				mk_stref_name( stype, name1 );
				mk_stref_name( stp->s_type, name2 );
				rm_emsg_lineno = UNDEF;
				sprintf( emsg,
			"strid: descr type mismatch: is %s should be %s.",
					name1, name2 );
				RM_errormsg( 1, emsg );
			}
		}
	}else{
		stp = rm_descr;
		for( t_idx = UNDEF, s = 0; s < rm_n_descr; s++, stp++ ){ 
			if( stp->s_tag == NULL )
				continue;
			else if( !strcmp( stp->s_tag, tag ) ){
				if( stp->s_type == stype ){
					t_idx = s;
					break;
				}else if(stp->s_type==SYM_SS && stype==SYM_SE){ 
					t_idx = s;
					break;
				}else{
					mk_stref_name( stype, name1 );
					mk_stref_name( stp->s_type, name2 );
					rm_emsg_lineno = UNDEF;
					sprintf( emsg,
				"strid: ambiguous descr reference: %s vs %s.",
						name1, name2 );
					RM_errormsg( 1, emsg );
				}
			}
		}
		if( t_idx == UNDEF ){
			rm_emsg_lineno = UNDEF;
			sprintf( emsg, "strid: no such descr '%s'.", tag );
			RM_errormsg( 1, emsg );
		}else if( idx != UNDEF ){
			if( t_idx != idx ){
				rm_emsg_lineno = UNDEF;
				sprintf( emsg, 
				"strid: tag '%s' and index %d conflict.",
					tag, idx );
				RM_errormsg( 1, emsg );
			}
		}
	}
	return( idx );
}

static	int	strid1( int stype, VALUE_T *v_id )
d1201 1
a1201 1
				"strid1: index (%d) out of range: 1 .. %d.",
d1213 1
a1213 1
			"strid1: descr type mismatch: is %s should be %s.",
d1237 1
a1237 1
				"strid1: ambiguous descr reference: %s vs %s.",
d1246 1
a1246 1
			sprintf( emsg, "strid1: no such descr '%s'.", tag );
@


1.36
log
@converted from K&R to ANSI.
@
text
@d204 1
a204 1
static	int	strid( int, int, int * );
d1324 1
a1324 1
static	int	strid( int stype, int idx, int *tag )
@


1.35
log
@actived ldc $
@
text
@d170 70
a239 68
void	RM_if();
void	RM_else();
void	RM_endelse();
void	RM_endif();
void	RM_forinit();
void	RM_fortest();
void	RM_forincr();
void	RM_endfor();
void	RM_while();
void	RM_endwhile();
void	RM_break();
void	RM_continue();
void	RM_accept();
void	RM_reject();
void	RM_mark();
void	RM_clear();
void	RM_expr();
void	RM_linkscore();
void	RM_dumpscore();
int	RM_score();

static	void	fixexpr();
static	void	genexpr();
static	int	is_syscall();
static	void	fix_kw_stref();
static	void	fix_ix_stref();
static	NODE_T	*mk_call_strid();
static	NODE_T	*mk_call_strid1();
static	void	fix_call();
static	void	do_fcl();
static	void	do_scl();
static	int	paired();
static	int	strid();
static	int	strid1();
static	void	do_strf();
static	void	do_lda();
static	void	do_lod();
static	void	do_ldc();
static	void	do_sto();
static	void	do_and();
static	void	do_ior();
static	void	do_not();
static	void	do_mat();
static	void	do_ins();
static	void	do_gtr();
static	void	do_geq();
static	void	do_equ();
static	void	do_neq();
static	void	do_leq();
static	void	do_les();
static	void	do_add();
static	void	do_sub();
static	void	do_mul();
static	void	do_div();
static	void	do_mod();
static	void	do_neg();
static	void	do_i_pp();
static	void	do_pp_i();
static	void	do_i_mm();
static	void	do_mm_i();

static	int	setupefn();
static	int	setbp();
static	void	mk_stref_name();
static	void	addnode();
static	void	addinst();
static	void	dumpinst();
static	void	dumpstk();
d253 3
a255 3
static	char	*tm_malloc();
static	void	tm_free();
static	void	tm_report();
d257 1
a257 2
void	RM_action( np )
NODE_T	*np;
d269 1
a269 1
void	RM_endaction()
d275 1
a275 2
void	RM_if( np )
NODE_T	*np;
d288 1
a288 1
void	RM_else()
d297 1
a297 1
void	RM_endelse()
d304 1
a304 1
void	RM_endif()
d311 1
a311 2
void	RM_forinit( np )
NODE_T	*np;
d322 1
a322 2
void	RM_fortest( np )
NODE_T	*np;
d333 1
a333 2
void	RM_forincr( np )
NODE_T	*np;
d339 1
a339 1
void	RM_endfor()
d353 1
a353 2
void	RM_while( np )
NODE_T	*np;
d367 1
a367 1
void	RM_endwhile()
d377 1
a377 1
void	RM_break()
d385 1
a385 1
void	RM_continue()
d393 1
a393 1
void	RM_accept()
d399 1
a399 1
void	RM_reject()
d405 1
a405 1
void	RM_mark()
d411 1
a411 1
void	RM_clear()
d417 1
a417 3
void	RM_expr( lval, np )
int	lval;
NODE_T	*np;
d424 1
a424 1
void	RM_linkscore()
d449 1
a449 2
void	RM_dumpscore( fp )
FILE	*fp;
d460 1
a460 5
int	RM_score( comp, slen, sbuf, score )
int	comp;
int	slen;
char	sbuf[];
double	*score;
d621 1
a621 2
static	void	fixexpr( np )
NODE_T	*np;
d637 1
a637 3
static	void	genexpr( lval, np )
int	lval;
NODE_T	*np;
d670 1
a670 2
static	int	is_syscall( np )
NODE_T	*np;
d683 1
a683 2
static	void	fix_kw_stref( np )
NODE_T	*np;
d770 1
a770 2
static	void	fix_ix_stref( np )
NODE_T	*np;
d819 1
a819 4
static	NODE_T	*mk_call_strid( n_tag, n_index, strel )
NODE_T	*n_tag;
NODE_T	*n_index;
int	strel;
d945 1
a945 3
static	NODE_T	*mk_call_strid1( strel, n_id )
int	strel;
NODE_T	*n_id;
d964 1
a964 2
static	void	fix_call( np )
NODE_T	*np;
d1040 1
a1040 2
static	void	do_fcl( ip )
INST_T	*ip;
d1056 1
a1056 2
static	void	do_scl( ip )
INST_T	*ip;
d1250 1
a1250 4
static	int	paired( stp, pos, len )
STREL_T	*stp;
int	pos;
int	len;
d1324 1
a1324 4
static	int	strid( stype, idx, tag )
int	stype;
int	idx;
char	*tag;
d1391 1
a1391 3
static	int	strid1( stype, v_id )
int	stype;
VALUE_T	*v_id;
d1454 1
a1454 2
static	void	do_strf( ip )
INST_T	*ip;
d1506 1
a1506 2
static	void	do_lda( ip )
INST_T	*ip;
d1530 1
a1530 2
static	void	do_lod( ip )
INST_T	*ip;
d1580 1
a1580 2
static	void	do_ldc( ip )
INST_T	*ip;
d1624 1
a1624 2
static	void	do_sto( ip )
INST_T	*ip;
d1693 1
a1693 2
static	void	do_and( ip )
INST_T	*ip;
d1728 1
a1728 2
static	void	do_ior( ip )
INST_T	*ip;
d1763 1
a1763 2
static	void	do_not( ip )
INST_T	*ip;
d1789 1
a1789 2
static	void	do_mat( ip )
INST_T	*ip;
d1820 1
a1820 2
static	void	do_ins( ip )
INST_T	*ip;
d1905 1
a1905 2
static	void	do_gtr( ip )
INST_T	*ip;
d1949 1
a1949 2
static	void	do_geq( ip )
INST_T	*ip;
d1994 1
a1994 2
static	void	do_equ( ip )
INST_T	*ip;
d2038 1
a2038 2
static	void	do_neq( ip )
INST_T	*ip;
d2082 1
a2082 2
static	void	do_leq( ip )
INST_T	*ip;
d2126 1
a2126 2
static	void	do_les( ip )
INST_T	*ip;
d2170 1
a2170 2
static	void	do_add( ip )
INST_T	*ip;
d2201 1
a2201 2
static	void	do_sub( ip )
INST_T	*ip;
d2232 1
a2232 2
static	void	do_mul( ip )
INST_T	*ip;
d2263 1
a2263 2
static	void	do_div( ip )
INST_T	*ip;
d2294 1
a2294 2
static	void	do_mod( ip )
INST_T	*ip;
d2316 1
a2316 2
static	void	do_neg( ip )
INST_T	*ip;
d2338 1
a2338 2
static	void	do_i_pp( ip )
INST_T	*ip;
d2365 1
a2365 2
static	void	do_pp_i( ip )
INST_T	*ip;
d2392 1
a2392 2
static	void	do_i_mm( ip )
INST_T	*ip;
d2420 1
a2420 2
static	void	do_mm_i( ip )
INST_T	*ip;
d2447 1
a2447 6
static	int	setupefn( ip, idx, pos, idx2, pos2 )
INST_T	*ip;
int	idx;
int	pos;
int	idx2;
int	pos2;
d2533 2
a2534 7
static	int	setbp( stp, p, i, off, len, basepr )
STREL_T	*stp;
int	p;
int	i;
int	off;
int	len;
int	basepr[];
d2561 1
a2561 3
static	void	mk_stref_name( sym, name )
int	sym;
char	name[];
d2616 1
a2616 4
static	void	addnode( lval, np, l_andor )
int	lval;
NODE_T	*np;
int	l_andor;
d2821 1
a2821 4
static	void	addinst( ln, op, vp )
int	ln;
int	op;
VALUE_T	*vp;
d2858 1
a2858 3
static	void	dumpinst( fp, i, ip )
FILE	*fp;
INST_T	*ip;
d2953 1
a2953 3
static	void	dumpstk( fp, msg )
FILE	*fp;
char	msg[];
d3018 1
a3018 1
static	void	tm_report()
@


1.34
log
@removed memory leak in do_and() and do_ior() when used with
string argument.  Never tried I bet.
@
text
@d164 3
d482 1
a482 1
	sp = mp = -1;
d1263 3
a1265 1
		mem[ sp ].v_value.v_ival = strid1( stype, v_id );
d1537 1
d1621 1
d1645 4
a1648 2
		v_top->v_type = T_POS;
		v_top->v_value.v_pval = NULL;
@


1.33
log
@oops - dropped the tm_ from tm_malloc() instead of converting it back
to ordinary malloc().
@
text
@d1727 1
d1740 1
d1743 5
d1763 1
d1776 5
d1783 1
@


1.32
log
@found and fixed memory leaks associated with string assigns and
the  ... in {} op.  Some memory is still lost due to values be
save across iterations and and and, or and not ops on strings.
Will fix the latter next.
@
text
@a1628 1
/*
a1629 2
*/
		cp = ( char * )malloc( strlen( ip->i_val.v_value.v_pval ) + 1, "do_ldc" );
@


1.31
log
@more or less working version including efn().
@
text
@d238 14
a1499 3
/*
	if( pos < 1 ){
*/
d1629 1
d1631 2
d1693 1
d1716 1
d1918 4
d3050 43
@


1.30
log
@store return value of RM_efn() as double, not int as int was losing
the fractional part.  Appears to be working!!
@
text
@d31 2
d1089 2
d2566 4
a2569 2
	int	p1, off1;
	int	bp1, bp2;
d2571 3
a2574 3
	off1 = stp1->s_matchoff;

	bp1 = p + stp->s_matchoff - off;
d2576 2
a2577 1
	bp2 = p1 + stp1->s_matchoff - off;
d2579 2
a2580 2
	if( bp2 < 0 || bp2 >= len ){
fprintf( stderr, "out of bounds bp: %4d.%4d\n", bp1, bp2 ); 
d2582 4
a2585 2
	}else
		basepr[ i ] = bp2;
@


1.29
log
@efn() is now a builtin!  Needs works, but returns energies!
@
text
@d1070 1
a1070 1
	int	rval;
d1158 2
a1159 2
		mem[ sp ].v_type = T_INT;
		mem[ sp ].v_value.v_ival = rval;
@


1.28
log
@began adding glue to connect to efn()
@
text
@d23 1
d27 4
d49 2
d226 2
d448 3
a450 1
int	RM_score( sbuf, score )
d460 2
a476 1

a742 3
/*
	np1 = mk_call_strid( n_tag, n_index, np->n_left->n_sym );
*/
d748 1
a748 1
		v_expr.v_value.v_ival = -1;
d755 1
d757 2
d798 1
a798 1
		v_expr.v_value.v_ival = -1;
d805 1
d807 2
d1070 1
a1090 3
fprintf( stderr, "do_scl: rm_efninit = %d, rm_efndataok = %d\n",
	rm_efninit, rm_efndataok );

d1100 17
a1116 1
		pos  = mem[ sp - 4 ].v_value.v_ival;
d1118 1
d1121 1
a1121 1
			rm_emsg_lineno = UNDEF;
d1126 6
d1135 16
d1152 4
d1159 1
a1159 1
		mem[ sp ].v_value.v_ival = 160;
d1482 1
d1484 4
d2460 119
@


1.27
log
@efn parm list is OK.  Now do the init.
@
text
@d23 4
d225 2
d1054 1
d1058 20
@


1.26
log
@removed unused vars in the fix_*_stref parts.
@
text
@d118 7
a124 6
#define	SC_LENGTH	0
#define	SC_MISMATCHES	1
#define	SC_MISPAIRS	2
#define	SC_PAIRED	3
#define	SC_STRID	4	
#define	N_SC		5	
d127 1
d950 1
a950 1
	NODE_T	*np1;
d954 39
d1003 1
a1003 1
				"fix_call: function '%s' has only 1 parameter.",
d1046 2
a1047 1
	STREL_T	*stp;
d1050 28
a1095 1
		sp -= 2;
a1110 1
		sp -= 2;
a1146 1
		sp -= 2;
a1153 10
/*
		tag = mem[ sp ].v_value.v_pval;
		idx = mem[ sp - 1 ].v_value.v_ival;
		stype = mem[ sp - 2 ].v_value.v_ival;
		sp -= 2;
		sp = mp;
		mp = mem[ mp ].v_value.v_ival;
		mem[ sp ].v_type = T_INT;
		mem[ sp ].v_value.v_ival = strid( stype, idx, tag );
*/
a1161 1

d1341 1
a1341 1
			"strid: descr type mismatch: is %s should be %s.",
d1359 1
d1365 1
a1365 1
				"strid: ambiguous descr reference: %s vs %s.",
d1368 1
d1374 1
a1374 1
			sprintf( emsg, "strid: no such descr '%s'.", tag );
@


1.25
log
@made all strf's use scl STRID as this is required for
indexing via se[i].
pwd
@
text
@a664 1
	NODE_T	*np4;
d751 1
a751 1
	NODE_T	*n_id, *n_index, *n_tag, *n_pos, *n_len;
a752 1
	NODE_T	*np4;
d756 1
a756 1
	n_id = n_index = n_tag = n_pos = n_len = NULL;
a759 4
	if( np2->n_sym == SYM_INT )
		n_index = np2;
	else if( np2->n_sym == SYM_STRING )
		n_tag = np2;
a760 1

a770 9
	rm_emsg_lineno = np->n_lineno;
	if( n_index == NULL && n_tag == NULL ){
		rm_emsg_lineno = np->n_lineno;
		RM_errormsg( 1,
			"fix_ix_stref: index = or tag = require for stref()." );
	}
*/

/*
d1002 1
a1002 1
	char	*cp, *tag;
@


1.24
log
@changed all v_fvals to v_dvals.  Changed %8.3f to %8.3lf
@
text
@d179 1
d185 1
d456 1
d584 1
d588 1
d662 2
d665 1
a665 1
	NODE_T	*n_index, *n_tag, *n_pos, *n_len;
d669 2
a670 1
	n_index = n_tag = n_pos = n_len = NULL;
d715 3
a717 1
	if( n_index == NULL && n_tag == NULL ){
d720 3
a722 2
			"fix_kw_stref: index = or tag = require for stref()." );
	}
d724 1
d726 2
d751 2
d754 1
a754 1
	NODE_T	*n_index, *n_tag, *n_pos, *n_len;
d757 2
a758 1
	n_index = n_tag = n_pos = n_len = NULL;
d766 1
d777 1
d784 1
d786 1
d788 2
d939 21
d1019 1
d1103 1
d1112 7
d1271 63
@


1.23
log
@added (finally) the in-set (OP_INS) instruction which completes the
initial specification of rnamotif!  Also added code that implemeneted
the indexed stref's (h5[1,2,3], etc) which while not necessary make
the descriptors shorter.
!ls
@
text
@d41 1
a41 1
static	float	*sc_score;
d412 1
a412 1
	v_svars.v_value.v_fval = 0.0;
d414 1
a414 1
	sc_score = &idp->i_val.v_value.v_fval;
d431 1
a431 1
float	*score;
d1328 1
a1328 1
			v_top->v_value.v_fval = idp->i_val.v_value.v_fval;
d1364 1
a1364 1
		v_top->v_value.v_fval = ip->i_val.v_value.v_fval;
d1434 1
a1434 1
		idp->i_val.v_value.v_ival = v_top->v_value.v_fval;
d1437 1
a1437 1
		idp->i_val.v_value.v_fval = v_top->v_value.v_ival;
d1440 1
a1440 1
		idp->i_val.v_value.v_fval = v_top->v_value.v_fval;
d1473 1
a1473 1
		rv = v_top->v_value.v_ival = v_top->v_value.v_fval != 0.0;
d1502 1
a1502 1
		rv = v_top->v_value.v_ival = v_top->v_value.v_fval != 0.0;
d1531 1
a1531 1
		v_top->v_value.v_ival = !( v_top->v_value.v_fval != 0.0 );
d1679 1
a1679 1
			v_tm1->v_value.v_ival > v_top->v_value.v_fval;
d1683 1
a1683 1
			v_tm1->v_value.v_fval > v_top->v_value.v_ival;
d1687 1
a1687 1
			v_tm1->v_value.v_fval > v_top->v_value.v_fval;
d1724 1
a1724 1
			v_tm1->v_value.v_ival >= v_top->v_value.v_fval;
d1728 1
a1728 1
			v_tm1->v_value.v_fval >= v_top->v_value.v_ival;
d1732 1
a1732 1
			v_tm1->v_value.v_fval >= v_top->v_value.v_fval;
d1770 1
a1770 1
			v_tm1->v_value.v_ival == v_top->v_value.v_fval;
d1774 1
a1774 1
			v_tm1->v_value.v_fval == v_top->v_value.v_ival;
d1778 1
a1778 1
			v_tm1->v_value.v_fval == v_top->v_value.v_fval;
d1815 1
a1815 1
			v_tm1->v_value.v_ival != v_top->v_value.v_fval;
d1819 1
a1819 1
			v_tm1->v_value.v_fval != v_top->v_value.v_ival;
d1823 1
a1823 1
			v_tm1->v_value.v_fval != v_top->v_value.v_fval;
d1860 1
a1860 1
			v_tm1->v_value.v_ival <= v_top->v_value.v_fval;
d1864 1
a1864 1
			v_tm1->v_value.v_fval <= v_top->v_value.v_ival;
d1868 1
a1868 1
			v_tm1->v_value.v_fval <= v_top->v_value.v_fval;
d1905 1
a1905 1
			v_tm1->v_value.v_ival < v_top->v_value.v_fval;
d1909 1
a1909 1
			v_tm1->v_value.v_fval < v_top->v_value.v_ival;
d1913 1
a1913 1
			v_tm1->v_value.v_fval < v_top->v_value.v_fval;
d1946 1
a1946 1
		v_tm1->v_value.v_ival += v_top->v_value.v_fval;
d1949 1
a1949 1
		v_tm1->v_value.v_fval += v_top->v_value.v_ival;
d1952 1
a1952 1
		v_tm1->v_value.v_fval += v_top->v_value.v_fval;
d1978 1
a1978 1
		v_tm1->v_value.v_ival -= v_top->v_value.v_fval;
d1981 1
a1981 1
		v_tm1->v_value.v_fval -= v_top->v_value.v_ival;
d1984 1
a1984 1
		v_tm1->v_value.v_fval -= v_top->v_value.v_fval;
d2010 1
a2010 1
		v_tm1->v_value.v_ival *= v_top->v_value.v_fval;
d2013 1
a2013 1
		v_tm1->v_value.v_fval *= v_top->v_value.v_ival;
d2016 1
a2016 1
		v_tm1->v_value.v_fval *= v_top->v_value.v_fval;
d2042 1
a2042 1
		v_tm1->v_value.v_ival /= v_top->v_value.v_fval;
d2045 1
a2045 1
		v_tm1->v_value.v_fval /= v_top->v_value.v_ival;
d2048 1
a2048 1
		v_tm1->v_value.v_fval /= v_top->v_value.v_fval;
d2094 1
a2094 1
		v_top->v_value.v_fval = -v_top->v_value.v_fval;
d2504 1
a2504 1
				ip->i_val.v_value.v_fval = vp->v_value.v_fval;
d2604 1
a2604 1
		fprintf( fp, " %f", vp->v_value.v_fval );
d2636 1
a2636 1
			fprintf( fp, "F %8.3f", vp->v_value.v_fval );
@


1.22
log
@about 1/2 way to x in {}.  The data is being store, the ldc {}
works, but the ins inst is not implemented.
Also added a field i_lineno to the instruction so as to be able
to give the source line number of an offending instruction.
@
text
@d176 2
a177 1
static	void	fix_stref();
d595 4
a598 2
		if( np->n_sym == SYM_STREF ){
			fix_stref( np );
d634 1
a634 1
		if( np->n_sym == SYM_STREF ){
d654 1
a654 1
static	void	fix_stref( np )
d672 1
a672 1
		"fix_stref: index parameter may not appear more than once." );
d679 1
a679 1
		"fix_stref: tag parameter may not appear more than once." );
d686 1
a686 1
		"fix_stref: pos parameter may not appear more than once." );
d693 1
a693 1
		"fix_stref: len parameter may not appear more than once." );
d699 1
a699 1
					"fix_stref: unknown parameter: '%s'.",
d710 1
a710 1
			"fix_stref: index = or tag = require for stref()." );
d734 53
d1380 4
d1579 72
d1652 4
d2294 2
a2295 1
	case SYM_STREF :
@


1.21
log
@added code that implements match & don't match (=~, !~)
@
text
@d72 7
a78 9
#define	OP_PRST		29	/* Make a pairset	*/
#define	OP_BPR		30	/* Make a pair		*/
#define	OP_I_PP		31	/* use then incr (i++)	*/
#define	OP_PP_I		32	/* incr then use (++i)	*/
#define	OP_I_MM		33	/* use then decr (i--)	*/
#define	OP_MM_I		34	/* decr then use (--i)	*/
#define	OP_FJP		35	/* False Jump		*/
#define	OP_JMP		36	/* Jump			*/
#define	N_OP		37
a109 2
	"prst",
	"bpr",
d134 1
a204 2
static	void	do_prst();
static	void	do_bpr();
d226 1
a226 1
	addinst( OP_FJP, &v_lab );
d246 1
a246 1
	addinst( OP_FJP, &v_lab );
d254 1
a254 1
	addinst( OP_JMP, &v_lab );
d293 1
a293 1
	addinst( OP_FJP, &v_lab );
d312 1
a312 1
	addinst( OP_JMP, &v_lab );
d329 1
a329 1
	addinst( OP_FJP, &v_lab );
d337 1
a337 1
	addinst( OP_JMP, &v_lab );
d347 1
a347 1
	addinst( OP_JMP, &v_lab );
d355 1
a355 1
	addinst( OP_JMP, &v_lab );
d361 1
a361 1
	addinst( OP_ACPT, NULL );
d367 1
a367 1
	addinst( OP_RJCT, NULL );
d373 1
a373 1
	addinst( OP_MRK, NULL );
d379 1
a379 1
	addinst( OP_CLS, 0 );
d496 1
a496 1
			do_sto();
d506 1
a506 1
			do_not();
d510 1
a510 1
			do_mat();
d513 1
a513 1
			do_ins();
d516 1
a516 1
			do_gtr();
d519 1
a519 1
			do_geq();
d522 1
a522 1
			do_equ();
d525 1
a525 1
			do_neq();
d528 1
a528 1
			do_leq();
d531 1
a531 1
			do_les();
d535 1
a535 1
			do_add();
d538 1
a538 1
			do_sub();
d541 1
a541 1
			do_mul();
d544 1
a544 1
			do_div();
d547 1
a547 1
			do_mod();
d550 1
a550 1
			do_neg();
a552 7
		case OP_PRST :
			do_prst();
			break;
		case OP_BPR :
			do_bpr();
			break;

d554 1
a554 1
			do_i_pp();
d557 1
a557 1
			do_pp_i();
d560 1
a560 1
			do_i_mm();
d563 1
a563 1
			do_mm_i();
d575 1
d610 3
a612 3
			addinst( OP_MRK, NULL );
		}else if( np->n_sym == SYM_LCURLY ){
			addinst( OP_MRK, NULL );
d632 1
a632 3
			addinst( OP_STRF, NULL );
		}else if( np->n_sym == SYM_LCURLY ){
			addinst( OP_PRST, NULL );
d705 1
d1180 1
a1180 1
		rm_emsg_lineno = UNDEF;
d1186 1
a1186 1
		rm_emsg_lineno = UNDEF;
d1191 1
a1191 1
		rm_emsg_lineno = UNDEF;
d1198 1
a1198 1
		rm_emsg_lineno = UNDEF;
d1206 1
a1206 1
		rm_emsg_lineno = UNDEF;
d1232 1
a1232 1
		rm_emsg_lineno = UNDEF;
d1285 3
a1287 3
		case T_PAIR :
			break;
		case T_POS :
a1288 2
		case T_IDENT :
			break;
d1314 1
a1314 1
			rm_emsg_lineno = UNDEF;
d1325 1
a1325 1
		rm_emsg_lineno = UNDEF;
d1331 2
a1332 1
static	void	do_sto()
a1369 2
	case T_IJ( T_UNDEF, T_PAIR ):
		break;
a1375 2
	case T_IJ( T_INT, T_POS ) :
		break;
a1391 2
	case T_IJ( T_PAIR, T_PAIR ) :
		break;
d1393 1
a1393 1
		rm_emsg_lineno = UNDEF;
d1420 1
a1420 1
		rm_emsg_lineno = UNDEF;
d1449 1
a1449 1
		rm_emsg_lineno = UNDEF;
d1457 2
a1458 1
static	void	do_not()
d1478 1
a1478 1
		rm_emsg_lineno = UNDEF;
d1484 2
a1485 1
static	void	do_mat()
d1510 1
a1510 1
		rm_emsg_lineno = UNDEF;
d1516 2
a1517 1
static	void	do_ins()
d1522 2
a1523 1
static	void	do_gtr()
d1561 1
a1561 1
		rm_emsg_lineno = UNDEF;
d1567 2
a1568 1
static	void	do_geq()
d1606 1
a1606 1
		rm_emsg_lineno = UNDEF;
d1613 2
a1614 1
static	void	do_equ()
d1652 1
a1652 1
		rm_emsg_lineno = UNDEF;
d1658 2
a1659 1
static	void	do_neq()
d1697 1
a1697 1
		rm_emsg_lineno = UNDEF;
d1703 2
a1704 1
static	void	do_leq()
d1742 1
a1742 1
		rm_emsg_lineno = UNDEF;
d1748 2
a1749 1
static	void	do_les()
d1787 1
a1787 1
		rm_emsg_lineno = UNDEF;
d1793 2
a1794 1
static	void	do_add()
a1811 2
	case T_IJ( T_INT, T_POS ) :
		break;
a1817 6
	case T_IJ( T_STRING, T_STRING ) :
		break;
	case T_IJ( T_PAIR, T_PAIR ) :
		break;
	case T_IJ( T_POS, T_INT ) :
		break;
d1819 1
a1819 1
		rm_emsg_lineno = UNDEF;
d1825 2
a1826 1
static	void	do_sub()
a1843 2
	case T_IJ( T_INT, T_POS ) :
		break;
a1849 4
	case T_IJ( T_PAIR, T_PAIR ) :
		break;
	case T_IJ( T_POS, T_INT ) :
		break;
d1851 1
a1851 1
		rm_emsg_lineno = UNDEF;
d1857 2
a1858 1
static	void	do_mul()
d1883 1
a1883 1
		rm_emsg_lineno = UNDEF;
d1889 2
a1890 1
static	void	do_div()
d1915 1
a1915 1
		rm_emsg_lineno = UNDEF;
d1921 2
a1922 1
static	void	do_mod()
d1938 1
a1938 1
		rm_emsg_lineno = UNDEF;
d1944 2
a1945 1
static	void	do_neg()
d1961 1
a1961 1
		rm_emsg_lineno = UNDEF;
d1967 2
a1968 11
static	void	do_prst()
{

}

static	void	do_bpr()
{

}

static	void	do_i_pp()
d1972 1
a1972 1
	IDENT_T	*ip;
d1975 2
a1976 2
	ip = v_top->v_value.v_pval;
	t_top = ip->i_type;
d1980 1
a1980 1
		rm_emsg_lineno = UNDEF;
d1982 1
a1982 1
			ip->i_name );
d1986 1
a1986 1
		v_top->v_value.v_ival = ( ip->i_val.v_value.v_ival )++;
d1989 1
a1989 1
		rm_emsg_lineno = UNDEF;
d1995 2
a1996 1
static	void	do_pp_i()
d2000 1
a2000 1
	IDENT_T	*ip;
d2003 2
a2004 2
	t_top = v_top->v_type;
	ip = v_top->v_value.v_pval;
d2008 1
a2008 1
		rm_emsg_lineno = UNDEF;
d2010 1
a2010 1
			ip->i_name );
d2014 1
a2014 1
		v_top->v_value.v_ival = ++( ip->i_val.v_value.v_ival );
d2017 1
a2017 1
		rm_emsg_lineno = UNDEF;
d2023 2
a2024 1
static	void	do_i_mm()
d2028 1
a2028 1
	IDENT_T	*ip;
d2031 2
a2032 2
	t_top = v_top->v_type;
	ip = v_top->v_value.v_pval;
d2036 1
a2036 1
		rm_emsg_lineno = UNDEF;
d2038 1
a2038 1
			ip->i_name );
d2042 1
a2042 1
		v_top->v_value.v_ival = ( ip->i_val.v_value.v_ival )--;
d2045 1
a2045 1
		rm_emsg_lineno = UNDEF;
d2052 2
a2053 1
static	void	do_mm_i()
d2057 1
a2057 1
	IDENT_T	*ip;
d2060 2
a2061 2
	t_top = v_top->v_type;
	ip = v_top->v_value.v_pval;
d2065 1
a2065 1
		rm_emsg_lineno = UNDEF;
d2067 1
a2067 1
			ip->i_name );
d2071 1
a2071 1
		v_top->v_value.v_ival = --( ip->i_val.v_value.v_ival );
d2074 1
a2074 1
		rm_emsg_lineno = UNDEF;
d2152 1
a2152 1
			addinst( OP_SCL, &v_node );
d2154 1
a2154 1
			addinst( OP_FCL, &np->n_val );
d2193 1
a2193 1
			addinst( OP_LDA, &np->n_val );
d2195 1
a2195 1
			addinst( OP_LOD, &np->n_val );
d2199 1
a2199 1
		addinst( OP_LDC, &np->n_val );
d2202 1
a2202 1
		addinst( OP_LDC, &np->n_val );
d2205 1
a2205 1
		addinst( OP_LDC, &np->n_val );
d2210 4
a2213 1
		addinst( OP_LDC, &v_node );
d2217 1
a2217 1
		addinst( OP_STO, NULL );
d2221 2
a2222 2
		addinst( OP_ADD, NULL );
		addinst( OP_STO, NULL );
d2225 2
a2226 2
		addinst( OP_SUB, NULL );
		addinst( OP_STO, NULL );
d2229 2
a2230 2
		addinst( OP_MOD, NULL );
		addinst( OP_STO, NULL );
d2233 2
a2234 2
		addinst( OP_MUL, NULL );
		addinst( OP_STO, NULL );
d2237 2
a2238 2
		addinst( OP_DIV, NULL );
		addinst( OP_STO, NULL );
d2244 1
a2244 1
		addinst( OP_AND, &v_lab );
d2249 1
a2249 1
		addinst( OP_IOR, &v_lab );
d2252 1
a2252 1
		addinst( OP_NOT, NULL );
d2256 1
a2256 1
		addinst( OP_EQU, NULL );
d2259 1
a2259 1
		addinst( OP_NEQ, NULL );
d2262 1
a2262 1
		addinst( OP_GTR, NULL );
d2265 1
a2265 1
		addinst( OP_GEQ, NULL );
d2268 1
a2268 1
		addinst( OP_LES, NULL );
d2271 1
a2271 1
		addinst( OP_LEQ, NULL );
d2275 1
a2275 1
		addinst( OP_MAT, NULL );
d2278 2
a2279 2
		addinst( OP_MAT, NULL );
		addinst( OP_NOT, NULL );
d2282 1
a2282 1
		addinst( OP_INS, NULL );
d2286 1
a2286 1
		addinst( OP_ADD, NULL );
d2289 1
a2289 1
		addinst( OP_SUB, NULL );
d2292 1
a2292 1
		addinst( OP_MOD, NULL );
d2295 1
a2295 1
		addinst( OP_MUL, NULL );
d2298 1
a2298 1
		addinst( OP_DIV, NULL );
d2301 1
a2301 1
		addinst( OP_NEG, NULL );
a2304 1
		addinst( OP_BPR, NULL );
d2309 1
a2309 1
			addinst( OP_I_MM, NULL );
d2311 1
a2311 1
			addinst( OP_MM_I, NULL );
d2316 1
a2316 1
			addinst( OP_I_PP, NULL );
d2318 1
a2318 1
			addinst( OP_PP_I, NULL );
d2344 2
a2345 1
static	void	addinst( op, vp )
d2357 1
d2377 2
a2448 4
	case OP_PRST :
	case OP_BPR :
		break;

d2474 4
d2504 1
a2504 1
		case T_PAIR :
@


1.20
log
@removed unused vars as detected by fermat's C compiler.  Fixed (undetected)
bug that would have made pair( 4-plex ) not work as it used the 3d
base for 3 & 4.
@
text
@d1504 5
d1510 21
@


1.19
log
@fixed bug that considered descriptor indexes on the interval
[0,n_descr) even though they were on the interval [1,n_descr]
@
text
@a600 1
	int	sc;
a616 1
	char	name[ 20 ];
a617 1
	VALUE_T	v_expr;
a623 1
RM_dumpexpr( stderr, np, 0 );
d669 1
a669 1
	char	*ip, *sp;
d1095 1
a1095 1
			b4 = sc_sbuf[ p3 - pos - i ];
d1104 1
a2139 1
	POS_T	*posp;
a2380 1
	char	name[ 20 ];
@


1.18
log
@fixed bug that improperly computed the target for the JMP at the end of the
then clause.
@
text
@d627 1
d809 1
a809 1
			if( v_index < 0 || v_index >= rm_n_descr ){
@


1.17
log
@added new variable SCORE which holds will be passed back to find_motif()
and eventually printed by print_match.
@
text
@d258 1
a258 4
/*
	v_lab.v_value.v_ival = ifstk[ ifstkp - 1 ];
*/
	v_lab.v_value.v_ival = ifstk[ 0 ] + 1;
@


1.16
log
@fixed bug in mk_call_strid() that forgot to check if tag == NULL.  Also added code
in do_strf() to accept pos = 1, for matchlen = 0.
@
text
@d41 1
d258 1
d260 2
d403 2
a404 1
	VALUE_T	v_NSE;
d415 7
a421 3
	v_NSE.v_type = T_INT;
	v_NSE.v_value.v_ival = rm_n_descr;
	RM_enter_id( "NSE", T_INT, C_VAR, S_GLOBAL, 1, &v_NSE );
d436 1
a436 1
int	RM_score( sbuf )
d438 1
d442 1
d467 1
d598 1
@


1.15
log
@fixed type = T_FLOAT bug that converted reflexive lod's to T_FLOAT.
@
text
@d781 3
a783 1
					if( !strcmp( stp->s_tag, v_tag ) ){
d789 3
a791 2
			rm_emsg_lineno = n_tag->n_lineno;
			sprintf( emsg,
d793 2
a794 1
			RM_errormsg( 1, emsg );
d1192 2
@


1.14
log
@implemented STRID(), se() allowing loop over the descriptors:

	for( i = 1; i <= NSE; i++ ){
		mpr += mispair( se( index=i ) );
		...
	}
@
text
@d390 1
d2347 1
a2347 1
			else if( vp->v_type = T_FLOAT )
d2444 1
a2444 1
	if( ip->i_op == OP_LDA ){
@


1.13
log
@added builtins mismatches(), mispairs() and paired().  Fixed bug that
was using the loopstk instead of the ifstk after and else.
@
text
@d184 1
d398 1
d409 3
d918 2
a919 2
	char	*cp;
	int	idx, pos, len;
d1002 8
d1012 1
d1096 70
d2069 4
d2115 1
a2115 1
		strcpy( name, "" );
@


1.12
log
@forgot to update the addinst() for RM_else() to use v_lab containing the label
value instead of the literal label number.
@
text
@d48 32
a79 31
#define	OP_STRF		6	/* Str. El. Reference	*/
#define	OP_LDA		7	/* Load Address		*/
#define	OP_LOD		8	/* Load Value		*/
#define	OP_LDC		9	/* Load Constant	*/
#define	OP_STO		10	/* Store top of stack	*/
#define	OP_AND		11	/* McCarthy And		*/
#define	OP_IOR		12	/* McCarthy Or		*/
#define	OP_NOT		13	/* Not			*/
#define	OP_MAT		14	/* Match		*/
#define	OP_INS		15	/* In Pairset		*/
#define	OP_GTR		16	/* Greater Than		*/
#define	OP_GEQ		17	/* Greater or Equal	*/
#define	OP_EQU		18	/* Equal		*/
#define	OP_NEQ		19	/* Not Equal		*/
#define	OP_LEQ		20	/* Less or Equal	*/
#define	OP_LES		21	/* Less Than		*/
#define	OP_ADD		22	/* Addition		*/
#define	OP_SUB		23	/* Subtraction		*/
#define	OP_MUL		24	/* Multiplication	*/
#define	OP_DIV		25	/* Division		*/
#define	OP_MOD		26	/* Modulus		*/
#define	OP_NEG		27	/* Negate		*/
#define	OP_PRST		28	/* Make a pairset	*/
#define	OP_BPR		29	/* Make a pair		*/
#define	OP_I_PP		30	/* use then incr (i++)	*/
#define	OP_PP_I		31	/* incr then use (++i)	*/
#define	OP_I_MM		32	/* use then decr (i--)	*/
#define	OP_MM_I		33	/* decr then use (--i)	*/
#define	OP_FJP		34	/* False Jump		*/
#define	OP_JMP		35	/* Jump			*/
#define	N_OP		36
d88 1
d121 15
d175 3
d180 1
d182 2
d256 1
a256 1
	v_lab.v_value.v_ival = loopstk[ loopstkp - 1 ];
d389 2
a390 37
	char	name[ 20 ];
	int	l_andor;
	VALUE_T	v_expr;

	if( np ){
		if( np->n_sym == SYM_CALL ){
			addinst( OP_MRK, NULL );
		}else if( np->n_sym == SYM_STREF ){
			fix_stref( np );
			v_expr.v_type = T_INT;
			v_expr.v_value.v_ival = np->n_left->n_sym;
		}else if( np->n_sym == SYM_LCURLY ){
			addinst( OP_MRK, NULL );
		}

		RM_expr( ISLVAL( np->n_sym ), np->n_left );

		if( ISRFLX( np->n_sym ) )
			RM_expr( 0, np->n_left );

		if( np->n_sym == SYM_OR || np->n_sym == SYM_AND ){
			l_andor = nextlab;
			nextlab++;
			addnode( lval, np, l_andor );
			RM_expr( 0, np->n_right );
			labtab[ l_andor ] = l_prog;
		}else{
			RM_expr( 0, np->n_right );
			addnode( lval, np, 0 );
		}

		if( np->n_sym == SYM_STREF ){
			addinst( OP_STRF, NULL );
		}else if( np->n_sym == SYM_LCURLY ){
			addinst( OP_PRST, NULL );
		}
	}
d463 1
a463 2
			sp = mp;
			mp = mem[ mp ].v_value.v_ival;
d469 3
d566 1
a566 1
			sp = mp;
d577 1
a577 1
dumpstk( stdout, "after op" );
d582 69
d849 1
a849 1
	v_expr.v_value.v_pval = "strid";
d855 38
d910 172
d1387 1
a1387 1
		v_top->v_value.v_ival = !( v_top->v_value.v_ival == 0 );
d1390 1
a1390 1
		v_top->v_value.v_ival = !( v_top->v_value.v_fval == 0.0 );
d1394 1
a1394 1
			!( *( char * )v_top->v_value.v_pval == '\0' );
d2039 1
d2045 6
a2050 1
		addinst( OP_FCL, &np->n_val );
d2298 1
d2357 2
d2379 1
a2379 1
	fprintf( fp, "%s\n", msg );
d2381 1
a2381 1
		fprintf( fp, "mem[%4d]: ", i );
d2387 1
a2387 1
			fprintf( fp, "I %d", vp->v_value.v_ival );
d2390 1
a2390 1
			fprintf( fp, "F %f", vp->v_value.v_fval );
@


1.11
log
@converted all literal errormsgs to RM_errormsg(). changed refs to node()
to RM_node().
@
text
@d232 3
a234 1
	addinst( OP_JMP, ifstk[ ifstkp - 1 ] + 1 );
@


1.10
log
@fixed mrk/cls to work properly for nested calls.
@
text
@d20 1
d25 1
a25 1
NODE_T	*node();
d135 22
a156 21
void	SC_if();
void	SC_else();
void	SC_endelse();
void	SC_endif();
void	SC_forinit();
void	SC_fortest();
void	SC_forincr();
void	SC_endfor();
void	SC_while();
void	SC_endwhile();
void	SC_break();
void	SC_continue();
void	SC_accept();
void	SC_reject();
void	SC_mark();
void	SC_clear();
void	SC_expr();
void	SC_node();
void	SC_dump();
void	SC_link();
int	SC_run();
d191 1
d196 1
a196 1
void	SC_action( np )
d200 2
a201 2
	SC_mark();
	SC_expr( 0, np );
d209 1
a209 1
void	SC_endaction()
d215 1
a215 1
void	SC_if( np )
d219 2
a220 2
	SC_mark();
	SC_expr( 0, np );
d229 1
a229 1
void	SC_else()
d236 1
a236 1
void	SC_endelse()
d243 1
a243 1
void	SC_endif()
d250 1
a250 1
void	SC_forinit( np )
d257 3
a259 3
	SC_mark();
	SC_expr( 0, np );
	SC_clear();
d262 1
a262 1
void	SC_fortest( np )
d267 2
a268 2
	SC_mark();
	SC_expr( 0, np );
d274 1
a274 1
void	SC_forincr( np )
d281 1
a281 1
void	SC_endfor()
d285 3
a287 3
	SC_mark();
	SC_expr( 0, loopincrstk[ loopstkp - 1 ] );
	SC_clear();
d295 1
a295 1
void	SC_while( np )
d303 2
a304 2
	SC_mark();
	SC_expr( 0, np );
d310 1
a310 1
void	SC_endwhile()
d320 1
a320 1
void	SC_break()
d328 1
a328 1
void	SC_continue()
d336 1
a336 1
void	SC_accept()
d342 1
a342 1
void	SC_reject()
d348 1
a348 1
void	SC_mark()
d354 1
a354 1
void	SC_clear()
d360 1
a360 1
void	SC_expr( lval, np )
d379 1
a379 1
		SC_expr( ISLVAL( np->n_sym ), np->n_left );
d382 1
a382 1
			SC_expr( 0, np->n_left );
d387 2
a388 2
			SC_node( lval, np, l_andor );
			SC_expr( 0, np->n_right );
d391 2
a392 2
			SC_expr( 0, np->n_right );
			SC_node( lval, np, 0 );
d403 1
a403 199
void	SC_node( lval, np, l_andor )
int	lval;
NODE_T	*np;
int	l_andor;
{
	POS_T	*posp;
	VALUE_T	v_node;

	switch( np->n_sym ){

	case SYM_CALL :
		addinst( OP_FCL, &np->n_val );
		break;
	case SYM_LIST :
		break;
	case SYM_STREF :
		break;

	case SYM_PARMS :
		break;
	case SYM_DESCR :
		break;
	case SYM_SITES :
		break;

	case SYM_SS :
	case SYM_H5 :
	case SYM_H3 :
	case SYM_P5 :
	case SYM_P3 :
	case SYM_T1 :
	case SYM_T2 :
	case SYM_T3 :
	case SYM_Q1 :
	case SYM_Q2 :
	case SYM_Q3 :
	case SYM_Q4 :
		break;

	case SYM_ELSE :
		break;
	case SYM_FOR :
		break;
	case SYM_IF :
		break;
	case SYM_WHILE :
		break;

	case SYM_IDENT :
		if( lval ){
			addinst( OP_LDA, &np->n_val );
		}else{
			addinst( OP_LOD, &np->n_val );
		}
		break;
	case SYM_INT :
		addinst( OP_LDC, &np->n_val );
		break;
	case SYM_FLOAT :
		addinst( OP_LDC, &np->n_val );
		break;
	case SYM_STRING :
		addinst( OP_LDC, &np->n_val );
		break;
	case SYM_DOLLAR :
		v_node.v_type = T_POS;
		v_node.v_value.v_pval = NULL;
		addinst( OP_LDC, &v_node );
		break;

	case SYM_ASSIGN :
		addinst( OP_STO, NULL );
		break;

	case SYM_PLUS_ASSIGN :
		addinst( OP_ADD, NULL );
		addinst( OP_STO, NULL );
		break;
	case SYM_MINUS_ASSIGN :
		addinst( OP_SUB, NULL );
		addinst( OP_STO, NULL );
		break;
	case SYM_PERCENT_ASSIGN :
		addinst( OP_MOD, NULL );
		addinst( OP_STO, NULL );
		break;
	case SYM_STAR_ASSIGN :
		addinst( OP_MUL, NULL );
		addinst( OP_STO, NULL );
		break;
	case SYM_SLASH_ASSIGN :
		addinst( OP_DIV, NULL );
		addinst( OP_STO, NULL );
		break;

	case SYM_AND :
		v_lab.v_type = T_INT;
		v_lab.v_value.v_ival = l_andor;
		addinst( OP_AND, &v_lab );
		break;
	case SYM_OR :
		v_lab.v_type = T_INT;
		v_lab.v_value.v_ival = l_andor;
		addinst( OP_IOR, &v_lab );
		break;
	case SYM_NOT :
		addinst( OP_NOT, NULL );
		break;

	case SYM_EQUAL :
		addinst( OP_EQU, NULL );
		break;
	case SYM_NOT_EQUAL :
		addinst( OP_NEQ, NULL );
		break;
	case SYM_GREATER :
		addinst( OP_GTR, NULL );
		break;
	case SYM_GREATER_EQUAL :
		addinst( OP_GEQ, NULL );
		break;
	case SYM_LESS :
		addinst( OP_LES, NULL );
		break;
	case SYM_LESS_EQUAL :
		addinst( OP_LEQ, NULL );
		break;

	case SYM_MATCH :
		addinst( OP_MAT, NULL );
		break;
	case SYM_DONT_MATCH :
		addinst( OP_MAT, NULL );
		addinst( OP_NOT, NULL );
		break;
	case SYM_IN :
		addinst( OP_INS, NULL );
		break;

	case SYM_PLUS :
		addinst( OP_ADD, NULL );
		break;
	case SYM_MINUS :
		addinst( OP_SUB, NULL );
		break;
	case SYM_PERCENT :
		addinst( OP_MOD, NULL );
		break;
	case SYM_STAR :
		addinst( OP_MUL, NULL );
		break;
	case SYM_SLASH :
		addinst( OP_DIV, NULL );
		break;
	case SYM_NEGATE :
		addinst( OP_NEG, NULL );
		break;

	case SYM_COLON :
		addinst( OP_BPR, NULL );
		break;

	case SYM_MINUS_MINUS :
		if( np->n_left ){
			addinst( OP_I_MM, NULL );
		}else{
			addinst( OP_MM_I, NULL );
		}
		break;
	case SYM_PLUS_PLUS :
		if( np->n_left ){
			addinst( OP_I_PP, NULL );
		}else{
			addinst( OP_PP_I, NULL );
		}
		break;

	case SYM_LPAREN :
		break;
	case SYM_RPAREN :
		break;
	case SYM_LCURLY :
		break;
	case SYM_RCURLY :
		break;
	case SYM_COMMA :
		break;
	case SYM_SEMICOLON :
		break;
	case SYM_ERROR :
		fprintf( stderr, "SYM_ERROR\n" );
		break;
	default :
		fprintf( stderr, "SC_node: Unknown symbol %d\n", np->n_sym );
		break;
	}
}

void	SC_link()
d419 1
a419 1
void	SC_dump( fp )
d431 1
a431 1
int	SC_run( sbuf )
d443 3
a445 3
			fprintf( stderr, "run: pc (%d) out of range 0..%d\n",
			pc, l_prog - 1 );
			exit( 1 );
d450 1
a450 1
fprintf( stdout, "SC_run, pc = %4d, op = %s\n", pc, opnames[ ip->i_op ] );
d580 2
a581 2
			fprintf( stderr, "run: unknown op %d\n", ip->i_op );
			exit( 1 );
d606 3
a608 4
					fprintf( stderr,
		"fix_stref: index parameter may not appear more than once.\n"
						);
					exit( 1 );
d613 3
a615 4
					fprintf( stderr,
		"fix_stref: tag parameter may not appear more than once.\n"
						);
					exit( 1 );
d620 3
a622 4
					fprintf( stderr,
		"fix_stref: pos parameter may not appear more than once.\n"
						);
					exit( 1 );
d627 3
a629 4
					fprintf( stderr,
		"fix_stref: len parameter may not appear more than once.\n"
						);
					exit( 1 );
d633 3
a635 2
				fprintf( stderr,
					"fix_stref: unknown parameter: '%s'\n",
d637 1
a637 1
				exit( 1 );
d642 1
d644 2
a645 3
		fprintf( stderr,
			"fix_stref: index = or tag = require for stref().\n" );
		exit( 1 );
d654 1
a654 1
		np3 = node( SYM_INT, &v_expr, 0, 0 );
d657 1
a657 1
	np2 = node( SYM_LIST, 0, np3, NULL );
d661 1
a661 1
		np3 = node( SYM_INT, &v_expr, 0, 0 );
d664 2
a665 2
	np2 = node( SYM_LIST, 0, np3, np2 );
	np1 = node( SYM_LIST, 0, np1, np2 );
d720 4
a723 3
			fprintf( stderr,
				"mk_call_strid: no such tag: '%s'.\n", v_tag );
			exit( 1 );
d726 1
d728 2
a729 2
				fprintf( stderr,
			"mk_call_strid: index must be between 1 and %d\n",
d731 1
a731 1
				exit( 1 );
d735 2
a736 2
				fprintf( stderr,
		"mk_call_strid: strel with index= %d has wrong type.\n",
d738 1
a738 1
				exit( 1 );
d742 3
a744 3
			fprintf( stderr,
"mk_call_strid: tag and index both have invalid values.\n" );
			exit( 1 );
d748 1
a748 1
			np1 = node( SYM_INT, &v_expr, 0, 0 );
d753 1
a753 1
			np1 = node( SYM_INT, &v_expr, 0, 0 );
d758 1
a758 1
			np1 = node( SYM_INT, &v_expr, 0, 0 );
d761 3
a763 3
			fprintf( stderr,
		"mk_call_strid: tag and index values are inconsistant.\n" );
			exit( 1 );
d770 1
a770 1
		n_tag = node( SYM_STRING, &v_expr, 0, 0 );
d772 1
a772 1
	np2 = node( SYM_LIST, 0, n_tag, NULL );
d777 1
a777 1
		n_index = node( SYM_INT, &v_expr, 0, 0 );
d780 1
a780 1
	np2 = node( SYM_LIST, 0, n_index, np2 );
d784 2
a785 2
	np3 = node( SYM_INT, &v_expr, 0, 0 );
	np2 = node( SYM_LIST, 0, np3, np2 );
d789 2
a790 2
	np3 = node( SYM_IDENT, &v_expr, 0, 0 );
	np1 = node( SYM_CALL, 0, np3, np2 );
d824 3
a826 2
		fprintf( stderr, "do_strf: no such descriptor %d.\n", index );
		exit( 1 );
d830 2
a831 2
		fprintf( stderr, "do_strf: pos must be > 0.\n" );
		exit( 1 );
d833 2
a834 1
		fprintf( stderr, "do_strf: pos must be <= %d.\n",
d836 1
a836 1
		exit( 1 );
d840 2
a841 2
		fprintf( stderr, "do_strf: len must be > 0.\n" );
		exit( 1 );
d848 2
a849 1
		fprintf( stderr, "do_strf: can't allocate cp.\n" );
d874 2
a875 1
		fprintf( stderr, "do_lda: variable '%s' is readonly.\n", 
d877 1
a877 1
		exit( 1 );
a878 3
/*
		v_top->v_type = idp->i_type;
*/
d895 2
a896 1
		fprintf( stderr, "do_lod: variable '%s' is undefined.\n",
d898 1
a898 1
		exit( 1 );
d902 3
a904 2
			fprintf( stderr,
				"do_lod: variable '%s' is undefined.\n",
d906 1
a906 1
			exit( 1 );
d920 2
a921 3
				fprintf( stderr,
					"do_lod: can't allocate cp.\n" );
				exit( 1 );
d958 2
a959 2
			fprintf( stderr, "do_ldc: can't allocate cp.\n" );
			exit( 1 );
d969 2
a970 2
		fprintf( stderr, "do_ldc: type mismatch.\n" );
		exit( 1 );
d1005 2
a1006 3
			fprintf( stderr,
				"do_sto: can't allocate new string.\n" );
			exit( 1 );
d1032 2
a1033 3
			fprintf( stderr,
				"do_sto: can't allocate new string.\n" );
			exit( 1 );
d1042 2
a1043 2
		fprintf( stderr, "do_sto: type mismatch.\n" );
		exit( 1 );
d1069 2
a1070 2
		fprintf( stderr, "do_and: type mismatch.\n" );
		exit( 1 );
d1098 2
a1099 2
		fprintf( stderr, "do_ior: type mismatch.\n" );
		exit( 1 );
d1126 2
a1127 2
		fprintf( stderr, "do_not: type mismatch.\n" );
		exit( 1 );
d1180 2
a1181 2
		fprintf( stderr, "do_gtr: type mismatch.\n" );
		exit( 1 );
d1224 2
a1225 1
		fprintf( stderr, "do_geq: type mismatch.\n" );
d1269 2
a1270 2
		fprintf( stderr, "do_equ: type mismatch.\n" );
		exit( 1 );
d1313 2
a1314 2
		fprintf( stderr, "do_neq: type mismatch.\n" );
		exit( 1 );
d1357 2
a1358 2
		fprintf( stderr, "do_leq: type mismatch.\n" );
		exit( 1 );
d1401 2
a1402 2
		fprintf( stderr, "do_les: type mismatch.\n" );
		exit( 1 );
d1440 2
a1441 2
		fprintf( stderr, "do_add: type mismatch.\n" );
		exit( 1 );
d1477 2
a1478 2
		fprintf( stderr, "do_sub: type mismatch.\n" );
		exit( 1 );
d1508 2
a1509 2
		fprintf( stderr, "do_mul: type mismatch.\n" );
		exit( 1 );
d1539 2
a1540 2
		fprintf( stderr, "do_div: type mismatch.\n" );
		exit( 1 );
d1561 2
a1562 2
		fprintf( stderr, "do_mod: type mismatch.\n" );
		exit( 1 );
d1583 2
a1584 2
		fprintf( stderr, "do_neg: type mismatch.\n" );
		exit( 1 );
d1611 2
a1612 1
		fprintf( stderr, "do_i_pp: variable '%s' is undefined.\n",
d1614 1
a1614 1
		exit( 1 );
d1620 2
a1621 2
		fprintf( stderr, "do_i_pp: type mismatch.\n" );
		exit( 1 );
d1638 2
a1639 1
		fprintf( stderr, "do_pp_i: variable '%s' is undefined.\n",
d1641 1
a1641 1
		exit( 1 );
d1647 2
a1648 2
		fprintf( stderr, "do_pp_i: type mismatch.\n" );
		exit( 1 );
d1665 2
a1666 1
		fprintf( stderr, "do_i_mm: variable '%s' is undefined.\n",
d1668 1
a1668 1
		exit( 1 );
d1674 2
a1675 1
		fprintf( stderr, "do_i_mm: type mismatch.\n" );
d1693 2
a1694 1
		fprintf( stderr, "do_mm_i: variable '%s' is undefined.\n",
d1696 1
a1696 1
		exit( 1 );
d1702 2
a1703 2
		fprintf( stderr, "do_mm_i: type mismatch.\n" );
		exit( 1 );
d1761 200
d1969 1
a1969 1
		errormsg( 1, "addinst: program size exceeded." );
d1987 2
a1988 3
					fprintf( stderr,
					"addinst: can't allocate sp.\n" );
					exit( 1 );
d2005 3
a2007 2
		fprintf( fp, "dumpinst: bad op %d\n", ip->i_op );
		exit( 1 );
@


1.9
log
@added 1st versions of strf & fcl.
@
text
@d662 3
d669 1
d1000 4
a1003 2
		mem[ sp ].v_type = T_INT;
		mem[ sp ].v_value.v_ival = len;
@


1.8
log
@redid strf instruction to accept three args: the d_index, the position
and the length.  -1 for length indicates from the position to the end
of the string.
@
text
@d8 2
d39 2
d626 2
a627 1
int	SC_run()
d634 1
d644 1
d647 1
d775 1
d777 1
d989 2
d992 7
d1004 5
d1010 34
d1065 1
d1067 2
d1168 1
a1173 1
	t_tm1 = v_tm1->v_type;
d1175 1
d1191 10
d1219 9
d1336 1
d1343 1
d1363 5
a1367 2
		v_tm1->v_value.v_ival =
			strcmp(v_tm1->v_value.v_pval,v_top->v_value.v_pval) > 0;
d1380 1
d1387 1
d1407 5
a1411 2
		v_tm1->v_value.v_ival =
			strcmp(v_tm1->v_value.v_pval,v_top->v_value.v_pval)>=0;
d1424 1
d1431 1
d1451 5
a1455 2
		v_tm1->v_value.v_ival =
			strcmp(v_tm1->v_value.v_pval,v_top->v_value.v_pval)==0;
d1468 1
d1475 1
d1495 5
a1499 2
		v_tm1->v_value.v_ival =
			strcmp(v_tm1->v_value.v_pval,v_top->v_value.v_pval)!=0;
d1512 1
d1519 1
d1539 5
a1543 2
		v_tm1->v_value.v_ival =
			strcmp(v_tm1->v_value.v_pval,v_top->v_value.v_pval)<=0;
d1556 1
d1563 1
d1583 5
a1587 2
		v_tm1->v_value.v_ival =
			strcmp(v_tm1->v_value.v_pval,v_top->v_value.v_pval) < 0;
a1794 1
	t_top = v_top->v_type;
d1796 1
@


1.7
log
@removed def of T_IJ() as it is now in rnamot.h being used also in
compile.c
@
text
@d18 2
d22 1
d152 2
d365 1
a367 1
			addinst( OP_STRF, &v_expr );
d407 1
a407 1
		addinst( OP_FCL, NULL );
d771 205
d1950 1
a1950 7
	if( ip->i_op == OP_STRF ){
		mk_stref_name( vp->v_value.v_ival, name );
		if( *name != '\0' )
			fprintf( fp, " opn (%s)", name );
		else
			fprintf( fp, " exec" );
	}else if( ip->i_op == OP_LDA ){
@


1.6
log
@added missing parm ip to call to do_ldc().
@
text
@a16 2
#define	T_IJ(i,j)	((i)*N_TYPE+(j))

@


1.5
log
@interpreter can do simple arithmetic including comparisons & booleans.
No string or other ( -> ) types yet.  No fcl, strf, mat, ins, bpr or
prst.   No builtins.
@
text
@d671 1
a671 1
			do_ldc();
@


1.4
log
@decided to use a threaded interp.  Have created stubs for all
non-trivial ops.
@
text
@d17 2
d20 2
d66 4
a69 4
#define	OP_INCP		30	/* use then incr (i++)	*/
#define	OP_PINC		31	/* incr then use (++i)	*/
#define	OP_DECP		32	/* use then decr (i--)	*/
#define	OP_PDEC		33	/* decr then use (--i)	*/
d176 4
a179 4
static	void	do_incp();
static	void	do_pinc();
static	void	do_decp();
static	void	do_pdec();
d184 1
a364 1
			mk_stref_name( np->n_left->n_sym, name );
d459 1
a459 1
		v_node.v_value.v_pval = "$";
d557 1
a557 1
			addinst( OP_DECP, NULL );
d559 1
a559 1
			addinst( OP_PDEC, NULL );
d564 1
a564 1
			addinst( OP_INCP, NULL );
d566 1
a566 1
			addinst( OP_PINC, NULL );
d600 3
d623 3
d634 4
d665 1
a665 1
			do_lda();
d668 1
a668 1
			do_lod();
d738 2
a739 2
		case OP_INCP :
			do_incp();
d741 2
a742 2
		case OP_PINC :
			do_pinc();
d744 2
a745 2
		case OP_DECP :
			do_decp();
d747 2
a748 2
		case OP_PDEC :
			do_pdec();
d752 1
a752 1
			if( mem[ sp ].v_value.v_ival )
d764 1
d780 2
a781 1
static	void	do_lda()
d783 2
d786 16
d804 2
a805 1
static	void	do_lod()
d807 3
d811 43
d856 2
a857 1
static	void	do_ldc()
d859 2
d862 30
d896 3
d900 47
d952 2
d955 21
d981 5
d987 18
d1009 5
d1015 16
d1045 2
d1048 32
d1084 2
d1087 32
d1123 2
d1126 32
d1162 2
d1165 32
d1201 2
d1204 32
d1240 2
d1243 32
d1288 2
a1289 2
	switch( t_tm1 * N_TYPE + t_top ){
	case T_INT * N_TYPE + T_INT :
d1292 1
a1292 1
	case T_INT * N_TYPE + T_FLOAT :
d1295 3
a1297 1
	case T_FLOAT * N_TYPE + T_INT :
d1300 1
a1300 1
	case T_FLOAT * N_TYPE + T_FLOAT :
d1303 1
a1303 3
	case T_STRING * N_TYPE + T_STRING :
		break;
	case T_PAIR * N_TYPE + T_PAIR :
d1305 1
a1305 1
	case T_INT * N_TYPE + T_POS :
d1307 1
a1307 1
	case T_POS * N_TYPE + T_INT :
d1327 2
a1328 2
	switch( t_tm1 * N_TYPE + t_top ){
	case T_INT * N_TYPE + T_INT :
d1331 1
a1331 1
	case T_INT * N_TYPE + T_FLOAT :
d1334 3
a1336 1
	case T_FLOAT * N_TYPE + T_INT :
d1339 1
a1339 1
	case T_FLOAT * N_TYPE + T_FLOAT :
d1342 1
a1342 3
	case T_PAIR * N_TYPE + T_PAIR :
		break;
	case T_INT * N_TYPE + T_POS :
d1344 1
a1344 1
	case T_POS * N_TYPE + T_INT :
d1364 2
a1365 2
	switch( t_tm1 * N_TYPE + t_top ){
	case T_INT * N_TYPE + T_INT :
d1368 1
a1368 1
	case T_INT * N_TYPE + T_FLOAT :
d1371 1
a1371 1
	case T_FLOAT * N_TYPE + T_INT :
d1374 1
a1374 1
	case T_FLOAT * N_TYPE + T_FLOAT :
d1395 2
a1396 2
	switch( t_tm1 * N_TYPE + t_top ){
	case T_INT * N_TYPE + T_INT :
d1399 1
a1399 1
	case T_INT * N_TYPE + T_FLOAT :
d1402 1
a1402 1
	case T_FLOAT * N_TYPE + T_INT :
d1405 1
a1405 1
	case T_FLOAT * N_TYPE + T_FLOAT :
d1426 2
a1427 2
	switch( t_tm1 * N_TYPE + t_top ){
	case T_INT * N_TYPE + T_INT :
d1469 1
a1469 1
static	void	do_incp()
d1471 3
d1475 18
d1495 1
a1495 1
static	void	do_pinc()
d1497 3
d1501 18
d1521 1
a1521 1
static	void	do_decp()
d1523 3
d1527 18
d1547 1
a1547 1
static	void	do_pdec()
d1549 3
d1553 18
d1619 4
d1731 4
a1734 4
	case OP_INCP :
	case OP_PINC :
	case OP_DECP :
	case OP_PDEC :
d1742 10
a1751 7
	if( vp->v_type == T_INT ){
		if( ip->i_op != OP_STRF )
			fprintf( fp, " %d", vp->v_value.v_ival );
		else{
			mk_stref_name( vp->v_value.v_ival, name );
			fprintf( fp, " %s", name );
		}
d1756 2
d1761 40
@


1.3
log
@operations compiled into prog.  Loops resolved.
@
text
@a16 2
#define	CFP	stdout

d21 1
a21 1
static	int	nextlab = 1;
a124 2
void	SC_link();
void	SC_dump();
d143 34
a180 25
void	SC_link()
{
	int	i;
	INST_T	*ip;

	for( ip = prog, i = 0; i < l_prog; i++, ip++ ){
		if( ip->i_op == OP_FJP || ip->i_op == OP_JMP ){
			ip->i_val.v_value.v_ival =
				labtab[ ip->i_val.v_value.v_ival ];
		}
	}
}

void	SC_dump( fp )
FILE	*fp;
{
	INST_T	*ip;
	int	i;

	fprintf( fp, "SCORE: %4d inst.\n", l_prog );
	for( ip = prog, i = 0; i < l_prog; i++, ip++ ){
		dumpinst( fp, i, ip );
	}
}

a191 2

	fprintf( CFP, "  fjp L%d\n", actlab );
a197 2

	fprintf( CFP, "L%d:\n", actlab );
a211 2

	fprintf( CFP, "  fjp L%d\n", ifstk[ ifstkp - 1 ] );
a218 3

	fprintf( CFP, "  jmp L%d\n", ifstk[ ifstkp - 1 ] + 1 );
	fprintf( CFP, "L%d:\n", ifstk[ ifstkp - 1 ] );
a224 3

	fprintf( CFP, "L%d:\n", ifstk[ ifstkp - 1 ] + 1 );

a231 3

	fprintf( CFP, "L%d:\n", ifstk[ ifstkp - 1 ] );

a251 3

	fprintf( CFP, "L%d:\n", loopstk[ loopstkp - 1 ] );

a256 2

	fprintf( CFP, "  fjp L%d\n", loopstk[ loopstkp - 1 ] + 2 );
a269 3

	fprintf( CFP, "L%d:\n", loopstk[ loopstkp - 1 ] + 1 );

a276 4

	fprintf( CFP, "  jmp L%d\n", loopstk[ loopstkp - 1 ] );
	fprintf( CFP, "L%d:\n", loopstk[ loopstkp - 1 ] + 2 );

a287 3

	fprintf( CFP, "L%d:\n", loopstk[ loopstkp - 1 ] );

a292 1
	fprintf( CFP, "  fjp L%d\n", loopstk[ loopstkp - 1 ] + 2 );
a301 4

	fprintf( CFP, "  jmp L%d\n", loopstk[ loopstkp - 1 ] );
	fprintf( CFP, "L%d:\n", loopstk[ loopstkp - 1 ] + 2 );

a310 1
	fprintf( CFP, "  jmp L%d\n", loopstk[ loopstkp - 1 ] + 1 );
a318 1
	fprintf( CFP, "  jmp L%d\n", loopstk[ loopstkp - 1 ] );
a324 1
	fprintf( CFP, "  acpt\n" );
a330 1
	fprintf( CFP, "  rjct\n" );
a336 1
	fprintf( CFP, "  mrk\n" );
a342 1
	fprintf( CFP, "  clr\n" );
a355 1
			fprintf( CFP, "  mrk\n" );
a360 1
			fprintf( CFP, "  strf %s\n", name );
a362 1
			fprintf( CFP, "  mrk\n" );
a375 3

			fprintf( CFP, "L%d:\n", l_andor );

a382 1
			fprintf( CFP, "  strf cls\n" );
a384 1
			fprintf( CFP, "  prst\n" );
a400 1
		fprintf( CFP, "  fcl %s\n", np->n_val.v_value.v_pval );
a439 1
			fprintf( CFP, "  lda %s\n", np->n_val.v_value.v_pval );
a441 1
			fprintf( CFP, "  lod %s\n", np->n_val.v_value.v_pval );
a445 1
		fprintf( CFP, "  ldc %d\n", np->n_val.v_value.v_ival );
a448 1
		fprintf( CFP, "  ldcR\n" );
a451 1
		fprintf( CFP, "  ldc \"%s\"\n", np->n_val.v_value.v_pval );
d454 3
a456 2
		addinst( OP_LDC, NULL );
		fprintf( CFP, "  lod $\n" );
a460 1
		fprintf( CFP, "  sto\n" );
a465 2
		fprintf( CFP, "  add\n" );
		fprintf( CFP, "  sto\n" );
a469 2
		fprintf( CFP, "  sub\n" );
		fprintf( CFP, "  sto\n" );
a473 2
		fprintf( CFP, "  mod\n" );
		fprintf( CFP, "  sto\n" );
a477 2
		fprintf( CFP, "  mul\n" );
		fprintf( CFP, "  sto\n" );
a481 2
		fprintf( CFP, "  div\n" );
		fprintf( CFP, "  sto\n" );
a487 1
		fprintf( CFP, "  and L%d\n", l_andor );
a492 1
		fprintf( CFP, "  ior L%d\n", l_andor );
a495 1
		fprintf( CFP, "  not\n" );
a499 1
		fprintf( CFP, "  equ\n" );
a502 1
		fprintf( CFP, "  neq\n" );
a505 1
		fprintf( CFP, "  gtr\n" );
a508 1
		fprintf( CFP, "  geq\n" );
a511 1
		fprintf( CFP, "  les\n" );
a514 1
		fprintf( CFP, "  leq\n" );
a518 1
		fprintf( CFP, "  mat\n" );
a522 2
		fprintf( CFP, "  mat\n" );
		fprintf( CFP, "  not\n" );
a525 1
		fprintf( CFP, "  ins\n" );
a529 1
		fprintf( CFP, "  add\n" );
a532 1
		fprintf( CFP, "  sub\n" );
a535 1
		fprintf( CFP, "  mod\n" );
a538 1
		fprintf( CFP, "  mul\n" );
a541 1
		fprintf( CFP, "  div\n" );
a544 1
		fprintf( CFP, "  neg\n" );
a548 1
		fprintf( CFP, "  bpr\n" );
a553 1
			fprintf( CFP, "  decp\n" );
a555 1
			fprintf( CFP, "  pdec\n" );
a560 1
			fprintf( CFP, "  incp\n" );
a562 1
			fprintf( CFP, "  pinc\n" );
d579 1
a579 1
		fprintf( CFP, "SYM_ERROR\n" );
d584 7
d592 5
d600 454
d1140 1
a1140 1
void	dumpinst( fp, i, ip )
d1152 2
a1153 1
	fprintf( fp, "prog[%5d]:  %s", i, opnames[ ip->i_op ] );
d1228 3
a1230 1
	else if( vp->v_type == T_STRING || vp->v_type == T_IDENT )
@


1.2
log
@added break/continue code.  Allocate 3 labels for while/for.
@
text
@d2 2
d21 2
a23 1

d25 1
d34 95
d148 7
d156 20
d184 4
d194 2
d208 4
d218 3
d228 2
d231 1
d238 2
d241 1
d261 2
d264 1
d267 4
d284 2
d287 1
d291 5
d298 1
d309 2
d312 1
d315 3
d324 5
d331 1
d338 3
d347 3
d356 2
a357 1
	fprintf( CFP, "  ACCEPT\n" );
d363 2
a364 1
	fprintf( CFP, "  REJECT\n" );
d370 1
d377 1
d386 2
d390 2
a391 1
		if( np->n_sym == SYM_CALL )
d393 4
a396 1
		else if( np->n_sym == SYM_STREF ){
d399 2
a400 1
		}else if( np->n_sym == SYM_LCURLY )
d402 2
d405 1
d408 15
a422 2
		SC_expr( 0, np->n_right );
		SC_node( lval, np );
d424 1
d426 2
a427 1
		}else if( np->n_sym == SYM_LCURLY )
d429 1
d433 1
a433 1
void	SC_node( lval, np )
d436 1
d439 1
d444 1
a451 4
	case SYM_FLOAT :
		fprintf( CFP, "  ldcR\n" );
		break;

a478 3
	case SYM_IN :
		fprintf( CFP, "  ins\n" );
		break;
d481 1
d483 2
a484 1
		if( lval )
d486 2
a487 1
		else
d489 1
d492 1
d495 4
d500 1
d503 3
a505 2
	case SYM_AND :
		fprintf( CFP, "  and\n" );
d507 1
d509 1
d512 1
d514 2
d520 2
d525 17
a541 2
	case SYM_PLUS :
		fprintf( CFP, "  add\n" );
d543 6
a548 2
	case SYM_MINUS :
		fprintf( CFP, "  sub\n" );
d550 5
a554 2
	case SYM_DOLLAR :
		fprintf( CFP, "  lod $\n" );
d556 3
a558 1
	case SYM_DONT_MATCH :
d560 1
d562 1
d565 4
d570 1
d574 1
d578 1
d582 1
d585 1
d587 1
d590 5
a594 5
	case SYM_MINUS_MINUS :
		if( np->n_left )
			fprintf( CFP, "  dcp\n" );
		else
			fprintf( CFP, "  pdc\n" );
d596 3
a598 2
	case SYM_NEGATE :
		fprintf( CFP, "  neg\n" );
d600 4
a603 2
	case SYM_NOT :
		fprintf( CFP, "  not\n" );
d605 3
a607 5
	case SYM_NOT_EQUAL :
		fprintf( CFP, "  neq\n" );
		break;
	case SYM_OR :
		fprintf( CFP, "  ior\n" );
d610 1
a612 10
	case SYM_PERCENT_ASSIGN :
		fprintf( CFP, "  mod\n" );
		fprintf( CFP, "  sto\n" );
		break;
	case SYM_PLUS_PLUS :
		if( np->n_left )
			fprintf( CFP, "  icp\n" );
		else
			fprintf( CFP, "  pic\n" );
		break;
d614 1
a616 4
	case SYM_STAR_ASSIGN :
		fprintf( CFP, "  mul\n" );
		fprintf( CFP, "  sto\n" );
		break;
d618 1
d621 27
a647 3
	case SYM_SLASH_ASSIGN :
		fprintf( CFP, "  div\n" );
		fprintf( CFP, "  sto\n" );
d649 1
a657 3
	case SYM_COLON :
		fprintf( CFP, "  bpr\n" );
		break;
d719 129
@


1.1
log
@Initial revision
@
text
@d26 3
a28 6
static	int	forstk[ 100 ];
static	NODE_T	*forincrstk[ 100 ];
static	int	forstkp = 0;

static	int	whilestk[ 100 ];
static	int	whilestkp = 0;
d40 2
d104 3
a106 3
	forstk[ forstkp ] = nextlab;
	forstkp++;
	nextlab += 2;
d116 1
a116 1
	fprintf( CFP, "L%d:\n", forstk[ forstkp - 1 ] );
d119 1
a119 1
	fprintf( CFP, "  fjp L%d\n", forstk[ forstkp - 1 ] + 1 );
d126 1
a126 1
	forincrstk[ forstkp - 1 ] = np;
d132 1
d134 1
a134 1
	SC_expr( 0, forincrstk[ forstkp - 1 ] );
d136 3
a138 3
	fprintf( CFP, "  jmp L%d\n", forstk[ forstkp - 1 ] );
	fprintf( CFP, "L%d:\n", forstk[ forstkp - 1 ] + 1 );
	forstkp--;
d145 4
a148 4
	whilestk[ whilestkp ] = nextlab;
	whilestkp++;
	nextlab += 2;
	fprintf( CFP, "L%d:\n", whilestk[ whilestkp - 1 ] );
d151 1
a151 1
	fprintf( CFP, "  fjp L%d\n", whilestk[ whilestkp - 1 ] + 1 );
d157 15
a171 3
	fprintf( CFP, "  jmp L%d\n", whilestk[ whilestkp - 1 ] );
	fprintf( CFP, "L%d:\n", whilestk[ whilestkp - 1 ] + 1 );
	whilestkp--;
@
