head	1.23;
access;
symbols;
locks; strict;
comment	@ * @;


1.23
date	2000.03.28.19.13.50;	author macke;	state Exp;
branches;
next	1.22;

1.22
date	2000.03.27.19.03.05;	author macke;	state Exp;
branches;
next	1.21;

1.21
date	2000.03.17.22.03.32;	author macke;	state Exp;
branches;
next	1.20;

1.20
date	2000.03.08.03.56.05;	author macke;	state Exp;
branches;
next	1.19;

1.19
date	2000.02.10.00.13.27;	author macke;	state Exp;
branches;
next	1.18;

1.18
date	99.10.23.02.23.34;	author macke;	state Exp;
branches;
next	1.17;

1.17
date	99.10.22.18.19.39;	author macke;	state Exp;
branches;
next	1.16;

1.16
date	99.10.22.03.21.59;	author macke;	state Exp;
branches;
next	1.15;

1.15
date	99.10.19.22.28.39;	author macke;	state Exp;
branches;
next	1.14;

1.14
date	99.10.19.17.59.40;	author macke;	state Exp;
branches;
next	1.13;

1.13
date	99.10.18.19.53.26;	author macke;	state Exp;
branches;
next	1.12;

1.12
date	99.10.06.19.57.38;	author macke;	state Exp;
branches;
next	1.11;

1.11
date	99.10.03.19.17.36;	author macke;	state Exp;
branches;
next	1.10;

1.10
date	99.10.01.03.23.57;	author macke;	state Exp;
branches;
next	1.9;

1.9
date	99.09.30.18.55.09;	author macke;	state Exp;
branches;
next	1.8;

1.8
date	99.09.30.01.04.44;	author macke;	state Exp;
branches;
next	1.7;

1.7
date	99.09.28.04.53.53;	author macke;	state Exp;
branches;
next	1.6;

1.6
date	99.09.18.02.22.24;	author macke;	state Exp;
branches;
next	1.5;

1.5
date	99.09.17.21.45.06;	author macke;	state Exp;
branches;
next	1.4;

1.4
date	99.09.16.01.40.44;	author macke;	state Exp;
branches;
next	1.3;

1.3
date	99.09.15.03.34.44;	author macke;	state Exp;
branches;
next	1.2;

1.2
date	99.09.12.18.34.06;	author macke;	state Exp;
branches;
next	1.1;

1.1
date	99.09.11.19.12.07;	author macke;	state Exp;
branches;
next	;


desc
@scoring engine.
@


1.23
log
@added (finally) the in-set (OP_INS) instruction which completes the
initial specification of rnamotif!  Also added code that implemeneted
the indexed stref's (h5[1,2,3], etc) which while not necessary make
the descriptors shorter.
!ls
@
text
@#include <stdio.h>
#include <ctype.h>
#include <string.h>

#include "rnamot.h"
#include "y.tab.h"

#define	MIN(a,b)	((a)<(b)?(a):(b))

#define	ISLVAL(s)	\
	((s)==SYM_ASSIGN||(s)==SYM_PLUS_ASSIGN||(s)==SYM_MINUS_ASSIGN||\
	 (s)==SYM_PERCENT_ASSIGN||(s)==SYM_SLASH_ASSIGN||(s)==SYM_STAR_ASSIGN||\
	 (s)==SYM_PLUS_PLUS||(s)==SYM_MINUS_MINUS)

#define	ISRFLX(s)	\
	((s)==SYM_PLUS_ASSIGN||(s)==SYM_MINUS_ASSIGN||\
	 (s)==SYM_PERCENT_ASSIGN||(s)==SYM_SLASH_ASSIGN||(s)==SYM_STAR_ASSIGN)

extern	int	rm_lineno;
extern	int	rm_emsg_lineno;	
extern	STREL_T	rm_descr[];
extern	int	rm_n_descr;
IDENT_T	*RM_find_id();
IDENT_T	*RM_enter_id();
NODE_T	*RM_node();

#define	LABTAB_SIZE	1000
static	int	labtab[ LABTAB_SIZE ];
static	int	nextlab;
static	int	actlab;
static	VALUE_T	v_lab;

static	int	ifstk[ 100 ];
static	int	ifstkp = 0;

static	int	loopstk[ 100 ];
static	NODE_T	*loopincrstk[ 100 ];
static	int	loopstkp = 0;

static	char	*sc_sbuf;
static	float	*sc_score;

#define	OP_NOOP		0	/* No Op	 	*/
#define	OP_ACPT		1	/* Accept the candidate	*/
#define	OP_RJCT		2	/* Reject the candidate */
#define	OP_MRK		3	/* Mark the stack	*/
#define	OP_CLS		4	/* Clear the stack	*/
#define	OP_FCL		5	/* Function Call	*/
#define	OP_SCL		6	/* Builtin  Call	*/
#define	OP_STRF		7	/* Str. El. Reference	*/
#define	OP_LDA		8	/* Load Address		*/
#define	OP_LOD		9	/* Load Value		*/
#define	OP_LDC		10	/* Load Constant	*/
#define	OP_STO		11	/* Store top of stack	*/
#define	OP_AND		12	/* McCarthy And		*/
#define	OP_IOR		13	/* McCarthy Or		*/
#define	OP_NOT		14	/* Not			*/
#define	OP_MAT		15	/* Match		*/
#define	OP_INS		16	/* In Pairset		*/
#define	OP_GTR		17	/* Greater Than		*/
#define	OP_GEQ		18	/* Greater or Equal	*/
#define	OP_EQU		19	/* Equal		*/
#define	OP_NEQ		20	/* Not Equal		*/
#define	OP_LEQ		21	/* Less or Equal	*/
#define	OP_LES		22	/* Less Than		*/
#define	OP_ADD		23	/* Addition		*/
#define	OP_SUB		24	/* Subtraction		*/
#define	OP_MUL		25	/* Multiplication	*/
#define	OP_DIV		26	/* Division		*/
#define	OP_MOD		27	/* Modulus		*/
#define	OP_NEG		28	/* Negate		*/
#define	OP_I_PP		29	/* use then incr (i++)	*/
#define	OP_PP_I		30	/* incr then use (++i)	*/
#define	OP_I_MM		31	/* use then decr (i--)	*/
#define	OP_MM_I		32	/* decr then use (--i)	*/
#define	OP_FJP		33	/* False Jump		*/
#define	OP_JMP		34	/* Jump			*/
#define	N_OP		35

static	char	*opnames[ N_OP ] = {
	"noop",
	"acpt",
	"rjct",
	"mrk",
	"cls",
	"fcl",
	"scl",
	"strf",
	"lda",
	"lod",
	"ldc",
	"sto",
	"and",
	"ior",
	"not",
	"mat",
	"ins",
	"gtr",
	"geq",
	"equ",
	"neq",
	"leq",
	"les",
	"add",
	"sub",
	"mul",
	"div",
	"mod",
	"neg",
	"incp",
	"pinc",
	"decp",
	"pdec",
	"fjp",
	"jmp" 
};

#define	SC_LENGTH	0
#define	SC_MISMATCHES	1
#define	SC_MISPAIRS	2
#define	SC_PAIRED	3
#define	SC_STRID	4	
#define	N_SC		5	

static	char	*scnames[ N_SC ] = {
	"length",
	"mismatches",
	"mispairs",
	"paired",
	"STRID"
};

typedef	struct	inst_t	{
	int	i_lineno;
	int	i_op;
	VALUE_T	i_val;
} INST_T;

#define	PROG_SIZE	10000
static	INST_T	prog[ PROG_SIZE ];
static	int	l_prog;

#define	MEM_SIZE	10000
static	VALUE_T	mem[ MEM_SIZE ];

static	int	pc;		/* program counter	*/
static	int	mp;		/* mark pointer		*/ 
static	int	sp;		/* stack pointer	*/

static	char	emsg[ 256 ];

void	RM_if();
void	RM_else();
void	RM_endelse();
void	RM_endif();
void	RM_forinit();
void	RM_fortest();
void	RM_forincr();
void	RM_endfor();
void	RM_while();
void	RM_endwhile();
void	RM_break();
void	RM_continue();
void	RM_accept();
void	RM_reject();
void	RM_mark();
void	RM_clear();
void	RM_expr();
void	RM_linkscore();
void	RM_dumpscore();
int	RM_score();

static	void	fixexpr();
static	void	genexpr();
static	int	is_syscall();
static	void	fix_kw_stref();
static	void	fix_ix_stref();
static	NODE_T	*mk_call_strid();
static	void	fix_call();
static	void	do_fcl();
static	void	do_scl();
static	int	paired();
static	int	strid();
static	void	do_strf();
static	void	do_lda();
static	void	do_lod();
static	void	do_ldc();
static	void	do_sto();
static	void	do_and();
static	void	do_ior();
static	void	do_not();
static	void	do_mat();
static	void	do_ins();
static	void	do_gtr();
static	void	do_geq();
static	void	do_equ();
static	void	do_neq();
static	void	do_leq();
static	void	do_les();
static	void	do_add();
static	void	do_sub();
static	void	do_mul();
static	void	do_div();
static	void	do_mod();
static	void	do_neg();
static	void	do_i_pp();
static	void	do_pp_i();
static	void	do_i_mm();
static	void	do_mm_i();

static	void	mk_stref_name();
static	void	addnode();
static	void	addinst();
static	void	dumpinst();
static	void	dumpstk();

void	RM_action( np )
NODE_T	*np;
{

	RM_mark();
	RM_expr( 0, np );
	actlab = nextlab;
	nextlab++;
	v_lab.v_type = T_INT;
	v_lab.v_value.v_ival = actlab;
	addinst( np->n_lineno, OP_FJP, &v_lab );
}

void	RM_endaction()
{

	labtab[ actlab ] = l_prog;
}

void	RM_if( np )
NODE_T	*np;
{

	RM_mark();
	RM_expr( 0, np );
	ifstk[ ifstkp ] = nextlab;
	ifstkp++;
	nextlab += 2;
	v_lab.v_type = T_INT;
	v_lab.v_value.v_ival = ifstk[ ifstkp - 1 ];
	addinst( np->n_lineno, OP_FJP, &v_lab );
}

void	RM_else()
{

	v_lab.v_type = T_INT;
	v_lab.v_value.v_ival = ifstk[ ifstkp - 1 ] + 1;
	addinst( UNDEF, OP_JMP, &v_lab );
	labtab[ ifstk[ ifstkp - 1 ] ] = l_prog;
}

void	RM_endelse()
{

	labtab[ ifstk[ ifstkp - 1 ] + 1 ] = l_prog;
	ifstkp--;
}

void	RM_endif()
{

	labtab[ ifstk[ ifstkp - 1 ] ] = l_prog;
	ifstkp--;
}

void	RM_forinit( np )
NODE_T	*np;
{

	loopstk[ loopstkp ] = nextlab;
	loopstkp++;
	nextlab += 3;
	RM_mark();
	RM_expr( 0, np );
	RM_clear();
}

void	RM_fortest( np )
NODE_T	*np;
{

	labtab[ loopstk[ loopstkp - 1 ] ] = l_prog;
	RM_mark();
	RM_expr( 0, np );
	v_lab.v_type = T_INT;
	v_lab.v_value.v_ival = loopstk[ loopstkp - 1 ] + 2;
	addinst( np->n_lineno, OP_FJP, &v_lab );
}

void	RM_forincr( np )
NODE_T	*np;
{

	loopincrstk[ loopstkp - 1 ] = np;
}

void	RM_endfor()
{

	labtab[ loopstk[ loopstkp - 1 ] + 1 ] = l_prog;
	RM_mark();
	RM_expr( 0, loopincrstk[ loopstkp - 1 ] );
	RM_clear();
	v_lab.v_type = T_INT;
	v_lab.v_value.v_ival = loopstk[ loopstkp - 1 ];
	addinst( UNDEF, OP_JMP, &v_lab );
	labtab[ loopstk[ loopstkp - 1 ] + 2 ] = l_prog;
	loopstkp--;
}

void	RM_while( np )
NODE_T	*np;
{

	loopstk[ loopstkp ] = nextlab;
	loopstkp++;
	nextlab += 3;
	labtab[ loopstk[ loopstkp -1 ] ] = l_prog;
	RM_mark();
	RM_expr( 0, np );
	v_lab.v_type = T_INT;
	v_lab.v_value.v_ival = loopstk[ loopstkp - 1 ] + 2;
	addinst( np->n_lineno, OP_FJP, &v_lab );
}

void	RM_endwhile()
{

	v_lab.v_type = T_INT;
	v_lab.v_value.v_ival = loopstk[ loopstkp - 1 ];
	addinst( UNDEF, OP_JMP, &v_lab );
	labtab[ loopstk[ loopstkp - 1 ] + 2 ] = l_prog;
	loopstkp--;
}

void	RM_break()
{

	v_lab.v_type = T_INT;
	v_lab.v_value.v_ival = loopstk[ loopstkp - 1 ] + 1;
	addinst( UNDEF, OP_JMP, &v_lab );
}

void	RM_continue()
{

	v_lab.v_type = T_INT;
	v_lab.v_value.v_ival = loopstk[ loopstkp - 1 ];
	addinst( UNDEF, OP_JMP, &v_lab );
}

void	RM_accept()
{

	addinst( UNDEF, OP_ACPT, NULL );
}

void	RM_reject()
{

	addinst( UNDEF, OP_RJCT, NULL );
}

void	RM_mark()
{

	addinst( UNDEF, OP_MRK, NULL );
}

void	RM_clear()
{

	addinst( UNDEF, OP_CLS, 0 );
}

void	RM_expr( lval, np )
int	lval;
NODE_T	*np;
{

	fixexpr( np );
	genexpr( lval, np );
}

void	RM_linkscore()
{
	int	i;
	INST_T	*ip;
	IDENT_T	*idp;
	VALUE_T	v_svars;

	for( ip = prog, i = 0; i < l_prog; i++, ip++ ){
		if( ip->i_op == OP_FJP || ip->i_op == OP_JMP ){
			ip->i_val.v_value.v_ival =
				labtab[ ip->i_val.v_value.v_ival ];
		}else if( ip->i_op == OP_IOR || ip->i_op == OP_AND ){
			ip->i_val.v_value.v_ival =
				labtab[ ip->i_val.v_value.v_ival ];
		}
	}
	v_svars.v_type = T_INT;
	v_svars.v_value.v_ival = rm_n_descr;
	RM_enter_id( "NSE", T_INT, C_VAR, S_GLOBAL, 1, &v_svars );
	v_svars.v_type = T_FLOAT;
	v_svars.v_value.v_fval = 0.0;
	idp = RM_enter_id( "SCORE", T_FLOAT, C_VAR, S_GLOBAL, 1, &v_svars );
	sc_score = &idp->i_val.v_value.v_fval;
}

void	RM_dumpscore( fp )
FILE	*fp;
{
	INST_T	*ip;
	int	i;

	fprintf( fp, "SCORE: %4d inst.\n", l_prog );
	for( ip = prog, i = 0; i < l_prog; i++, ip++ ){
		dumpinst( fp, i, ip );
	}
}

int	RM_score( sbuf, score )
char	sbuf[];
float	*score;
{
	INST_T	*ip;
	
	*score = 0.0;
	if( l_prog <= 0 )
		return( 1 );

	sc_sbuf = sbuf;
	sp = mp = -1;
	for( pc = 0; ; ){
		if( pc < 0 || pc >= l_prog ){
			sprintf( emsg, "RM_score: pc: %d: out of range 0..%d.",
				pc, l_prog - 1 );
			RM_errormsg( 1, emsg );
		}
		ip = &prog[ pc ];

/*
fprintf( stdout, "RM_run, pc = %4d, op = %s\n", pc, opnames[ ip->i_op ] );
dumpstk( stdout, "before op" );
*/

		pc++;
		switch( ip->i_op ){
		case OP_NOOP :
			break;

		case OP_ACPT :
			*score = *sc_score;
			return( 1 );
			break;
		case OP_RJCT :
			return( 0 );
			break;

		case OP_MRK :
			sp++;
			mem[ sp ].v_type = T_INT;
			mem[ sp ].v_value.v_ival = mp;
			mp = sp;
			break;
		case OP_CLS :
			sp = mp = -1;
			break;

		case OP_FCL :
			do_fcl( ip );
			break;
		case OP_SCL :
			do_scl( ip );
			break;
		case OP_STRF :
			do_strf( ip );
			break;

		case OP_LDA :
			do_lda( ip );
			break;
		case OP_LOD :
			do_lod( ip );
			break;
		case OP_LDC :
			do_ldc( ip );
			break;
		case OP_STO :
			do_sto( ip );
			break;

		case OP_AND :
			do_and( ip );
			break;
		case OP_IOR :
			do_ior( ip );
			break;
		case OP_NOT :
			do_not( ip );
			break;

		case OP_MAT :
			do_mat( ip );
			break;
		case OP_INS :
			do_ins( ip );
			break;
		case OP_GTR :
			do_gtr( ip );
			break;
		case OP_GEQ :
			do_geq( ip );
			break;
		case OP_EQU :
			do_equ( ip );
			break;
		case OP_NEQ :
			do_neq( ip );
			break;
		case OP_LEQ :
			do_leq( ip );
			break;
		case OP_LES :
			do_les( ip );
			break;

		case OP_ADD :
			do_add( ip );
			break;
		case OP_SUB :
			do_sub( ip );
			break;
		case OP_MUL :
			do_mul( ip );
			break;
		case OP_DIV :
			do_div( ip );
			break;
		case OP_MOD :
			do_mod( ip );
			break;
		case OP_NEG :
			do_neg( ip );
			break;

		case OP_I_PP :
			do_i_pp( ip );
			break;
		case OP_PP_I :
			do_pp_i( ip );
			break;
		case OP_I_MM :
			do_i_mm( ip );
			break;
		case OP_MM_I :
			do_mm_i( ip );
			break;

		case OP_FJP :
			if( !mem[ sp ].v_value.v_ival )
				pc = ip->i_val.v_value.v_ival; 
			sp = mp = -1;
			break;
		case OP_JMP :
			pc = ip->i_val.v_value.v_ival;
			break;
		default :
			rm_emsg_lineno = ip->i_lineno;
			sprintf( emsg, "RM_score: unknown op %d.", ip->i_op );
			RM_errormsg( 1, emsg );
			break;
		}
/*
dumpstk( stdout, "after op " );
*/
	}
	*score = *sc_score;
}

static	void	fixexpr( np )
NODE_T	*np;
{

	if( np ){
		fixexpr( np->n_left );
		fixexpr( np->n_right );
		if( np->n_sym == SYM_KW_STREF ){
			fix_kw_stref( np );
		}else if( np->n_sym == SYM_IX_STREF ){
			fix_ix_stref( np );
		}else if( np->n_sym == SYM_CALL ){
			fix_call( np );
		}
	}
}

static	void	genexpr( lval, np )
int	lval;
NODE_T	*np;
{
	int	l_andor;

	if( np ){
		if( np->n_sym == SYM_CALL ){
			addinst( np->n_lineno, OP_MRK, NULL );
		}else if( np->n_sym == SYM_IN ){
			addinst( np->n_lineno, OP_MRK, NULL );
		}

		genexpr( ISLVAL( np->n_sym ), np->n_left );

		if( ISRFLX( np->n_sym ) )
			genexpr( 0, np->n_left );

		if( np->n_sym == SYM_OR || np->n_sym == SYM_AND ){
			l_andor = nextlab;
			nextlab++;
			addnode( lval, np, l_andor );
			genexpr( 0, np->n_right );
			labtab[ l_andor ] = l_prog;
		}else{
			genexpr( 0, np->n_right );
			addnode( lval, np, 0 );
		}

		if( np->n_sym == SYM_KW_STREF || np->n_sym == SYM_IX_STREF ){
			addinst( np->n_lineno, OP_STRF, NULL );
		}
	}
}

static	int	is_syscall( np )
NODE_T	*np;
{
	int	i;
	char	*sp;

	sp = np->n_val.v_value.v_pval;
	for( i = 0; i < N_SC; i++ ){
		if( !strcmp( sp, scnames[ i ] ) )
			return( i );
	}
	return( UNDEF );
}

static	void	fix_kw_stref( np )
NODE_T	*np;
{
	NODE_T	*np1, *np2, *np3;
	NODE_T	*n_index, *n_tag, *n_pos, *n_len;
	char	*ip;
	VALUE_T	v_expr;

	n_index = n_tag = n_pos = n_len = NULL;
	for( np1 = np->n_right; np1; np1 = np1->n_right ){
		np2 = np1->n_left;
		np3 = np2->n_left;
		if( np3->n_sym == SYM_IDENT ){
			ip = np3->n_val.v_value.v_pval;
			if( !strcmp( ip, "index" ) ){
				if( n_index != NULL ){
					rm_emsg_lineno = n_index->n_lineno;
					RM_errormsg( 1,
	"fix_kw_stref: index parameter may not appear more than once." );
				}else
					n_index = np2->n_right;
			}else if( !strcmp( ip, "tag" ) ){
				if( n_tag != NULL ){
					rm_emsg_lineno = n_tag->n_lineno;
					RM_errormsg( 1,
	"fix_kw_stref: tag parameter may not appear more than once." );
				}else
					n_tag = np2->n_right;
			}else if( !strcmp( ip, "pos" ) ){
				if( n_pos != NULL ){
					rm_emsg_lineno = n_pos->n_lineno;
					RM_errormsg( 1,
		"fix_kw_stref: pos parameter may not appear more than once." );
				}else
					n_pos = np2->n_right;
			}else if( !strcmp( ip, "len" ) ){
				if( n_len != NULL ){
					rm_emsg_lineno = n_len->n_lineno;
					RM_errormsg( 1,
		"fix_kw_stref: len parameter may not appear more than once." );
				}else
					n_len = np2->n_right;
			}else{
				rm_emsg_lineno = np3->n_lineno;
				sprintf( emsg,
				"fix_kw_stref: unknown parameter: '%s'.",
					ip );
				RM_errormsg( 1, emsg );
			}
		}
	}

	rm_emsg_lineno = np->n_lineno;
	if( n_index == NULL && n_tag == NULL ){
		rm_emsg_lineno = np->n_lineno;
		RM_errormsg( 1,
			"fix_kw_stref: index = or tag = require for stref()." );
	}

	np1 = mk_call_strid( n_tag, n_index, np->n_left->n_sym );

	/* build the 3 parms to stref	*/
	if( n_len == NULL ){
		v_expr.v_type = T_INT;
		v_expr.v_value.v_ival = -1;
		np3 = RM_node( SYM_INT, &v_expr, 0, 0 );
	}else
		np3 = n_len;
	np2 = RM_node( SYM_LIST, 0, np3, NULL );
	if( n_pos == NULL ){
		v_expr.v_type = T_INT;
		v_expr.v_value.v_ival = 1;
		np3 = RM_node( SYM_INT, &v_expr, 0, 0 );
	}else
		np3 = n_pos;
	np2 = RM_node( SYM_LIST, 0, np3, np2 );
	np1 = RM_node( SYM_LIST, 0, np1, np2 );
	np->n_right = np1;
}

static	void	fix_ix_stref( np )
NODE_T	*np;
{
	NODE_T	*np1, *np2, *np3;
	NODE_T	*n_index, *n_tag, *n_pos, *n_len;
	VALUE_T	v_expr;

	n_index = n_tag = n_pos = n_len = NULL;
	np1 = np->n_right;
	np2 = np1->n_left; 

	if( np2->n_sym == SYM_INT )
		n_index = np2;
	else if( np2->n_sym == SYM_STRING )
		n_tag = np2;

	if( np1->n_right != NULL ){
		np1 = np1->n_right;
		n_pos = np1->n_left; 
		if( np1->n_right != NULL ){
			np1 = np1->n_right;
			n_len = np1->n_left; 
		}
	}

	rm_emsg_lineno = np->n_lineno;
	if( n_index == NULL && n_tag == NULL ){
		rm_emsg_lineno = np->n_lineno;
		RM_errormsg( 1,
			"fix_ix_stref: index = or tag = require for stref()." );
	}

	np1 = mk_call_strid( n_tag, n_index, np->n_left->n_sym );

	/* build the 3 parms to stref	*/
	if( n_len == NULL ){
		v_expr.v_type = T_INT;
		v_expr.v_value.v_ival = -1;
		np3 = RM_node( SYM_INT, &v_expr, 0, 0 );
	}else
		np3 = n_len;
	np2 = RM_node( SYM_LIST, 0, np3, NULL );
	if( n_pos == NULL ){
		v_expr.v_type = T_INT;
		v_expr.v_value.v_ival = 1;
		np3 = RM_node( SYM_INT, &v_expr, 0, 0 );
	}else
		np3 = n_pos;
	np2 = RM_node( SYM_LIST, 0, np3, np2 );
	np1 = RM_node( SYM_LIST, 0, np1, np2 );
	np->n_right = np1;
}

static	NODE_T	*mk_call_strid( n_tag, n_index, strel )
NODE_T	*n_tag;
NODE_T	*n_index;
int	strel;
{
	NODE_T	*np1, *np2, *np3;
	VALUE_T	v_expr;
	int	k_tag, k_index;
	char	*v_tag;
	int	v_index;
	int	d, d_tag, d_index;
	STREL_T	*stp;

	k_tag = 0;
	v_tag = NULL;
	d_tag = UNDEF;
	k_index = 0;
	v_index = UNDEF;
	d_index = UNDEF;

	if( n_tag != NULL ){
		if( n_tag->n_sym == SYM_STRING ){
			k_tag = 1;
			v_tag = n_tag->n_val.v_value.v_pval;
		}
	}else{
		k_tag = 1;
		v_tag = NULL;
	}

	if( n_index != NULL ){
		if( n_index->n_sym == SYM_INT ){
			k_index = 1;
			v_index = n_index->n_val.v_value.v_ival;
		}
	}else{
		k_index = 1;
		v_index = UNDEF;
	}

	if( k_tag && k_index ){
		if( v_tag != NULL ){
			stp = rm_descr;
			for( d = 0; d < rm_n_descr; d++, stp++ ){
				if( stp->s_type == strel ){
					if( stp->s_tag == NULL )
						continue;
					else if( !strcmp( stp->s_tag, v_tag ) ){
						d_tag = d;
						break;
					}
				}
			}
			if( d_tag == UNDEF ){
				rm_emsg_lineno = n_tag->n_lineno;
				sprintf( emsg,
				"mk_call_strid: no such tag: '%s'.", v_tag );
				RM_errormsg( 1, emsg );
			}
		}
		if( v_index != UNDEF ){
			rm_emsg_lineno = n_index->n_lineno;
			if( v_index < 1 || v_index > rm_n_descr ){
				sprintf( emsg,
			"mk_call_strid: index must be between 1 and %d.",
					rm_n_descr );
				RM_errormsg( 1, emsg );
			}else
				d_index = v_index;
			if( rm_descr[ d_index - 1 ].s_type != strel ){
				sprintf( emsg,
		"mk_call_strid: strel with index= %d has wrong type.",
					v_index );
				RM_errormsg( 1, emsg );
			}
		}
		if( d_tag == UNDEF && d_index == UNDEF ){
			rm_emsg_lineno = n_tag->n_lineno;
			RM_errormsg( 1,
		"mk_call_strid: tag and index both have invalid values." );
		}else if( d_tag != UNDEF && d_index == UNDEF ){
			v_expr.v_type = T_INT;
			v_expr.v_value.v_ival = d_tag;
			np1 = RM_node( SYM_INT, &v_expr, 0, 0 );
			return( np1 );
		}else if( d_tag == UNDEF && d_index != UNDEF ){
			v_expr.v_type = T_INT;
			v_expr.v_value.v_ival = d_index - 1;
			np1 = RM_node( SYM_INT, &v_expr, 0, 0 );
			return( np1 );
		}else if( d_tag == d_index - 1 ){
			v_expr.v_type = T_INT;
			v_expr.v_value.v_ival = d_index;
			np1 = RM_node( SYM_INT, &v_expr, 0, 0 );
			return( np1 );
		}else{
			rm_emsg_lineno = n_tag->n_lineno;
			RM_errormsg( 1,
		"mk_call_strid: tag and index values are inconsistant." );
		}
	}

	if( n_tag == NULL ){
		v_expr.v_type = T_STRING;
		v_expr.v_value.v_pval = "";
		n_tag = RM_node( SYM_STRING, &v_expr, 0, 0 );
	}
	np2 = RM_node( SYM_LIST, 0, n_tag, NULL );

	if( n_index == NULL ){
		v_expr.v_type = T_INT;
		v_expr.v_value.v_ival = UNDEF;
		n_index = RM_node( SYM_INT, &v_expr, 0, 0 );
	}
		np3 = n_index;
	np2 = RM_node( SYM_LIST, 0, n_index, np2 );

	v_expr.v_type = T_INT;
	v_expr.v_value.v_ival = strel;
	np3 = RM_node( SYM_INT, &v_expr, 0, 0 );
	np2 = RM_node( SYM_LIST, 0, np3, np2 );

	v_expr.v_type = T_STRING;
	v_expr.v_value.v_pval = "STRID";
	np3 = RM_node( SYM_IDENT, &v_expr, 0, 0 );
	np1 = RM_node( SYM_CALL, 0, np3, np2 );
	return( np1 );
}

static	void	fix_call( np )
NODE_T	*np;
{
	int	sc, pcnt;
	NODE_T	*np1;

	sc = is_syscall( np );
	switch( sc ){
	case SC_LENGTH :
		break;
	case SC_MISMATCHES :
	case SC_MISPAIRS :
	case SC_PAIRED :
		for( pcnt = 0, np1 = np->n_right; np1; np1 = np1->n_right )
			pcnt++;
		if( pcnt != 1 ){
			rm_emsg_lineno = np->n_lineno;
			sprintf( emsg,
				"fix_call: function '%s' has only 1 parameter.",
				 scnames[ sc ] );
			RM_errormsg( 1, emsg );
		}
		np1 = np->n_right;
		np1 = np1->n_left;
		np1 = np1->n_right;
		np->n_right = np1;
		break;
	case SC_STRID :
		rm_emsg_lineno = np->n_lineno;
		RM_errormsg( 1, "fix_call: STRID can not be called by user." );
		break;
	default :
		rm_emsg_lineno = np->n_lineno;
		RM_errormsg( 1, "fix_call: unknown syscall." );
		break;
	}
}

static	void	do_fcl( ip )
INST_T	*ip;
{
	char	*cp;
	int	len;

	if( !strcmp( ip->i_val.v_value.v_pval, "length" ) ){
		cp = mem[ sp ].v_value.v_pval;
		len = strlen( cp );
		free( cp );
		mem[ mp ].v_type = T_INT;
		mem[ mp ].v_value.v_ival = len;
		sp = mp;
		mp = mem[ mp ].v_value.v_ival;
	}
}

static	void	do_scl( ip )
INST_T	*ip;
{
	char	*cp, *tag;
	int	stype, idx, pos, len;
	STREL_T	*stp;

	switch( ip->i_val.v_value.v_ival ){
	case SC_LENGTH :
		cp = mem[ sp ].v_value.v_pval;
		len = strlen( cp );
		free( cp );
		sp = mp;
		mp = mem[ mp ].v_value.v_ival;
		mem[ sp ].v_type = T_INT;
		mem[ sp ].v_value.v_ival = len;
		break; 
	case SC_MISMATCHES :
		idx = mem[ sp - 2 ].v_value.v_ival;
		if( idx < 0 || idx >= rm_n_descr ){
			rm_emsg_lineno = UNDEF;
			sprintf( emsg, 
		"do_scl: mismatches: descr index must be between 1 and %d.",
				rm_n_descr );
			RM_errormsg( 1, emsg );
		}
		sp -= 2;
		stp = &rm_descr[ idx ];
		sp = mp;
		mp = mem[ mp ].v_value.v_ival;
		mem[ sp ].v_type = T_INT;
		mem[ sp ].v_value.v_ival = stp->s_n_mismatches;
		break;
	case SC_MISPAIRS :
		idx = mem[ sp - 2 ].v_value.v_ival;
		if( idx < 0 || idx >= rm_n_descr ){
			rm_emsg_lineno = UNDEF;
			sprintf( emsg, 
		"do_scl: mispairs: descr index must be between 1 and %d.",
				rm_n_descr );
			RM_errormsg( 1, emsg );
		}
		sp -= 2;
		stp = &rm_descr[ idx ];
		sp = mp;
		mp = mem[ mp ].v_value.v_ival;
		mem[ sp ].v_type = T_INT;
		mem[ sp ].v_value.v_ival = stp->s_n_mispairs;
		break;
	case SC_PAIRED :
		idx = mem[ sp - 2 ].v_value.v_ival;
		if( idx < 0 || idx >= rm_n_descr ){
			rm_emsg_lineno = UNDEF;
			sprintf( emsg, 
		"do_scl: paired: descr index must be between 1 and %d.",
				rm_n_descr );
			RM_errormsg( 1, emsg );
		}
		stp = &rm_descr[ idx ];
		
		pos = mem[ sp - 1 ].v_value.v_ival;
		if( pos < 1 || pos > stp->s_matchlen ){
			rm_emsg_lineno = UNDEF;
			sprintf( emsg, 
		"do_scl: paired: pos must be between 1 and %d.",
				stp->s_matchlen );
			RM_errormsg( 1, emsg );
		}
		pos--;

		len = mem[ sp ].v_value.v_ival;
		if( len == 0 ){
			rm_emsg_lineno = UNDEF;
			sprintf( emsg, "do_scl: paired: len must be > 0." );
			RM_errormsg( 1, emsg );
		}else if( len < 0 )
			len = stp->s_matchlen - pos;
		else
			len = MIN( stp->s_matchlen - pos, len );
		sp -= 2;
		sp = mp;
		mp = mem[ mp ].v_value.v_ival;
		mem[ sp ].v_type = T_INT;
		mem[ sp ].v_value.v_ival = paired( stp, pos, len );
		break;

	case SC_STRID :
		tag = mem[ sp ].v_value.v_pval;
		idx = mem[ sp - 1 ].v_value.v_ival;
		stype = mem[ sp - 2 ].v_value.v_ival;
		sp -= 2;
		sp = mp;
		mp = mem[ mp ].v_value.v_ival;
		mem[ sp ].v_type = T_INT;
		mem[ sp ].v_value.v_ival = strid( stype, idx, tag );
		break;


	default :
		rm_emsg_lineno = UNDEF;
		RM_errormsg( 1, "do_scl: undefined syscall." );
		break;
	}
}

static	int	paired( stp, pos, len )
STREL_T	*stp;
int	pos;
int	len;
{
	STREL_T	*stp1, *stp2, *stp3, *stp4;
	int	i, mlen;
	int	p1, p2, p3, p4;
	int	b1, b2, b3, b4;

	mlen = stp->s_matchlen;
	switch( stp->s_n_mates ){
	case 1 : 
		if( stp->s_index < stp->s_mates[ 0 ]->s_index )
			stp1 = stp;
		else
			stp1 = stp->s_mates[ 0 ];
		stp2 = stp1->s_mates[ 0 ];
		p1 = stp1->s_matchoff;
		p2 = stp2->s_matchoff + mlen - 1;
		for( i = 0; i < len; i++ ){
			b1 = sc_sbuf[ p1 + pos + i ];
			b2 = sc_sbuf[ p2 - pos - i ];
			if( !RM_paired( stp1->s_pairset, b1, b2 ) )
				return( 0 );
		}
		return( 1 );
		break;
	case 2 :
		if( stp->s_index < stp->s_mates[ 0 ]->s_index )
			stp1 = stp;
		else
			stp1 = stp->s_mates[ 0 ];
		stp2 = stp1->s_mates[ 0 ];
		stp3 = stp1->s_mates[ 1 ];
		p1 = stp1->s_matchoff;
		p2 = stp2->s_matchoff + mlen - 1;
		p3 = stp3->s_matchoff;
		for( i = 0; i < len; i++ ){
			b1 = sc_sbuf[ p1 + pos + i ];
			b2 = sc_sbuf[ p2 - pos - i ];
			b3 = sc_sbuf[ p3 + pos + i ];
			if( !RM_triple( stp1->s_pairset, b1, b2, b3 ) )
				return( 0 );
		}
		return( 1 );
		break;
	case 3 :
		if( stp->s_index < stp->s_mates[ 0 ]->s_index )
			stp1 = stp;
		else
			stp1 = stp->s_mates[ 0 ];
		stp2 = stp1->s_mates[ 0 ];
		stp3 = stp1->s_mates[ 1 ];
		stp4 = stp1->s_mates[ 2 ];
		p1 = stp1->s_matchoff;
		p2 = stp2->s_matchoff + mlen - 1;
		p3 = stp3->s_matchoff;
		p4 = stp4->s_matchoff + mlen - 1;
		for( i = 0; i < len; i++ ){
			b1 = sc_sbuf[ p1 + pos + i ];
			b2 = sc_sbuf[ p2 - pos - i ];
			b3 = sc_sbuf[ p3 + pos + i ];
			b4 = sc_sbuf[ p4 - pos - i ];
			if( !RM_quad( stp1->s_pairset, b1, b2, b3, b4 ) )
				return( 0 );
		}
		return( 1 );
		break;
	default :
		rm_emsg_lineno = stp->s_lineno;
		RM_errormsg( 1, "paired() does not accept descr type 'ss'." );
		return( 0 );
		break;
	}
}

static	int	strid( stype, idx, tag )
int	stype;
int	idx;
char	*tag;
{
	int	s, t_idx;
	STREL_T	*stp;
	char	name1[ 20 ], name2[ 20 ];

	if( *tag == '\0' ){
		if( idx < 1 || idx > rm_n_descr ){
			rm_emsg_lineno = UNDEF;
			sprintf( emsg,
				"strid: index (%d) out of range: 1 .. %d.",
				idx, rm_n_descr );
			RM_errormsg( 1, emsg );
		}
		idx--;
		stp = &rm_descr[ idx ];
		if( stype != SYM_SE ){
			if( stp->s_type != stype ){
				mk_stref_name( stype, name1 );
				mk_stref_name( stp->s_type, name2 );
				rm_emsg_lineno = UNDEF;
				sprintf( emsg,
			"strid: descr type mismatch: is %s should be %s.",
					name1, name2 );
				RM_errormsg( 1, emsg );
			}
		}
	}else{
		stp = rm_descr;
		for( t_idx = UNDEF, s = 0; s < rm_n_descr; s++, stp++ ){ 
			if( stp->s_tag == NULL )
				continue;
			else if( !strcmp( stp->s_tag, tag ) ){
				if( stp->s_type == stype ){
					t_idx = s;
					break;
				}else if(stp->s_type==SYM_SS && stype==SYM_SE){ 
					t_idx = s;
					break;
				}else{
					mk_stref_name( stype, name1 );
					mk_stref_name( stp->s_type, name2 );
					rm_emsg_lineno = UNDEF;
					sprintf( emsg,
				"strid: ambiguous descr reference: %s vs %s.",
						name1, name2 );
					RM_errormsg( 1, emsg );
				}
			}
		}
		if( t_idx == UNDEF ){
			rm_emsg_lineno = UNDEF;
			sprintf( emsg, "strid: no such descr '%s'.", tag );
			RM_errormsg( 1, emsg );
		}else if( idx != UNDEF ){
			if( t_idx != idx ){
				rm_emsg_lineno = UNDEF;
				sprintf( emsg, 
				"strid: tag '%s' and index %d conflict.",
					tag, idx );
				RM_errormsg( 1, emsg );
			}
		}
	}
	return( idx );
}

static	void	do_strf( ip )
INST_T	*ip;
{
	int	index;
	int	pos;
	int	len;
	STREL_T	*stp;
	char	*cp;

	len   = mem[ sp     ].v_value.v_ival;
	pos   = mem[ sp - 1 ].v_value.v_ival;
	index = mem[ sp - 2 ].v_value.v_ival;
	if( index < 0 || index >= rm_n_descr ){
		rm_emsg_lineno = ip->i_lineno;;
		sprintf( emsg, "do_strf: no such descriptor %d.", index );
		RM_errormsg( 1, emsg );
	}
	stp = &rm_descr[ index ];
	if( pos < 1 ){
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( 1, "do_strf: pos must be > 0." );
	}else if( stp->s_matchlen == 0 ){
		pos = 1;	
	}else if( pos > stp->s_matchlen ){
		rm_emsg_lineno = ip->i_lineno;
		sprintf( emsg, "do_strf: pos must be <= %d.\n",
			stp->s_matchlen );
		RM_errormsg( 1, emsg );
	}
	pos--;
	if( len == 0 ){ 
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( 1, "do_strf: len must be > 0." );
	}else if( len == UNDEF )	/* rest of string */
		len = stp->s_matchlen - pos;
	else
		len = MIN( stp->s_matchlen - pos, len );
	cp = ( char * )malloc( ( len + 1 ) * sizeof( char ) );
	if( cp == NULL ){
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( 1, "do_strf: can't allocate cp." );
		exit( 1 );
	}
	strncpy( cp, &sc_sbuf[ stp->s_matchoff + pos ], len );
	cp[ len ] = '\0';
	sp -= 2; 
	mem[ sp ].v_type = T_STRING;
	mem[ sp ].v_value.v_pval = cp; 
}

static	void	do_lda( ip )
INST_T	*ip;
{
	VALUE_T	*v_top;
	IDENT_T	*idp;

	sp++;
	v_top = &mem[ sp ];
	idp = RM_find_id( ip->i_val.v_value.v_pval );
	if( idp == NULL ){
		idp = RM_enter_id( ip->i_val.v_value.v_pval, T_UNDEF, C_VAR,
			S_GLOBAL, 1, NULL );
		v_top->v_type = T_UNDEF;
		v_top->v_value.v_pval = idp;
	}else if( !idp->i_reinit ){
		rm_emsg_lineno = ip->i_lineno;
		sprintf( emsg, "do_lda: variable '%s' is readonly.", 
			idp->i_name );
		RM_errormsg( 1, emsg );
	}else{
		v_top->v_type = T_IDENT;
		v_top->v_value.v_pval = idp;
	}
}

static	void	do_lod( ip )
INST_T	*ip;
{
	VALUE_T	*v_top;
	IDENT_T	*idp;
	char	*cp;

	sp++;
	v_top = &mem[ sp ];
	idp = RM_find_id( ip->i_val.v_value.v_pval );
	if( idp == NULL ){
		rm_emsg_lineno = UNDEF;
		sprintf( emsg, "do_lod: variable '%s' is undefined.",
			idp->i_name );
		RM_errormsg( 1, emsg );
	}else{
		switch( idp->i_type ){
		case T_UNDEF :
			rm_emsg_lineno = UNDEF;
			sprintf( emsg,
				"do_lod: variable '%s' is undefined.",
				idp->i_name );
			RM_errormsg( 1, emsg );
			break;
		case T_INT :
			v_top->v_type = T_INT;
			v_top->v_value.v_ival = idp->i_val.v_value.v_ival;
			break;
		case T_FLOAT :
			v_top->v_type = T_FLOAT;
			v_top->v_value.v_fval = idp->i_val.v_value.v_fval;
			break;
		case T_STRING :
			cp = ( char * )
				malloc( strlen(idp->i_val.v_value.v_pval) + 1 );
			if( cp == NULL ){
				rm_emsg_lineno = UNDEF;
				RM_errormsg( 1, "do_lod: can't allocate cp." );
			}
			strcpy( cp, idp->i_val.v_value.v_pval );
			v_top->v_type = T_STRING;
			v_top->v_value.v_pval = cp;
			break;
		default :
			rm_emsg_lineno = ip->i_lineno;
			RM_errormsg( 1, "do_lod: type mismatch." );
			break;
		}
	}
}

static	void	do_ldc( ip )
INST_T	*ip;
{
	VALUE_T	*v_top;
	char	*cp;

	sp++;
	v_top = &mem[ sp ];
	switch( ip->i_val.v_type ){
	case T_INT :
		v_top->v_type = T_INT;
		v_top->v_value.v_ival = ip->i_val.v_value.v_ival;
		break;
	case T_FLOAT :
		v_top->v_type = T_FLOAT;
		v_top->v_value.v_fval = ip->i_val.v_value.v_fval;
		break;
	case T_STRING :
		v_top->v_type = T_STRING;
		cp = ( char * )malloc( strlen( ip->i_val.v_value.v_pval ) + 1 );
		if( cp == NULL ){
			rm_emsg_lineno = ip->i_lineno;
			RM_errormsg( 1, "do_ldc: can't allocate cp." );
		}
		strcpy( cp, ip->i_val.v_value.v_pval );
		v_top->v_value.v_pval = cp;
		break;
	case	T_POS :
		v_top->v_type = T_POS;
		v_top->v_value.v_pval = NULL;
		break;
	case 	T_PAIRSET :
		v_top->v_type = T_PAIRSET;
		v_top->v_value.v_pval = ip->i_val.v_value.v_pval;
		break;
	default :
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( 1, "do_ldc: type mismatch." );
		break;
	}
}

static	void	do_sto( ip )
INST_T	*ip;
{
	VALUE_T	*v_tm1, *v_top;
	int	t_tm1, t_top;
	IDENT_T	*idp;
	char	*cp;

	v_top = &mem[ sp ];
	t_top = v_top->v_type;
	sp--;
	v_tm1 = &mem[ sp ];
	idp = v_tm1->v_value.v_pval;
	t_tm1 = idp->i_type;
	
	switch( T_IJ( t_tm1, t_top ) ){
	case T_IJ( T_UNDEF, T_INT ):
		v_tm1->v_type = T_INT;
		idp->i_type = T_INT;
		idp->i_val.v_type = T_INT;
		idp->i_val.v_value.v_ival = v_top->v_value.v_ival;
		break;
	case T_IJ( T_UNDEF, T_FLOAT ):
		v_tm1->v_type = T_FLOAT;
		idp->i_type = T_INT;
		idp->i_val.v_type = T_INT;
		idp->i_val.v_value.v_ival = v_top->v_value.v_ival;
		break;
	case T_IJ( T_UNDEF, T_STRING ):
		cp = ( char * )malloc( strlen( v_top->v_value.v_pval ) + 1 );
		if( cp == NULL ){
			rm_emsg_lineno = UNDEF;
			RM_errormsg( 1, "do_sto: can't allocate new string." );
		}
		strcpy( cp, v_top->v_value.v_pval );
		idp->i_type = T_STRING;
		idp->i_val.v_type = T_STRING;
		idp->i_val.v_value.v_pval = cp;
		break;
	case T_IJ( T_INT, T_INT ) :
		idp->i_val.v_value.v_ival = v_top->v_value.v_ival;
		break;
	case T_IJ( T_INT, T_FLOAT ) :
		idp->i_val.v_value.v_ival = v_top->v_value.v_fval;
		break;
	case T_IJ( T_FLOAT, T_INT ) :
		idp->i_val.v_value.v_fval = v_top->v_value.v_ival;
		break;
	case T_IJ( T_FLOAT, T_FLOAT ) :
		idp->i_val.v_value.v_fval = v_top->v_value.v_fval;
		break;
	case T_IJ( T_STRING, T_STRING ) :
		cp = ( char * )malloc( strlen( v_top->v_value.v_pval ) + 1 );
		if( cp == NULL ){
			rm_emsg_lineno = UNDEF;
			RM_errormsg( 1, "do_sto: can't allocate new string." );
		}
		strcpy( cp, v_top->v_value.v_pval );
		free( idp->i_val.v_value.v_pval );
		idp->i_val.v_value.v_pval = cp;
		break;
	default :
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( 1, "do_sto: type mismatch." );
		break;
	}
}

static	void	do_and( ip )
INST_T	*ip;
{
	VALUE_T	*v_top;
	int	t_top, rv;

	v_top = &mem[ sp ];
	t_top = v_top->v_type;

	switch( t_top ){
	case T_INT :
		rv = v_top->v_value.v_ival = v_top->v_value.v_ival != 0;
		break;
	case T_FLOAT :
		rv = v_top->v_value.v_ival = v_top->v_value.v_fval != 0.0;
		break;
	case T_STRING :
		rv = v_top->v_value.v_ival =
			*( char * )v_top->v_value.v_pval != '\0';
		break;
	default :
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( 1, "do_and: type mismatch." );
		break;
	}
	if( !rv )
		pc = ip->i_val.v_value.v_ival;
}

static	void	do_ior( ip )
INST_T	*ip;
{
	VALUE_T	*v_top;
	int	t_top, rv;

	v_top = &mem[ sp ];
	t_top = v_top->v_type;

	switch( t_top ){
	case T_INT :
		rv = v_top->v_value.v_ival = v_top->v_value.v_ival != 0;
		break;
	case T_FLOAT :
		rv = v_top->v_value.v_ival = v_top->v_value.v_fval != 0.0;
		break;
	case T_STRING :
		rv = v_top->v_value.v_ival =
			*( char * )v_top->v_value.v_pval != '\0';
		break;
	default :
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( 1, "do_ior: type mismatch." );
		break;
	}
	if( rv )
		pc = ip->i_val.v_value.v_ival;
}

static	void	do_not( ip )
INST_T	*ip;
{
	VALUE_T	*v_top;
	int	t_top;

	v_top = &mem[ sp ];
	t_top = v_top->v_type;

	switch( t_top ){
	case T_INT :
		v_top->v_value.v_ival = !( v_top->v_value.v_ival != 0 );
		break;
	case T_FLOAT :
		v_top->v_value.v_ival = !( v_top->v_value.v_fval != 0.0 );
		break;
	case T_STRING :
		v_top->v_value.v_ival =
			!( *( char * )v_top->v_value.v_pval != '\0' );
		break;
	default :
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( 1, "do_not: type mismatch." );
		break;
	}
}

static	void	do_mat( ip )
INST_T	*ip;
{
	VALUE_T	*v_tm1, *v_top;
	int	t_tm1, t_top;
	char	*s_tm1, *s_top;
#define	EXPBUF_SIZE	256
	static	char	expbuf[ EXPBUF_SIZE ];

	v_top = &mem[ sp ];
	t_top = v_top->v_type;
	sp--;
	v_tm1 = &mem[ sp ];
	t_tm1 = v_tm1->v_type;
	v_tm1->v_type = T_INT;

	switch( T_IJ( t_tm1, t_top ) ){
	case T_IJ( T_STRING, T_STRING ) :
		s_tm1 = v_tm1->v_value.v_pval;
		s_top = v_top->v_value.v_pval;
		compile( s_top, expbuf, &expbuf[ EXPBUF_SIZE ], '\0' );
		v_tm1->v_value.v_ival = step( s_tm1, expbuf );
		free( s_top );
		free( s_tm1 );
		break;
	default :
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( 1, "do_mat: type mismatch." );
		break;
	}
}

static	void	do_ins( ip )
INST_T	*ip;
{
	VALUE_T	*v_bases[ 4 ], *v_top;
	char	*s_bases[ 4 ];
	int	l0, l_bases[ 4 ];
	int	i, n_bases;
	int	rv;
	PAIRSET_T	*ps_top;

	n_bases = sp - mp - 1;
	if( n_bases < 2 || n_bases > 4 ){
		rm_emsg_lineno = ip->i_lineno;
		sprintf( emsg, "do_ins: pair has %d bases, requires %d-%d.",
			n_bases, 2, 4 );
		RM_errormsg( 1, emsg );
	}

	v_top = &mem[ sp ];
	if( v_top->v_type != T_PAIRSET ){
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( 1,
			"do_ins: rhs of \"in\" must have type pairset." );
	}
	ps_top = v_top->v_value.v_pval;
	for( l0 = UNDEF, i = 0; i < n_bases; i++ ){
		v_bases[ i ] = &mem[ mp + 1 + i ];
		if( v_bases[ i ]->v_type != T_STRING ){
			rm_emsg_lineno = ip->i_lineno;
			RM_errormsg( 1,
				"do_ins: pair elements must be type string." );
		}
		l_bases[ i ] = strlen( v_bases[ i ]->v_value.v_pval );
		if( l0 == UNDEF )
			l0 = l_bases[ i ]; 
		else if( l_bases[ i ] != l0 ){
			rm_emsg_lineno = ip->i_lineno;
			RM_errormsg( 1,
		"do_ins: all pair elements must have the same length." );
		}
		s_bases[ i ] = v_bases[ i ]->v_value.v_pval;
	}

	switch( n_bases ){
	case 2 :
		for( rv = 1, i = 0; i < l0; i++ ){
			if( !RM_paired( ps_top, s_bases[0][i], s_bases[1][i] ) )
			{
				rv = 0;
				break;
			}
		}
		break;
	case 3 :
		for( rv = 1, i = 0; i < l0; i++ ){
			if( !RM_triple( ps_top,
				s_bases[0][i], s_bases[1][i], s_bases[2][i] ) )
			{
				rv = 0;
				break;
			}
		}
		break;
	case 4 :
		for( rv = 1, i = 0; i < l0; i++ ){
			if( !RM_quad( ps_top,
				s_bases[0][i], s_bases[1][i],
				s_bases[2][i], s_bases[3][i] ) )
			{
				rv = 0;
				break;
			}
		}
		break;
	}

	sp = mp;
	mp = mem[ mp ].v_value.v_ival;
	mem[ sp ].v_type = T_INT;
	mem[ sp ].v_value.v_ival = rv;
}

static	void	do_gtr( ip )
INST_T	*ip;
{
	VALUE_T	*v_tm1, *v_top;
	int	t_tm1, t_top;
	char	*s_tm1, *s_top;

	v_top = &mem[ sp ];
	t_top = v_top->v_type;
	sp--;
	v_tm1 = &mem[ sp ];
	t_tm1 = v_tm1->v_type;
	v_tm1->v_type = T_INT;
	
	switch( T_IJ( t_tm1, t_top ) ){
	case T_IJ( T_INT, T_INT ) :
		v_tm1->v_value.v_ival =
			v_tm1->v_value.v_ival > v_top->v_value.v_ival;
		break;
	case T_IJ( T_INT, T_FLOAT ) :
		v_tm1->v_value.v_ival =
			v_tm1->v_value.v_ival > v_top->v_value.v_fval;
		break;
	case T_IJ( T_FLOAT, T_INT ) :
		v_tm1->v_value.v_ival =
			v_tm1->v_value.v_fval > v_top->v_value.v_ival;
		break;
	case T_IJ( T_FLOAT, T_FLOAT ) :
		v_tm1->v_value.v_ival =
			v_tm1->v_value.v_fval > v_top->v_value.v_fval;
		break;
	case T_IJ( T_STRING, T_STRING ) :
		s_tm1 = v_tm1->v_value.v_pval;
		s_top = v_top->v_value.v_pval;
		v_tm1->v_value.v_ival = strcmp( s_tm1, s_top ) > 0;
		free( s_top );
		free( s_tm1 );
		break;
	default :
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( 1, "do_gtr: type mismatch." );
		break;
	}
}

static	void	do_geq( ip )
INST_T	*ip;
{
	VALUE_T	*v_tm1, *v_top;
	int	t_tm1, t_top;
	char	*s_tm1, *s_top;

	v_top = &mem[ sp ];
	t_top = v_top->v_type;
	sp--;
	v_tm1 = &mem[ sp ];
	t_tm1 = v_tm1->v_type;
	v_tm1->v_type = T_INT;
	
	switch( T_IJ( t_tm1, t_top ) ){
	case T_IJ( T_INT, T_INT ) :
		v_tm1->v_value.v_ival =
			v_tm1->v_value.v_ival >= v_top->v_value.v_ival;
		break;
	case T_IJ( T_INT, T_FLOAT ) :
		v_tm1->v_value.v_ival =
			v_tm1->v_value.v_ival >= v_top->v_value.v_fval;
		break;
	case T_IJ( T_FLOAT, T_INT ) :
		v_tm1->v_value.v_ival =
			v_tm1->v_value.v_fval >= v_top->v_value.v_ival;
		break;
	case T_IJ( T_FLOAT, T_FLOAT ) :
		v_tm1->v_value.v_ival =
			v_tm1->v_value.v_fval >= v_top->v_value.v_fval;
		break;
	case T_IJ( T_STRING, T_STRING ) :
		s_tm1 = v_tm1->v_value.v_pval;
		s_top = v_top->v_value.v_pval;
		v_tm1->v_value.v_ival = strcmp( s_tm1, s_top ) >= 0;
		free( s_top );
		free( s_tm1 );
		break;
	default :
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( 1, "do_geq: type mismatch." );
		exit( 1 );
		break;
	}
}

static	void	do_equ( ip )
INST_T	*ip;
{
	VALUE_T	*v_tm1, *v_top;
	int	t_tm1, t_top;
	char	*s_tm1, *s_top;

	v_top = &mem[ sp ];
	t_top = v_top->v_type;
	sp--;
	v_tm1 = &mem[ sp ];
	t_tm1 = v_tm1->v_type;
	v_tm1->v_type = T_INT;
	
	switch( T_IJ( t_tm1, t_top ) ){
	case T_IJ( T_INT, T_INT ) :
		v_tm1->v_value.v_ival =
			v_tm1->v_value.v_ival == v_top->v_value.v_ival;
		break;
	case T_IJ( T_INT, T_FLOAT ) :
		v_tm1->v_value.v_ival =
			v_tm1->v_value.v_ival == v_top->v_value.v_fval;
		break;
	case T_IJ( T_FLOAT, T_INT ) :
		v_tm1->v_value.v_ival =
			v_tm1->v_value.v_fval == v_top->v_value.v_ival;
		break;
	case T_IJ( T_FLOAT, T_FLOAT ) :
		v_tm1->v_value.v_ival =
			v_tm1->v_value.v_fval == v_top->v_value.v_fval;
		break;
	case T_IJ( T_STRING, T_STRING ) :
		s_tm1 = v_tm1->v_value.v_pval;
		s_top = v_top->v_value.v_pval;
		v_tm1->v_value.v_ival = strcmp( s_tm1, s_top ) == 0;
		free( s_top );
		free( s_tm1 );
		break;
	default :
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( 1, "do_equ: type mismatch." );
		break;
	}
}

static	void	do_neq( ip )
INST_T	*ip;
{
	VALUE_T	*v_tm1, *v_top;
	int	t_tm1, t_top;
	char	*s_tm1, *s_top;

	v_top = &mem[ sp ];
	t_top = v_top->v_type;
	sp--;
	v_tm1 = &mem[ sp ];
	t_tm1 = v_tm1->v_type;
	v_tm1->v_type = T_INT;
	
	switch( T_IJ( t_tm1, t_top ) ){
	case T_IJ( T_INT, T_INT ) :
		v_tm1->v_value.v_ival =
			v_tm1->v_value.v_ival != v_top->v_value.v_ival;
		break;
	case T_IJ( T_INT, T_FLOAT ) :
		v_tm1->v_value.v_ival =
			v_tm1->v_value.v_ival != v_top->v_value.v_fval;
		break;
	case T_IJ( T_FLOAT, T_INT ) :
		v_tm1->v_value.v_ival =
			v_tm1->v_value.v_fval != v_top->v_value.v_ival;
		break;
	case T_IJ( T_FLOAT, T_FLOAT ) :
		v_tm1->v_value.v_ival =
			v_tm1->v_value.v_fval != v_top->v_value.v_fval;
		break;
	case T_IJ( T_STRING, T_STRING ) :
		s_tm1 = v_tm1->v_value.v_pval;
		s_top = v_top->v_value.v_pval;
		v_tm1->v_value.v_ival = strcmp( s_tm1, s_top ) != 0;
		free( s_top );
		free( s_tm1 );
		break;
	default :
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( 1, "do_neq: type mismatch." );
		break;
	}
}

static	void	do_leq( ip )
INST_T	*ip;
{
	VALUE_T	*v_tm1, *v_top;
	int	t_tm1, t_top;
	char	*s_tm1, *s_top;

	v_top = &mem[ sp ];
	t_top = v_top->v_type;
	sp--;
	v_tm1 = &mem[ sp ];
	t_tm1 = v_tm1->v_type;
	v_tm1->v_type = T_INT;
	
	switch( T_IJ( t_tm1, t_top ) ){
	case T_IJ( T_INT, T_INT ) :
		v_tm1->v_value.v_ival =
			v_tm1->v_value.v_ival <= v_top->v_value.v_ival;
		break;
	case T_IJ( T_INT, T_FLOAT ) :
		v_tm1->v_value.v_ival =
			v_tm1->v_value.v_ival <= v_top->v_value.v_fval;
		break;
	case T_IJ( T_FLOAT, T_INT ) :
		v_tm1->v_value.v_ival =
			v_tm1->v_value.v_fval <= v_top->v_value.v_ival;
		break;
	case T_IJ( T_FLOAT, T_FLOAT ) :
		v_tm1->v_value.v_ival =
			v_tm1->v_value.v_fval <= v_top->v_value.v_fval;
		break;
	case T_IJ( T_STRING, T_STRING ) :
		s_tm1 = v_tm1->v_value.v_pval;
		s_top = v_top->v_value.v_pval;
		v_tm1->v_value.v_ival = strcmp( s_tm1, s_top ) <= 0;
		free( s_top );
		free( s_tm1 );
		break;
	default :
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( 1, "do_leq: type mismatch." );
		break;
	}
}

static	void	do_les( ip )
INST_T	*ip;
{
	VALUE_T	*v_tm1, *v_top;
	int	t_tm1, t_top;
	char	*s_tm1, *s_top;

	v_top = &mem[ sp ];
	t_top = v_top->v_type;
	sp--;
	v_tm1 = &mem[ sp ];
	t_tm1 = v_tm1->v_type;
	v_tm1->v_type = T_INT;
	
	switch( T_IJ( t_tm1, t_top ) ){
	case T_IJ( T_INT, T_INT ) :
		v_tm1->v_value.v_ival =
			v_tm1->v_value.v_ival < v_top->v_value.v_ival;
		break;
	case T_IJ( T_INT, T_FLOAT ) :
		v_tm1->v_value.v_ival =
			v_tm1->v_value.v_ival < v_top->v_value.v_fval;
		break;
	case T_IJ( T_FLOAT, T_INT ) :
		v_tm1->v_value.v_ival =
			v_tm1->v_value.v_fval < v_top->v_value.v_ival;
		break;
	case T_IJ( T_FLOAT, T_FLOAT ) :
		v_tm1->v_value.v_ival =
			v_tm1->v_value.v_fval < v_top->v_value.v_fval;
		break;
	case T_IJ( T_STRING, T_STRING ) :
		s_tm1 = v_tm1->v_value.v_pval;
		s_top = v_top->v_value.v_pval;
		v_tm1->v_value.v_ival = strcmp( s_tm1, s_top ) < 0;
		free( s_top );
		free( s_tm1 );
		break;
	default :
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( 1, "do_les: type mismatch." );
		break;
	}
}

static	void	do_add( ip )
INST_T	*ip;
{
	VALUE_T	*v_tm1, *v_top;
	int	t_tm1, t_top;

	v_top = &mem[ sp ];
	t_top = v_top->v_type;
	sp--;
	v_tm1 = &mem[ sp ];
	t_tm1 = v_tm1->v_type;
	
	switch( T_IJ( t_tm1, t_top ) ){
	case T_IJ( T_INT, T_INT ) :
		v_tm1->v_value.v_ival += v_top->v_value.v_ival;
		break;
	case T_IJ( T_INT, T_FLOAT ) :
		v_tm1->v_value.v_ival += v_top->v_value.v_fval;
		break;
	case T_IJ( T_FLOAT, T_INT ) :
		v_tm1->v_value.v_fval += v_top->v_value.v_ival;
		break;
	case T_IJ( T_FLOAT, T_FLOAT ) :
		v_tm1->v_value.v_fval += v_top->v_value.v_fval;
		break;
	default :
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( 1, "do_add: type mismatch." );
		break;
	}
}

static	void	do_sub( ip )
INST_T	*ip;
{
	VALUE_T	*v_tm1, *v_top;
	int	t_tm1, t_top;

	v_top = &mem[ sp ];
	t_top = v_top->v_type;
	sp--;
	v_tm1 = &mem[ sp ];
	t_tm1 = v_tm1->v_type;
	
	switch( T_IJ( t_tm1, t_top ) ){
	case T_IJ( T_INT, T_INT ) :
		v_tm1->v_value.v_ival -= v_top->v_value.v_ival;
		break;
	case T_IJ( T_INT, T_FLOAT ) :
		v_tm1->v_value.v_ival -= v_top->v_value.v_fval;
		break;
	case T_IJ( T_FLOAT, T_INT ) :
		v_tm1->v_value.v_fval -= v_top->v_value.v_ival;
		break;
	case T_IJ( T_FLOAT, T_FLOAT ) :
		v_tm1->v_value.v_fval -= v_top->v_value.v_fval;
		break;
	default :
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( 1, "do_sub: type mismatch." );
		break;
	}
}

static	void	do_mul( ip )
INST_T	*ip;
{
	VALUE_T	*v_tm1, *v_top;
	int	t_tm1, t_top;

	v_top = &mem[ sp ];
	t_top = v_top->v_type;
	sp--;
	v_tm1 = &mem[ sp ];
	t_tm1 = v_tm1->v_type;
	
	switch( T_IJ( t_tm1, t_top ) ){
	case T_IJ( T_INT, T_INT ) :
		v_tm1->v_value.v_ival *= v_top->v_value.v_ival;
		break;
	case T_IJ( T_INT, T_FLOAT ) :
		v_tm1->v_value.v_ival *= v_top->v_value.v_fval;
		break;
	case T_IJ( T_FLOAT, T_INT ) :
		v_tm1->v_value.v_fval *= v_top->v_value.v_ival;
		break;
	case T_IJ( T_FLOAT, T_FLOAT ) :
		v_tm1->v_value.v_fval *= v_top->v_value.v_fval;
		break;
	default :
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( 1, "do_mul: type mismatch." );
		break;
	}
}

static	void	do_div( ip )
INST_T	*ip;
{
	VALUE_T	*v_tm1, *v_top;
	int	t_tm1, t_top;

	v_top = &mem[ sp ];
	t_top = v_top->v_type;
	sp--;
	v_tm1 = &mem[ sp ];
	t_tm1 = v_tm1->v_type;
	
	switch( T_IJ( t_tm1, t_top ) ){
	case T_IJ( T_INT, T_INT ) :
		v_tm1->v_value.v_ival /= v_top->v_value.v_ival;
		break;
	case T_IJ( T_INT, T_FLOAT ) :
		v_tm1->v_value.v_ival /= v_top->v_value.v_fval;
		break;
	case T_IJ( T_FLOAT, T_INT ) :
		v_tm1->v_value.v_fval /= v_top->v_value.v_ival;
		break;
	case T_IJ( T_FLOAT, T_FLOAT ) :
		v_tm1->v_value.v_fval /= v_top->v_value.v_fval;
		break;
	default :
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( 1, "do_div: type mismatch." );
		break;
	}
}

static	void	do_mod( ip )
INST_T	*ip;
{
	VALUE_T	*v_tm1, *v_top;
	int	t_tm1, t_top;

	v_top = &mem[ sp ];
	t_top = v_top->v_type;
	sp--;
	v_tm1 = &mem[ sp ];
	t_tm1 = v_tm1->v_type;
	
	switch( T_IJ( t_tm1, t_top ) ){
	case T_IJ( T_INT, T_INT ) :
		v_tm1->v_value.v_ival %= v_top->v_value.v_ival;
		break;
	default :
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( 1, "do_mod: type mismatch." );
		break;
	}
}

static	void	do_neg( ip )
INST_T	*ip;
{
	VALUE_T	*v_top;
	int	t_top;

	v_top = &mem[ sp ];
	t_top = v_top->v_type;
	
	switch( t_top ){
	case T_INT :
		v_top->v_value.v_ival = -v_top->v_value.v_ival;
		break;
	case T_FLOAT :
		v_top->v_value.v_fval = -v_top->v_value.v_fval;
		break;
	default :
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( 1, "do_neg: type mismatch." );
		break;
	}
}

static	void	do_i_pp( ip )
INST_T	*ip;
{
	VALUE_T	*v_top;
	int	t_top;
	IDENT_T	*idp;

	v_top = &mem[ sp ];
	idp = v_top->v_value.v_pval;
	t_top = idp->i_type;
	
	switch( t_top ){
	case T_UNDEF :
		rm_emsg_lineno = ip->i_lineno;
		sprintf( emsg, "do_i_pp: variable '%s' is undefined.",
			idp->i_name );
		RM_errormsg( 1, emsg );
		break;
	case T_INT :
		v_top->v_value.v_ival = ( idp->i_val.v_value.v_ival )++;
		break;
	default :
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( 1, "do_i_pp: type mismatch." );
		break;
	}
}

static	void	do_pp_i( ip )
INST_T	*ip;
{
	VALUE_T	*v_top;
	int	t_top;
	IDENT_T	*idp;

	v_top = &mem[ sp ];
	idp = v_top->v_value.v_pval;
	t_top = idp->i_type;
	
	switch( t_top ){
	case T_UNDEF :
		rm_emsg_lineno = ip->i_lineno;
		sprintf( emsg, "do_pp_i: variable '%s' is undefined.",
			idp->i_name );
		RM_errormsg( 1, emsg );
		break;
	case T_INT :
		v_top->v_value.v_ival = ++( idp->i_val.v_value.v_ival );
		break;
	default :
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( 1, "do_pp_i: type mismatch." );
		break;
	}
}

static	void	do_i_mm( ip )
INST_T	*ip;
{
	VALUE_T	*v_top;
	int	t_top;
	IDENT_T	*idp;

	v_top = &mem[ sp ];
	idp = v_top->v_value.v_pval;
	t_top = idp->i_type;
	
	switch( t_top ){
	case T_UNDEF :
		rm_emsg_lineno = ip->i_lineno;
		sprintf( emsg, "do_i_mm: variable '%s' is undefined.",
			idp->i_name );
		RM_errormsg( 1, emsg );
		break;
	case T_INT :
		v_top->v_value.v_ival = ( idp->i_val.v_value.v_ival )--;
		break;
	default :
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( 1, "do_i_mm: type mismatch." );
		exit( 1 );
		break;
	}
}

static	void	do_mm_i( ip )
INST_T	*ip;
{
	VALUE_T	*v_top;
	int	t_top;
	IDENT_T	*idp;

	v_top = &mem[ sp ];
	idp = v_top->v_value.v_pval;
	t_top = idp->i_type;
	
	switch( t_top ){
	case T_UNDEF :
		rm_emsg_lineno = ip->i_lineno;
		sprintf( emsg, "do_mm_i: variable '%s' is undefined.",
			idp->i_name );
		RM_errormsg( 1, emsg );
		break;
	case T_INT :
		v_top->v_value.v_ival = --( idp->i_val.v_value.v_ival );
		break;
	default :
		rm_emsg_lineno = ip->i_lineno;
		RM_errormsg( 1, "do_mm_i: type mismatch." );
		break;
	}
}

static	void	mk_stref_name( sym, name )
int	sym;
char	name[];
{

	switch( sym ){
	case SYM_SE :
		strcpy( name, "se" );
		break;

	case SYM_SS :
		strcpy( name, "ss" );
		break;

	case SYM_H5 :
		strcpy( name, "h5" );
		break;
	case SYM_H3 :
		strcpy( name, "h3" );
		break;

	case SYM_P5 :
		strcpy( name, "p5" );
		break;
	case SYM_P3 :
		strcpy( name, "p3" );
		break;

	case SYM_T1 :
		strcpy( name, "t1" );
		break;
	case SYM_T2 :
		strcpy( name, "t2" );
		break;
	case SYM_T3 :
		strcpy( name, "t3" );
		break;

	case SYM_Q1 :
		strcpy( name, "q1" );
		break;
	case SYM_Q2 :
		strcpy( name, "q2" );
		break;
	case SYM_Q3 :
		strcpy( name, "q3" );
		break;
	case SYM_Q4 :
		strcpy( name, "q4" );
		break;

	default :
		sprintf( name, " ?%d? ", sym );
		break;
	}
}

static	void	addnode( lval, np, l_andor )
int	lval;
NODE_T	*np;
int	l_andor;
{
	VALUE_T	v_node;
	int	sc;

	rm_emsg_lineno = np->n_lineno;
	switch( np->n_sym ){

	case SYM_CALL :
		if( ( sc = is_syscall( np ) ) != UNDEF ){
			v_node.v_type = T_INT;
			v_node.v_value.v_ival = sc;
			addinst( np->n_lineno, OP_SCL, &v_node );
		}else
			addinst( np->n_lineno, OP_FCL, &np->n_val );
		break;
	case SYM_LIST :
		break;
	case SYM_KW_STREF :
	case SYM_IX_STREF :
		break;

	case SYM_PARMS :
		break;
	case SYM_DESCR :
		break;
	case SYM_SITES :
		break;

	case SYM_SS :
	case SYM_H5 :
	case SYM_H3 :
	case SYM_P5 :
	case SYM_P3 :
	case SYM_T1 :
	case SYM_T2 :
	case SYM_T3 :
	case SYM_Q1 :
	case SYM_Q2 :
	case SYM_Q3 :
	case SYM_Q4 :
		break;

	case SYM_ELSE :
		break;
	case SYM_FOR :
		break;
	case SYM_IF :
		break;
	case SYM_WHILE :
		break;

	case SYM_IDENT :
		if( lval ){
			addinst( np->n_lineno, OP_LDA, &np->n_val );
		}else{
			addinst( np->n_lineno, OP_LOD, &np->n_val );
		}
		break;
	case SYM_INT :
		addinst( np->n_lineno, OP_LDC, &np->n_val );
		break;
	case SYM_FLOAT :
		addinst( np->n_lineno, OP_LDC, &np->n_val );
		break;
	case SYM_STRING :
		addinst( np->n_lineno, OP_LDC, &np->n_val );
		break;
	case SYM_DOLLAR :
		v_node.v_type = T_POS;
		v_node.v_value.v_pval = NULL;
		addinst( np->n_lineno, OP_LDC, &v_node );
		break;
	case SYM_PAIRSET :
		addinst( np->n_lineno, OP_LDC, &np->n_val );
		break;

	case SYM_ASSIGN :
		addinst( np->n_lineno, OP_STO, NULL );
		break;

	case SYM_PLUS_ASSIGN :
		addinst( np->n_lineno, OP_ADD, NULL );
		addinst( np->n_lineno, OP_STO, NULL );
		break;
	case SYM_MINUS_ASSIGN :
		addinst( np->n_lineno, OP_SUB, NULL );
		addinst( np->n_lineno, OP_STO, NULL );
		break;
	case SYM_PERCENT_ASSIGN :
		addinst( np->n_lineno, OP_MOD, NULL );
		addinst( np->n_lineno, OP_STO, NULL );
		break;
	case SYM_STAR_ASSIGN :
		addinst( np->n_lineno, OP_MUL, NULL );
		addinst( np->n_lineno, OP_STO, NULL );
		break;
	case SYM_SLASH_ASSIGN :
		addinst( np->n_lineno, OP_DIV, NULL );
		addinst( np->n_lineno, OP_STO, NULL );
		break;

	case SYM_AND :
		v_lab.v_type = T_INT;
		v_lab.v_value.v_ival = l_andor;
		addinst( np->n_lineno, OP_AND, &v_lab );
		break;
	case SYM_OR :
		v_lab.v_type = T_INT;
		v_lab.v_value.v_ival = l_andor;
		addinst( np->n_lineno, OP_IOR, &v_lab );
		break;
	case SYM_NOT :
		addinst( np->n_lineno, OP_NOT, NULL );
		break;

	case SYM_EQUAL :
		addinst( np->n_lineno, OP_EQU, NULL );
		break;
	case SYM_NOT_EQUAL :
		addinst( np->n_lineno, OP_NEQ, NULL );
		break;
	case SYM_GREATER :
		addinst( np->n_lineno, OP_GTR, NULL );
		break;
	case SYM_GREATER_EQUAL :
		addinst( np->n_lineno, OP_GEQ, NULL );
		break;
	case SYM_LESS :
		addinst( np->n_lineno, OP_LES, NULL );
		break;
	case SYM_LESS_EQUAL :
		addinst( np->n_lineno, OP_LEQ, NULL );
		break;

	case SYM_MATCH :
		addinst( np->n_lineno, OP_MAT, NULL );
		break;
	case SYM_DONT_MATCH :
		addinst( np->n_lineno, OP_MAT, NULL );
		addinst( np->n_lineno, OP_NOT, NULL );
		break;
	case SYM_IN :
		addinst( np->n_lineno, OP_INS, NULL );
		break;

	case SYM_PLUS :
		addinst( np->n_lineno, OP_ADD, NULL );
		break;
	case SYM_MINUS :
		addinst( np->n_lineno, OP_SUB, NULL );
		break;
	case SYM_PERCENT :
		addinst( np->n_lineno, OP_MOD, NULL );
		break;
	case SYM_STAR :
		addinst( np->n_lineno, OP_MUL, NULL );
		break;
	case SYM_SLASH :
		addinst( np->n_lineno, OP_DIV, NULL );
		break;
	case SYM_NEGATE :
		addinst( np->n_lineno, OP_NEG, NULL );
		break;

	case SYM_COLON :
		break;

	case SYM_MINUS_MINUS :
		if( np->n_left ){
			addinst( np->n_lineno, OP_I_MM, NULL );
		}else{
			addinst( np->n_lineno, OP_MM_I, NULL );
		}
		break;
	case SYM_PLUS_PLUS :
		if( np->n_left ){
			addinst( np->n_lineno, OP_I_PP, NULL );
		}else{
			addinst( np->n_lineno, OP_PP_I, NULL );
		}
		break;

	case SYM_LPAREN :
		break;
	case SYM_RPAREN :
		break;
	case SYM_LCURLY :
		break;
	case SYM_RCURLY :
		break;
	case SYM_COMMA :
		break;
	case SYM_SEMICOLON :
		break;
	case SYM_ERROR :
		RM_errormsg( 1, "addnode: SYM_ERROR." );
		break;
	default :
		sprintf( emsg, "addnode: Unknown symbol %d\n", np->n_sym );
		RM_errormsg( 1, emsg );
		break;
	}
}

static	void	addinst( ln, op, vp )
int	ln;
int	op;
VALUE_T	*vp;
{
	INST_T	*ip;
	char	*sp;

	if( pc >= PROG_SIZE ){
		RM_errormsg( 1, "addinst: program size exceeded." );
	}else{
		ip = &prog[ l_prog ];
		l_prog++;
		ip->i_lineno = ln;
		ip->i_op = op;
		if( vp == NULL ){
			ip->i_val.v_type = T_UNDEF;
			ip->i_val.v_value.v_ival = 0;
		}else{
			ip->i_val.v_type = vp->v_type;
			if( vp->v_type == T_INT )
				ip->i_val.v_value.v_ival = vp->v_value.v_ival;
			else if( vp->v_type == T_FLOAT )
				ip->i_val.v_value.v_fval = vp->v_value.v_fval;
			else if( vp->v_type==T_STRING || vp->v_type==T_IDENT ){
				sp = ( char * )malloc( 
					strlen( vp->v_value.v_pval ) + 1 );
				if( sp == NULL ){
					RM_errormsg( 1,
						"addinst: can't allocate sp." );
				}
				strcpy( sp, vp->v_value.v_pval );
				ip->i_val.v_value.v_pval = sp;
			}else if( vp->v_type == T_PAIRSET ){
				ip->i_val.v_value.v_pval = vp->v_value.v_pval;
			}
		}
	}
}

static	void	dumpinst( fp, i, ip )
FILE	*fp;
INST_T	*ip;
{
	VALUE_T	*vp;
	
	if( ip->i_op < 0 || ip->i_op >= N_OP ){
		rm_emsg_lineno = UNDEF;
		sprintf( emsg, "dumpinst: bad op %d\n", ip->i_op );
		RM_errormsg( 1, emsg );
	}

	fprintf( fp, "%5d ", i );
	fprintf( fp, "  %s", opnames[ ip->i_op ] );
	switch( ip->i_op ){
	case OP_NOOP :
	case OP_ACPT :
	case OP_RJCT :
	case OP_MRK :
	case OP_CLS :
		break;

	case OP_FCL :
	case OP_SCL :
		break;
	case OP_STRF :
		break;

	case OP_LDA :
	case OP_LOD :
		break;

	case OP_LDC :
		break;

	case OP_STO :
		break;

	case OP_AND :
	case OP_IOR :
		break;

	case OP_NOT :
		break;

	case OP_MAT :
	case OP_INS :
	case OP_GTR :
	case OP_GEQ :
	case OP_EQU :
	case OP_NEQ :
	case OP_LEQ :
	case OP_LES :
		break;

	case OP_ADD :
	case OP_SUB :
	case OP_MUL :
	case OP_DIV :
	case OP_MOD :
		break;

	case OP_NEG :
		break;

	case OP_I_PP :
	case OP_PP_I :
	case OP_I_MM :
	case OP_MM_I :
		break;

	case OP_FJP :
	case OP_JMP :
		break;
	}
	vp = &ip->i_val;
	if( ip->i_op == OP_LDA || ip->i_op == OP_LOD ){
		fprintf( fp, " %s", vp->v_value.v_pval );
	}else if( ip->i_op == OP_SCL ){
		fprintf( fp, " %s", scnames[ vp->v_value.v_ival ] );
	}else if( vp->v_type == T_INT ){
		fprintf( fp, " %d", vp->v_value.v_ival );
	}else if( vp->v_type == T_FLOAT ) 
		fprintf( fp, " %f", vp->v_value.v_fval );
	else if( vp->v_type == T_STRING )
		fprintf( fp, " \"%s\"", vp->v_value.v_pval );
	else if( vp->v_type == T_POS )
		fprintf( fp, " $" );
	else if( vp->v_type == T_IDENT )
		fprintf( fp, " %s", vp->v_value.v_pval );
	else if( vp->v_type == T_PAIRSET ){
		fprintf( fp, " " );
		RM_dump_pairset( fp, vp->v_value.v_pval );
	}
	fprintf( fp, "\n" );
}

static	void	dumpstk( fp, msg )
FILE	*fp;
char	msg[];
{
	int	i;
	VALUE_T	*vp;

	fprintf( fp, "%s: sp = %5d, mp = %5d\n", msg, sp, mp );
	for( vp = mem, i = 0; i <= sp; i++, vp++ ){
		fprintf( fp, "  mem[%4d]: ", i );
		switch( vp->v_type ){
		case T_UNDEF :
			fprintf( fp, "U " );
			break;
		case T_INT :
			fprintf( fp, "I %6d", vp->v_value.v_ival );
			break;
		case T_FLOAT :
			fprintf( fp, "F %8.3f", vp->v_value.v_fval );
			break;
		case T_STRING :
			fprintf( fp, "S \"%s\"", vp->v_value.v_pval );
			break;
		case T_PAIRSET :
			fprintf( fp, "Pr" );
			break;
		case T_POS :
			fprintf( fp, "Ps" );
			break;
		case T_IDENT :
			fprintf( fp, "Id" );
			break;
		default :
			fprintf( fp, "? " );
			break;
		}
		fprintf( fp, "\n" );
	}
}
@


1.22
log
@about 1/2 way to x in {}.  The data is being store, the ldc {}
works, but the ins inst is not implemented.
Also added a field i_lineno to the instruction so as to be able
to give the source line number of an offending instruction.
@
text
@d176 2
a177 1
static	void	fix_stref();
d595 4
a598 2
		if( np->n_sym == SYM_STREF ){
			fix_stref( np );
d634 1
a634 1
		if( np->n_sym == SYM_STREF ){
d654 1
a654 1
static	void	fix_stref( np )
d672 1
a672 1
		"fix_stref: index parameter may not appear more than once." );
d679 1
a679 1
		"fix_stref: tag parameter may not appear more than once." );
d686 1
a686 1
		"fix_stref: pos parameter may not appear more than once." );
d693 1
a693 1
		"fix_stref: len parameter may not appear more than once." );
d699 1
a699 1
					"fix_stref: unknown parameter: '%s'.",
d710 1
a710 1
			"fix_stref: index = or tag = require for stref()." );
d734 53
d1380 4
d1579 72
d1652 4
d2294 2
a2295 1
	case SYM_STREF :
@


1.21
log
@added code that implements match & don't match (=~, !~)
@
text
@d72 7
a78 9
#define	OP_PRST		29	/* Make a pairset	*/
#define	OP_BPR		30	/* Make a pair		*/
#define	OP_I_PP		31	/* use then incr (i++)	*/
#define	OP_PP_I		32	/* incr then use (++i)	*/
#define	OP_I_MM		33	/* use then decr (i--)	*/
#define	OP_MM_I		34	/* decr then use (--i)	*/
#define	OP_FJP		35	/* False Jump		*/
#define	OP_JMP		36	/* Jump			*/
#define	N_OP		37
a109 2
	"prst",
	"bpr",
d134 1
a204 2
static	void	do_prst();
static	void	do_bpr();
d226 1
a226 1
	addinst( OP_FJP, &v_lab );
d246 1
a246 1
	addinst( OP_FJP, &v_lab );
d254 1
a254 1
	addinst( OP_JMP, &v_lab );
d293 1
a293 1
	addinst( OP_FJP, &v_lab );
d312 1
a312 1
	addinst( OP_JMP, &v_lab );
d329 1
a329 1
	addinst( OP_FJP, &v_lab );
d337 1
a337 1
	addinst( OP_JMP, &v_lab );
d347 1
a347 1
	addinst( OP_JMP, &v_lab );
d355 1
a355 1
	addinst( OP_JMP, &v_lab );
d361 1
a361 1
	addinst( OP_ACPT, NULL );
d367 1
a367 1
	addinst( OP_RJCT, NULL );
d373 1
a373 1
	addinst( OP_MRK, NULL );
d379 1
a379 1
	addinst( OP_CLS, 0 );
d496 1
a496 1
			do_sto();
d506 1
a506 1
			do_not();
d510 1
a510 1
			do_mat();
d513 1
a513 1
			do_ins();
d516 1
a516 1
			do_gtr();
d519 1
a519 1
			do_geq();
d522 1
a522 1
			do_equ();
d525 1
a525 1
			do_neq();
d528 1
a528 1
			do_leq();
d531 1
a531 1
			do_les();
d535 1
a535 1
			do_add();
d538 1
a538 1
			do_sub();
d541 1
a541 1
			do_mul();
d544 1
a544 1
			do_div();
d547 1
a547 1
			do_mod();
d550 1
a550 1
			do_neg();
a552 7
		case OP_PRST :
			do_prst();
			break;
		case OP_BPR :
			do_bpr();
			break;

d554 1
a554 1
			do_i_pp();
d557 1
a557 1
			do_pp_i();
d560 1
a560 1
			do_i_mm();
d563 1
a563 1
			do_mm_i();
d575 1
d610 3
a612 3
			addinst( OP_MRK, NULL );
		}else if( np->n_sym == SYM_LCURLY ){
			addinst( OP_MRK, NULL );
d632 1
a632 3
			addinst( OP_STRF, NULL );
		}else if( np->n_sym == SYM_LCURLY ){
			addinst( OP_PRST, NULL );
d705 1
d1180 1
a1180 1
		rm_emsg_lineno = UNDEF;
d1186 1
a1186 1
		rm_emsg_lineno = UNDEF;
d1191 1
a1191 1
		rm_emsg_lineno = UNDEF;
d1198 1
a1198 1
		rm_emsg_lineno = UNDEF;
d1206 1
a1206 1
		rm_emsg_lineno = UNDEF;
d1232 1
a1232 1
		rm_emsg_lineno = UNDEF;
d1285 3
a1287 3
		case T_PAIR :
			break;
		case T_POS :
a1288 2
		case T_IDENT :
			break;
d1314 1
a1314 1
			rm_emsg_lineno = UNDEF;
d1325 1
a1325 1
		rm_emsg_lineno = UNDEF;
d1331 2
a1332 1
static	void	do_sto()
a1369 2
	case T_IJ( T_UNDEF, T_PAIR ):
		break;
a1375 2
	case T_IJ( T_INT, T_POS ) :
		break;
a1391 2
	case T_IJ( T_PAIR, T_PAIR ) :
		break;
d1393 1
a1393 1
		rm_emsg_lineno = UNDEF;
d1420 1
a1420 1
		rm_emsg_lineno = UNDEF;
d1449 1
a1449 1
		rm_emsg_lineno = UNDEF;
d1457 2
a1458 1
static	void	do_not()
d1478 1
a1478 1
		rm_emsg_lineno = UNDEF;
d1484 2
a1485 1
static	void	do_mat()
d1510 1
a1510 1
		rm_emsg_lineno = UNDEF;
d1516 2
a1517 1
static	void	do_ins()
d1522 2
a1523 1
static	void	do_gtr()
d1561 1
a1561 1
		rm_emsg_lineno = UNDEF;
d1567 2
a1568 1
static	void	do_geq()
d1606 1
a1606 1
		rm_emsg_lineno = UNDEF;
d1613 2
a1614 1
static	void	do_equ()
d1652 1
a1652 1
		rm_emsg_lineno = UNDEF;
d1658 2
a1659 1
static	void	do_neq()
d1697 1
a1697 1
		rm_emsg_lineno = UNDEF;
d1703 2
a1704 1
static	void	do_leq()
d1742 1
a1742 1
		rm_emsg_lineno = UNDEF;
d1748 2
a1749 1
static	void	do_les()
d1787 1
a1787 1
		rm_emsg_lineno = UNDEF;
d1793 2
a1794 1
static	void	do_add()
a1811 2
	case T_IJ( T_INT, T_POS ) :
		break;
a1817 6
	case T_IJ( T_STRING, T_STRING ) :
		break;
	case T_IJ( T_PAIR, T_PAIR ) :
		break;
	case T_IJ( T_POS, T_INT ) :
		break;
d1819 1
a1819 1
		rm_emsg_lineno = UNDEF;
d1825 2
a1826 1
static	void	do_sub()
a1843 2
	case T_IJ( T_INT, T_POS ) :
		break;
a1849 4
	case T_IJ( T_PAIR, T_PAIR ) :
		break;
	case T_IJ( T_POS, T_INT ) :
		break;
d1851 1
a1851 1
		rm_emsg_lineno = UNDEF;
d1857 2
a1858 1
static	void	do_mul()
d1883 1
a1883 1
		rm_emsg_lineno = UNDEF;
d1889 2
a1890 1
static	void	do_div()
d1915 1
a1915 1
		rm_emsg_lineno = UNDEF;
d1921 2
a1922 1
static	void	do_mod()
d1938 1
a1938 1
		rm_emsg_lineno = UNDEF;
d1944 2
a1945 1
static	void	do_neg()
d1961 1
a1961 1
		rm_emsg_lineno = UNDEF;
d1967 2
a1968 11
static	void	do_prst()
{

}

static	void	do_bpr()
{

}

static	void	do_i_pp()
d1972 1
a1972 1
	IDENT_T	*ip;
d1975 2
a1976 2
	ip = v_top->v_value.v_pval;
	t_top = ip->i_type;
d1980 1
a1980 1
		rm_emsg_lineno = UNDEF;
d1982 1
a1982 1
			ip->i_name );
d1986 1
a1986 1
		v_top->v_value.v_ival = ( ip->i_val.v_value.v_ival )++;
d1989 1
a1989 1
		rm_emsg_lineno = UNDEF;
d1995 2
a1996 1
static	void	do_pp_i()
d2000 1
a2000 1
	IDENT_T	*ip;
d2003 2
a2004 2
	t_top = v_top->v_type;
	ip = v_top->v_value.v_pval;
d2008 1
a2008 1
		rm_emsg_lineno = UNDEF;
d2010 1
a2010 1
			ip->i_name );
d2014 1
a2014 1
		v_top->v_value.v_ival = ++( ip->i_val.v_value.v_ival );
d2017 1
a2017 1
		rm_emsg_lineno = UNDEF;
d2023 2
a2024 1
static	void	do_i_mm()
d2028 1
a2028 1
	IDENT_T	*ip;
d2031 2
a2032 2
	t_top = v_top->v_type;
	ip = v_top->v_value.v_pval;
d2036 1
a2036 1
		rm_emsg_lineno = UNDEF;
d2038 1
a2038 1
			ip->i_name );
d2042 1
a2042 1
		v_top->v_value.v_ival = ( ip->i_val.v_value.v_ival )--;
d2045 1
a2045 1
		rm_emsg_lineno = UNDEF;
d2052 2
a2053 1
static	void	do_mm_i()
d2057 1
a2057 1
	IDENT_T	*ip;
d2060 2
a2061 2
	t_top = v_top->v_type;
	ip = v_top->v_value.v_pval;
d2065 1
a2065 1
		rm_emsg_lineno = UNDEF;
d2067 1
a2067 1
			ip->i_name );
d2071 1
a2071 1
		v_top->v_value.v_ival = --( ip->i_val.v_value.v_ival );
d2074 1
a2074 1
		rm_emsg_lineno = UNDEF;
d2152 1
a2152 1
			addinst( OP_SCL, &v_node );
d2154 1
a2154 1
			addinst( OP_FCL, &np->n_val );
d2193 1
a2193 1
			addinst( OP_LDA, &np->n_val );
d2195 1
a2195 1
			addinst( OP_LOD, &np->n_val );
d2199 1
a2199 1
		addinst( OP_LDC, &np->n_val );
d2202 1
a2202 1
		addinst( OP_LDC, &np->n_val );
d2205 1
a2205 1
		addinst( OP_LDC, &np->n_val );
d2210 4
a2213 1
		addinst( OP_LDC, &v_node );
d2217 1
a2217 1
		addinst( OP_STO, NULL );
d2221 2
a2222 2
		addinst( OP_ADD, NULL );
		addinst( OP_STO, NULL );
d2225 2
a2226 2
		addinst( OP_SUB, NULL );
		addinst( OP_STO, NULL );
d2229 2
a2230 2
		addinst( OP_MOD, NULL );
		addinst( OP_STO, NULL );
d2233 2
a2234 2
		addinst( OP_MUL, NULL );
		addinst( OP_STO, NULL );
d2237 2
a2238 2
		addinst( OP_DIV, NULL );
		addinst( OP_STO, NULL );
d2244 1
a2244 1
		addinst( OP_AND, &v_lab );
d2249 1
a2249 1
		addinst( OP_IOR, &v_lab );
d2252 1
a2252 1
		addinst( OP_NOT, NULL );
d2256 1
a2256 1
		addinst( OP_EQU, NULL );
d2259 1
a2259 1
		addinst( OP_NEQ, NULL );
d2262 1
a2262 1
		addinst( OP_GTR, NULL );
d2265 1
a2265 1
		addinst( OP_GEQ, NULL );
d2268 1
a2268 1
		addinst( OP_LES, NULL );
d2271 1
a2271 1
		addinst( OP_LEQ, NULL );
d2275 1
a2275 1
		addinst( OP_MAT, NULL );
d2278 2
a2279 2
		addinst( OP_MAT, NULL );
		addinst( OP_NOT, NULL );
d2282 1
a2282 1
		addinst( OP_INS, NULL );
d2286 1
a2286 1
		addinst( OP_ADD, NULL );
d2289 1
a2289 1
		addinst( OP_SUB, NULL );
d2292 1
a2292 1
		addinst( OP_MOD, NULL );
d2295 1
a2295 1
		addinst( OP_MUL, NULL );
d2298 1
a2298 1
		addinst( OP_DIV, NULL );
d2301 1
a2301 1
		addinst( OP_NEG, NULL );
a2304 1
		addinst( OP_BPR, NULL );
d2309 1
a2309 1
			addinst( OP_I_MM, NULL );
d2311 1
a2311 1
			addinst( OP_MM_I, NULL );
d2316 1
a2316 1
			addinst( OP_I_PP, NULL );
d2318 1
a2318 1
			addinst( OP_PP_I, NULL );
d2344 2
a2345 1
static	void	addinst( op, vp )
d2357 1
d2377 2
a2448 4
	case OP_PRST :
	case OP_BPR :
		break;

d2474 4
d2504 1
a2504 1
		case T_PAIR :
@


1.20
log
@removed unused vars as detected by fermat's C compiler.  Fixed (undetected)
bug that would have made pair( 4-plex ) not work as it used the 3d
base for 3 & 4.
@
text
@d1504 5
d1510 21
@


1.19
log
@fixed bug that considered descriptor indexes on the interval
[0,n_descr) even though they were on the interval [1,n_descr]
@
text
@a600 1
	int	sc;
a616 1
	char	name[ 20 ];
a617 1
	VALUE_T	v_expr;
a623 1
RM_dumpexpr( stderr, np, 0 );
d669 1
a669 1
	char	*ip, *sp;
d1095 1
a1095 1
			b4 = sc_sbuf[ p3 - pos - i ];
d1104 1
a2139 1
	POS_T	*posp;
a2380 1
	char	name[ 20 ];
@


1.18
log
@fixed bug that improperly computed the target for the JMP at the end of the
then clause.
@
text
@d627 1
d809 1
a809 1
			if( v_index < 0 || v_index >= rm_n_descr ){
@


1.17
log
@added new variable SCORE which holds will be passed back to find_motif()
and eventually printed by print_match.
@
text
@d258 1
a258 4
/*
	v_lab.v_value.v_ival = ifstk[ ifstkp - 1 ];
*/
	v_lab.v_value.v_ival = ifstk[ 0 ] + 1;
@


1.16
log
@fixed bug in mk_call_strid() that forgot to check if tag == NULL.  Also added code
in do_strf() to accept pos = 1, for matchlen = 0.
@
text
@d41 1
d258 1
d260 2
d403 2
a404 1
	VALUE_T	v_NSE;
d415 7
a421 3
	v_NSE.v_type = T_INT;
	v_NSE.v_value.v_ival = rm_n_descr;
	RM_enter_id( "NSE", T_INT, C_VAR, S_GLOBAL, 1, &v_NSE );
d436 1
a436 1
int	RM_score( sbuf )
d438 1
d442 1
d467 1
d598 1
@


1.15
log
@fixed type = T_FLOAT bug that converted reflexive lod's to T_FLOAT.
@
text
@d781 3
a783 1
					if( !strcmp( stp->s_tag, v_tag ) ){
d789 3
a791 2
			rm_emsg_lineno = n_tag->n_lineno;
			sprintf( emsg,
d793 2
a794 1
			RM_errormsg( 1, emsg );
d1192 2
@


1.14
log
@implemented STRID(), se() allowing loop over the descriptors:

	for( i = 1; i <= NSE; i++ ){
		mpr += mispair( se( index=i ) );
		...
	}
@
text
@d390 1
d2347 1
a2347 1
			else if( vp->v_type = T_FLOAT )
d2444 1
a2444 1
	if( ip->i_op == OP_LDA ){
@


1.13
log
@added builtins mismatches(), mispairs() and paired().  Fixed bug that
was using the loopstk instead of the ifstk after and else.
@
text
@d184 1
d398 1
d409 3
d918 2
a919 2
	char	*cp;
	int	idx, pos, len;
d1002 8
d1012 1
d1096 70
d2069 4
d2115 1
a2115 1
		strcpy( name, "" );
@


1.12
log
@forgot to update the addinst() for RM_else() to use v_lab containing the label
value instead of the literal label number.
@
text
@d48 32
a79 31
#define	OP_STRF		6	/* Str. El. Reference	*/
#define	OP_LDA		7	/* Load Address		*/
#define	OP_LOD		8	/* Load Value		*/
#define	OP_LDC		9	/* Load Constant	*/
#define	OP_STO		10	/* Store top of stack	*/
#define	OP_AND		11	/* McCarthy And		*/
#define	OP_IOR		12	/* McCarthy Or		*/
#define	OP_NOT		13	/* Not			*/
#define	OP_MAT		14	/* Match		*/
#define	OP_INS		15	/* In Pairset		*/
#define	OP_GTR		16	/* Greater Than		*/
#define	OP_GEQ		17	/* Greater or Equal	*/
#define	OP_EQU		18	/* Equal		*/
#define	OP_NEQ		19	/* Not Equal		*/
#define	OP_LEQ		20	/* Less or Equal	*/
#define	OP_LES		21	/* Less Than		*/
#define	OP_ADD		22	/* Addition		*/
#define	OP_SUB		23	/* Subtraction		*/
#define	OP_MUL		24	/* Multiplication	*/
#define	OP_DIV		25	/* Division		*/
#define	OP_MOD		26	/* Modulus		*/
#define	OP_NEG		27	/* Negate		*/
#define	OP_PRST		28	/* Make a pairset	*/
#define	OP_BPR		29	/* Make a pair		*/
#define	OP_I_PP		30	/* use then incr (i++)	*/
#define	OP_PP_I		31	/* incr then use (++i)	*/
#define	OP_I_MM		32	/* use then decr (i--)	*/
#define	OP_MM_I		33	/* decr then use (--i)	*/
#define	OP_FJP		34	/* False Jump		*/
#define	OP_JMP		35	/* Jump			*/
#define	N_OP		36
d88 1
d121 15
d175 3
d180 1
d182 2
d256 1
a256 1
	v_lab.v_value.v_ival = loopstk[ loopstkp - 1 ];
d389 2
a390 37
	char	name[ 20 ];
	int	l_andor;
	VALUE_T	v_expr;

	if( np ){
		if( np->n_sym == SYM_CALL ){
			addinst( OP_MRK, NULL );
		}else if( np->n_sym == SYM_STREF ){
			fix_stref( np );
			v_expr.v_type = T_INT;
			v_expr.v_value.v_ival = np->n_left->n_sym;
		}else if( np->n_sym == SYM_LCURLY ){
			addinst( OP_MRK, NULL );
		}

		RM_expr( ISLVAL( np->n_sym ), np->n_left );

		if( ISRFLX( np->n_sym ) )
			RM_expr( 0, np->n_left );

		if( np->n_sym == SYM_OR || np->n_sym == SYM_AND ){
			l_andor = nextlab;
			nextlab++;
			addnode( lval, np, l_andor );
			RM_expr( 0, np->n_right );
			labtab[ l_andor ] = l_prog;
		}else{
			RM_expr( 0, np->n_right );
			addnode( lval, np, 0 );
		}

		if( np->n_sym == SYM_STREF ){
			addinst( OP_STRF, NULL );
		}else if( np->n_sym == SYM_LCURLY ){
			addinst( OP_PRST, NULL );
		}
	}
d463 1
a463 2
			sp = mp;
			mp = mem[ mp ].v_value.v_ival;
d469 3
d566 1
a566 1
			sp = mp;
d577 1
a577 1
dumpstk( stdout, "after op" );
d582 69
d849 1
a849 1
	v_expr.v_value.v_pval = "strid";
d855 38
d910 172
d1387 1
a1387 1
		v_top->v_value.v_ival = !( v_top->v_value.v_ival == 0 );
d1390 1
a1390 1
		v_top->v_value.v_ival = !( v_top->v_value.v_fval == 0.0 );
d1394 1
a1394 1
			!( *( char * )v_top->v_value.v_pval == '\0' );
d2039 1
d2045 6
a2050 1
		addinst( OP_FCL, &np->n_val );
d2298 1
d2357 2
d2379 1
a2379 1
	fprintf( fp, "%s\n", msg );
d2381 1
a2381 1
		fprintf( fp, "mem[%4d]: ", i );
d2387 1
a2387 1
			fprintf( fp, "I %d", vp->v_value.v_ival );
d2390 1
a2390 1
			fprintf( fp, "F %f", vp->v_value.v_fval );
@


1.11
log
@converted all literal errormsgs to RM_errormsg(). changed refs to node()
to RM_node().
@
text
@d232 3
a234 1
	addinst( OP_JMP, ifstk[ ifstkp - 1 ] + 1 );
@


1.10
log
@fixed mrk/cls to work properly for nested calls.
@
text
@d20 1
d25 1
a25 1
NODE_T	*node();
d135 22
a156 21
void	SC_if();
void	SC_else();
void	SC_endelse();
void	SC_endif();
void	SC_forinit();
void	SC_fortest();
void	SC_forincr();
void	SC_endfor();
void	SC_while();
void	SC_endwhile();
void	SC_break();
void	SC_continue();
void	SC_accept();
void	SC_reject();
void	SC_mark();
void	SC_clear();
void	SC_expr();
void	SC_node();
void	SC_dump();
void	SC_link();
int	SC_run();
d191 1
d196 1
a196 1
void	SC_action( np )
d200 2
a201 2
	SC_mark();
	SC_expr( 0, np );
d209 1
a209 1
void	SC_endaction()
d215 1
a215 1
void	SC_if( np )
d219 2
a220 2
	SC_mark();
	SC_expr( 0, np );
d229 1
a229 1
void	SC_else()
d236 1
a236 1
void	SC_endelse()
d243 1
a243 1
void	SC_endif()
d250 1
a250 1
void	SC_forinit( np )
d257 3
a259 3
	SC_mark();
	SC_expr( 0, np );
	SC_clear();
d262 1
a262 1
void	SC_fortest( np )
d267 2
a268 2
	SC_mark();
	SC_expr( 0, np );
d274 1
a274 1
void	SC_forincr( np )
d281 1
a281 1
void	SC_endfor()
d285 3
a287 3
	SC_mark();
	SC_expr( 0, loopincrstk[ loopstkp - 1 ] );
	SC_clear();
d295 1
a295 1
void	SC_while( np )
d303 2
a304 2
	SC_mark();
	SC_expr( 0, np );
d310 1
a310 1
void	SC_endwhile()
d320 1
a320 1
void	SC_break()
d328 1
a328 1
void	SC_continue()
d336 1
a336 1
void	SC_accept()
d342 1
a342 1
void	SC_reject()
d348 1
a348 1
void	SC_mark()
d354 1
a354 1
void	SC_clear()
d360 1
a360 1
void	SC_expr( lval, np )
d379 1
a379 1
		SC_expr( ISLVAL( np->n_sym ), np->n_left );
d382 1
a382 1
			SC_expr( 0, np->n_left );
d387 2
a388 2
			SC_node( lval, np, l_andor );
			SC_expr( 0, np->n_right );
d391 2
a392 2
			SC_expr( 0, np->n_right );
			SC_node( lval, np, 0 );
d403 1
a403 199
void	SC_node( lval, np, l_andor )
int	lval;
NODE_T	*np;
int	l_andor;
{
	POS_T	*posp;
	VALUE_T	v_node;

	switch( np->n_sym ){

	case SYM_CALL :
		addinst( OP_FCL, &np->n_val );
		break;
	case SYM_LIST :
		break;
	case SYM_STREF :
		break;

	case SYM_PARMS :
		break;
	case SYM_DESCR :
		break;
	case SYM_SITES :
		break;

	case SYM_SS :
	case SYM_H5 :
	case SYM_H3 :
	case SYM_P5 :
	case SYM_P3 :
	case SYM_T1 :
	case SYM_T2 :
	case SYM_T3 :
	case SYM_Q1 :
	case SYM_Q2 :
	case SYM_Q3 :
	case SYM_Q4 :
		break;

	case SYM_ELSE :
		break;
	case SYM_FOR :
		break;
	case SYM_IF :
		break;
	case SYM_WHILE :
		break;

	case SYM_IDENT :
		if( lval ){
			addinst( OP_LDA, &np->n_val );
		}else{
			addinst( OP_LOD, &np->n_val );
		}
		break;
	case SYM_INT :
		addinst( OP_LDC, &np->n_val );
		break;
	case SYM_FLOAT :
		addinst( OP_LDC, &np->n_val );
		break;
	case SYM_STRING :
		addinst( OP_LDC, &np->n_val );
		break;
	case SYM_DOLLAR :
		v_node.v_type = T_POS;
		v_node.v_value.v_pval = NULL;
		addinst( OP_LDC, &v_node );
		break;

	case SYM_ASSIGN :
		addinst( OP_STO, NULL );
		break;

	case SYM_PLUS_ASSIGN :
		addinst( OP_ADD, NULL );
		addinst( OP_STO, NULL );
		break;
	case SYM_MINUS_ASSIGN :
		addinst( OP_SUB, NULL );
		addinst( OP_STO, NULL );
		break;
	case SYM_PERCENT_ASSIGN :
		addinst( OP_MOD, NULL );
		addinst( OP_STO, NULL );
		break;
	case SYM_STAR_ASSIGN :
		addinst( OP_MUL, NULL );
		addinst( OP_STO, NULL );
		break;
	case SYM_SLASH_ASSIGN :
		addinst( OP_DIV, NULL );
		addinst( OP_STO, NULL );
		break;

	case SYM_AND :
		v_lab.v_type = T_INT;
		v_lab.v_value.v_ival = l_andor;
		addinst( OP_AND, &v_lab );
		break;
	case SYM_OR :
		v_lab.v_type = T_INT;
		v_lab.v_value.v_ival = l_andor;
		addinst( OP_IOR, &v_lab );
		break;
	case SYM_NOT :
		addinst( OP_NOT, NULL );
		break;

	case SYM_EQUAL :
		addinst( OP_EQU, NULL );
		break;
	case SYM_NOT_EQUAL :
		addinst( OP_NEQ, NULL );
		break;
	case SYM_GREATER :
		addinst( OP_GTR, NULL );
		break;
	case SYM_GREATER_EQUAL :
		addinst( OP_GEQ, NULL );
		break;
	case SYM_LESS :
		addinst( OP_LES, NULL );
		break;
	case SYM_LESS_EQUAL :
		addinst( OP_LEQ, NULL );
		break;

	case SYM_MATCH :
		addinst( OP_MAT, NULL );
		break;
	case SYM_DONT_MATCH :
		addinst( OP_MAT, NULL );
		addinst( OP_NOT, NULL );
		break;
	case SYM_IN :
		addinst( OP_INS, NULL );
		break;

	case SYM_PLUS :
		addinst( OP_ADD, NULL );
		break;
	case SYM_MINUS :
		addinst( OP_SUB, NULL );
		break;
	case SYM_PERCENT :
		addinst( OP_MOD, NULL );
		break;
	case SYM_STAR :
		addinst( OP_MUL, NULL );
		break;
	case SYM_SLASH :
		addinst( OP_DIV, NULL );
		break;
	case SYM_NEGATE :
		addinst( OP_NEG, NULL );
		break;

	case SYM_COLON :
		addinst( OP_BPR, NULL );
		break;

	case SYM_MINUS_MINUS :
		if( np->n_left ){
			addinst( OP_I_MM, NULL );
		}else{
			addinst( OP_MM_I, NULL );
		}
		break;
	case SYM_PLUS_PLUS :
		if( np->n_left ){
			addinst( OP_I_PP, NULL );
		}else{
			addinst( OP_PP_I, NULL );
		}
		break;

	case SYM_LPAREN :
		break;
	case SYM_RPAREN :
		break;
	case SYM_LCURLY :
		break;
	case SYM_RCURLY :
		break;
	case SYM_COMMA :
		break;
	case SYM_SEMICOLON :
		break;
	case SYM_ERROR :
		fprintf( stderr, "SYM_ERROR\n" );
		break;
	default :
		fprintf( stderr, "SC_node: Unknown symbol %d\n", np->n_sym );
		break;
	}
}

void	SC_link()
d419 1
a419 1
void	SC_dump( fp )
d431 1
a431 1
int	SC_run( sbuf )
d443 3
a445 3
			fprintf( stderr, "run: pc (%d) out of range 0..%d\n",
			pc, l_prog - 1 );
			exit( 1 );
d450 1
a450 1
fprintf( stdout, "SC_run, pc = %4d, op = %s\n", pc, opnames[ ip->i_op ] );
d580 2
a581 2
			fprintf( stderr, "run: unknown op %d\n", ip->i_op );
			exit( 1 );
d606 3
a608 4
					fprintf( stderr,
		"fix_stref: index parameter may not appear more than once.\n"
						);
					exit( 1 );
d613 3
a615 4
					fprintf( stderr,
		"fix_stref: tag parameter may not appear more than once.\n"
						);
					exit( 1 );
d620 3
a622 4
					fprintf( stderr,
		"fix_stref: pos parameter may not appear more than once.\n"
						);
					exit( 1 );
d627 3
a629 4
					fprintf( stderr,
		"fix_stref: len parameter may not appear more than once.\n"
						);
					exit( 1 );
d633 3
a635 2
				fprintf( stderr,
					"fix_stref: unknown parameter: '%s'\n",
d637 1
a637 1
				exit( 1 );
d642 1
d644 2
a645 3
		fprintf( stderr,
			"fix_stref: index = or tag = require for stref().\n" );
		exit( 1 );
d654 1
a654 1
		np3 = node( SYM_INT, &v_expr, 0, 0 );
d657 1
a657 1
	np2 = node( SYM_LIST, 0, np3, NULL );
d661 1
a661 1
		np3 = node( SYM_INT, &v_expr, 0, 0 );
d664 2
a665 2
	np2 = node( SYM_LIST, 0, np3, np2 );
	np1 = node( SYM_LIST, 0, np1, np2 );
d720 4
a723 3
			fprintf( stderr,
				"mk_call_strid: no such tag: '%s'.\n", v_tag );
			exit( 1 );
d726 1
d728 2
a729 2
				fprintf( stderr,
			"mk_call_strid: index must be between 1 and %d\n",
d731 1
a731 1
				exit( 1 );
d735 2
a736 2
				fprintf( stderr,
		"mk_call_strid: strel with index= %d has wrong type.\n",
d738 1
a738 1
				exit( 1 );
d742 3
a744 3
			fprintf( stderr,
"mk_call_strid: tag and index both have invalid values.\n" );
			exit( 1 );
d748 1
a748 1
			np1 = node( SYM_INT, &v_expr, 0, 0 );
d753 1
a753 1
			np1 = node( SYM_INT, &v_expr, 0, 0 );
d758 1
a758 1
			np1 = node( SYM_INT, &v_expr, 0, 0 );
d761 3
a763 3
			fprintf( stderr,
		"mk_call_strid: tag and index values are inconsistant.\n" );
			exit( 1 );
d770 1
a770 1
		n_tag = node( SYM_STRING, &v_expr, 0, 0 );
d772 1
a772 1
	np2 = node( SYM_LIST, 0, n_tag, NULL );
d777 1
a777 1
		n_index = node( SYM_INT, &v_expr, 0, 0 );
d780 1
a780 1
	np2 = node( SYM_LIST, 0, n_index, np2 );
d784 2
a785 2
	np3 = node( SYM_INT, &v_expr, 0, 0 );
	np2 = node( SYM_LIST, 0, np3, np2 );
d789 2
a790 2
	np3 = node( SYM_IDENT, &v_expr, 0, 0 );
	np1 = node( SYM_CALL, 0, np3, np2 );
d824 3
a826 2
		fprintf( stderr, "do_strf: no such descriptor %d.\n", index );
		exit( 1 );
d830 2
a831 2
		fprintf( stderr, "do_strf: pos must be > 0.\n" );
		exit( 1 );
d833 2
a834 1
		fprintf( stderr, "do_strf: pos must be <= %d.\n",
d836 1
a836 1
		exit( 1 );
d840 2
a841 2
		fprintf( stderr, "do_strf: len must be > 0.\n" );
		exit( 1 );
d848 2
a849 1
		fprintf( stderr, "do_strf: can't allocate cp.\n" );
d874 2
a875 1
		fprintf( stderr, "do_lda: variable '%s' is readonly.\n", 
d877 1
a877 1
		exit( 1 );
a878 3
/*
		v_top->v_type = idp->i_type;
*/
d895 2
a896 1
		fprintf( stderr, "do_lod: variable '%s' is undefined.\n",
d898 1
a898 1
		exit( 1 );
d902 3
a904 2
			fprintf( stderr,
				"do_lod: variable '%s' is undefined.\n",
d906 1
a906 1
			exit( 1 );
d920 2
a921 3
				fprintf( stderr,
					"do_lod: can't allocate cp.\n" );
				exit( 1 );
d958 2
a959 2
			fprintf( stderr, "do_ldc: can't allocate cp.\n" );
			exit( 1 );
d969 2
a970 2
		fprintf( stderr, "do_ldc: type mismatch.\n" );
		exit( 1 );
d1005 2
a1006 3
			fprintf( stderr,
				"do_sto: can't allocate new string.\n" );
			exit( 1 );
d1032 2
a1033 3
			fprintf( stderr,
				"do_sto: can't allocate new string.\n" );
			exit( 1 );
d1042 2
a1043 2
		fprintf( stderr, "do_sto: type mismatch.\n" );
		exit( 1 );
d1069 2
a1070 2
		fprintf( stderr, "do_and: type mismatch.\n" );
		exit( 1 );
d1098 2
a1099 2
		fprintf( stderr, "do_ior: type mismatch.\n" );
		exit( 1 );
d1126 2
a1127 2
		fprintf( stderr, "do_not: type mismatch.\n" );
		exit( 1 );
d1180 2
a1181 2
		fprintf( stderr, "do_gtr: type mismatch.\n" );
		exit( 1 );
d1224 2
a1225 1
		fprintf( stderr, "do_geq: type mismatch.\n" );
d1269 2
a1270 2
		fprintf( stderr, "do_equ: type mismatch.\n" );
		exit( 1 );
d1313 2
a1314 2
		fprintf( stderr, "do_neq: type mismatch.\n" );
		exit( 1 );
d1357 2
a1358 2
		fprintf( stderr, "do_leq: type mismatch.\n" );
		exit( 1 );
d1401 2
a1402 2
		fprintf( stderr, "do_les: type mismatch.\n" );
		exit( 1 );
d1440 2
a1441 2
		fprintf( stderr, "do_add: type mismatch.\n" );
		exit( 1 );
d1477 2
a1478 2
		fprintf( stderr, "do_sub: type mismatch.\n" );
		exit( 1 );
d1508 2
a1509 2
		fprintf( stderr, "do_mul: type mismatch.\n" );
		exit( 1 );
d1539 2
a1540 2
		fprintf( stderr, "do_div: type mismatch.\n" );
		exit( 1 );
d1561 2
a1562 2
		fprintf( stderr, "do_mod: type mismatch.\n" );
		exit( 1 );
d1583 2
a1584 2
		fprintf( stderr, "do_neg: type mismatch.\n" );
		exit( 1 );
d1611 2
a1612 1
		fprintf( stderr, "do_i_pp: variable '%s' is undefined.\n",
d1614 1
a1614 1
		exit( 1 );
d1620 2
a1621 2
		fprintf( stderr, "do_i_pp: type mismatch.\n" );
		exit( 1 );
d1638 2
a1639 1
		fprintf( stderr, "do_pp_i: variable '%s' is undefined.\n",
d1641 1
a1641 1
		exit( 1 );
d1647 2
a1648 2
		fprintf( stderr, "do_pp_i: type mismatch.\n" );
		exit( 1 );
d1665 2
a1666 1
		fprintf( stderr, "do_i_mm: variable '%s' is undefined.\n",
d1668 1
a1668 1
		exit( 1 );
d1674 2
a1675 1
		fprintf( stderr, "do_i_mm: type mismatch.\n" );
d1693 2
a1694 1
		fprintf( stderr, "do_mm_i: variable '%s' is undefined.\n",
d1696 1
a1696 1
		exit( 1 );
d1702 2
a1703 2
		fprintf( stderr, "do_mm_i: type mismatch.\n" );
		exit( 1 );
d1761 200
d1969 1
a1969 1
		errormsg( 1, "addinst: program size exceeded." );
d1987 2
a1988 3
					fprintf( stderr,
					"addinst: can't allocate sp.\n" );
					exit( 1 );
d2005 3
a2007 2
		fprintf( fp, "dumpinst: bad op %d\n", ip->i_op );
		exit( 1 );
@


1.9
log
@added 1st versions of strf & fcl.
@
text
@d662 3
d669 1
d1000 4
a1003 2
		mem[ sp ].v_type = T_INT;
		mem[ sp ].v_value.v_ival = len;
@


1.8
log
@redid strf instruction to accept three args: the d_index, the position
and the length.  -1 for length indicates from the position to the end
of the string.
@
text
@d8 2
d39 2
d626 2
a627 1
int	SC_run()
d634 1
d644 1
d647 1
d775 1
d777 1
d989 2
d992 7
d1004 5
d1010 34
d1065 1
d1067 2
d1168 1
a1173 1
	t_tm1 = v_tm1->v_type;
d1175 1
d1191 10
d1219 9
d1336 1
d1343 1
d1363 5
a1367 2
		v_tm1->v_value.v_ival =
			strcmp(v_tm1->v_value.v_pval,v_top->v_value.v_pval) > 0;
d1380 1
d1387 1
d1407 5
a1411 2
		v_tm1->v_value.v_ival =
			strcmp(v_tm1->v_value.v_pval,v_top->v_value.v_pval)>=0;
d1424 1
d1431 1
d1451 5
a1455 2
		v_tm1->v_value.v_ival =
			strcmp(v_tm1->v_value.v_pval,v_top->v_value.v_pval)==0;
d1468 1
d1475 1
d1495 5
a1499 2
		v_tm1->v_value.v_ival =
			strcmp(v_tm1->v_value.v_pval,v_top->v_value.v_pval)!=0;
d1512 1
d1519 1
d1539 5
a1543 2
		v_tm1->v_value.v_ival =
			strcmp(v_tm1->v_value.v_pval,v_top->v_value.v_pval)<=0;
d1556 1
d1563 1
d1583 5
a1587 2
		v_tm1->v_value.v_ival =
			strcmp(v_tm1->v_value.v_pval,v_top->v_value.v_pval) < 0;
a1794 1
	t_top = v_top->v_type;
d1796 1
@


1.7
log
@removed def of T_IJ() as it is now in rnamot.h being used also in
compile.c
@
text
@d18 2
d22 1
d152 2
d365 1
a367 1
			addinst( OP_STRF, &v_expr );
d407 1
a407 1
		addinst( OP_FCL, NULL );
d771 205
d1950 1
a1950 7
	if( ip->i_op == OP_STRF ){
		mk_stref_name( vp->v_value.v_ival, name );
		if( *name != '\0' )
			fprintf( fp, " opn (%s)", name );
		else
			fprintf( fp, " exec" );
	}else if( ip->i_op == OP_LDA ){
@


1.6
log
@added missing parm ip to call to do_ldc().
@
text
@a16 2
#define	T_IJ(i,j)	((i)*N_TYPE+(j))

@


1.5
log
@interpreter can do simple arithmetic including comparisons & booleans.
No string or other ( -> ) types yet.  No fcl, strf, mat, ins, bpr or
prst.   No builtins.
@
text
@d671 1
a671 1
			do_ldc();
@


1.4
log
@decided to use a threaded interp.  Have created stubs for all
non-trivial ops.
@
text
@d17 2
d20 2
d66 4
a69 4
#define	OP_INCP		30	/* use then incr (i++)	*/
#define	OP_PINC		31	/* incr then use (++i)	*/
#define	OP_DECP		32	/* use then decr (i--)	*/
#define	OP_PDEC		33	/* decr then use (--i)	*/
d176 4
a179 4
static	void	do_incp();
static	void	do_pinc();
static	void	do_decp();
static	void	do_pdec();
d184 1
a364 1
			mk_stref_name( np->n_left->n_sym, name );
d459 1
a459 1
		v_node.v_value.v_pval = "$";
d557 1
a557 1
			addinst( OP_DECP, NULL );
d559 1
a559 1
			addinst( OP_PDEC, NULL );
d564 1
a564 1
			addinst( OP_INCP, NULL );
d566 1
a566 1
			addinst( OP_PINC, NULL );
d600 3
d623 3
d634 4
d665 1
a665 1
			do_lda();
d668 1
a668 1
			do_lod();
d738 2
a739 2
		case OP_INCP :
			do_incp();
d741 2
a742 2
		case OP_PINC :
			do_pinc();
d744 2
a745 2
		case OP_DECP :
			do_decp();
d747 2
a748 2
		case OP_PDEC :
			do_pdec();
d752 1
a752 1
			if( mem[ sp ].v_value.v_ival )
d764 1
d780 2
a781 1
static	void	do_lda()
d783 2
d786 16
d804 2
a805 1
static	void	do_lod()
d807 3
d811 43
d856 2
a857 1
static	void	do_ldc()
d859 2
d862 30
d896 3
d900 47
d952 2
d955 21
d981 5
d987 18
d1009 5
d1015 16
d1045 2
d1048 32
d1084 2
d1087 32
d1123 2
d1126 32
d1162 2
d1165 32
d1201 2
d1204 32
d1240 2
d1243 32
d1288 2
a1289 2
	switch( t_tm1 * N_TYPE + t_top ){
	case T_INT * N_TYPE + T_INT :
d1292 1
a1292 1
	case T_INT * N_TYPE + T_FLOAT :
d1295 3
a1297 1
	case T_FLOAT * N_TYPE + T_INT :
d1300 1
a1300 1
	case T_FLOAT * N_TYPE + T_FLOAT :
d1303 1
a1303 3
	case T_STRING * N_TYPE + T_STRING :
		break;
	case T_PAIR * N_TYPE + T_PAIR :
d1305 1
a1305 1
	case T_INT * N_TYPE + T_POS :
d1307 1
a1307 1
	case T_POS * N_TYPE + T_INT :
d1327 2
a1328 2
	switch( t_tm1 * N_TYPE + t_top ){
	case T_INT * N_TYPE + T_INT :
d1331 1
a1331 1
	case T_INT * N_TYPE + T_FLOAT :
d1334 3
a1336 1
	case T_FLOAT * N_TYPE + T_INT :
d1339 1
a1339 1
	case T_FLOAT * N_TYPE + T_FLOAT :
d1342 1
a1342 3
	case T_PAIR * N_TYPE + T_PAIR :
		break;
	case T_INT * N_TYPE + T_POS :
d1344 1
a1344 1
	case T_POS * N_TYPE + T_INT :
d1364 2
a1365 2
	switch( t_tm1 * N_TYPE + t_top ){
	case T_INT * N_TYPE + T_INT :
d1368 1
a1368 1
	case T_INT * N_TYPE + T_FLOAT :
d1371 1
a1371 1
	case T_FLOAT * N_TYPE + T_INT :
d1374 1
a1374 1
	case T_FLOAT * N_TYPE + T_FLOAT :
d1395 2
a1396 2
	switch( t_tm1 * N_TYPE + t_top ){
	case T_INT * N_TYPE + T_INT :
d1399 1
a1399 1
	case T_INT * N_TYPE + T_FLOAT :
d1402 1
a1402 1
	case T_FLOAT * N_TYPE + T_INT :
d1405 1
a1405 1
	case T_FLOAT * N_TYPE + T_FLOAT :
d1426 2
a1427 2
	switch( t_tm1 * N_TYPE + t_top ){
	case T_INT * N_TYPE + T_INT :
d1469 1
a1469 1
static	void	do_incp()
d1471 3
d1475 18
d1495 1
a1495 1
static	void	do_pinc()
d1497 3
d1501 18
d1521 1
a1521 1
static	void	do_decp()
d1523 3
d1527 18
d1547 1
a1547 1
static	void	do_pdec()
d1549 3
d1553 18
d1619 4
d1731 4
a1734 4
	case OP_INCP :
	case OP_PINC :
	case OP_DECP :
	case OP_PDEC :
d1742 10
a1751 7
	if( vp->v_type == T_INT ){
		if( ip->i_op != OP_STRF )
			fprintf( fp, " %d", vp->v_value.v_ival );
		else{
			mk_stref_name( vp->v_value.v_ival, name );
			fprintf( fp, " %s", name );
		}
d1756 2
d1761 40
@


1.3
log
@operations compiled into prog.  Loops resolved.
@
text
@a16 2
#define	CFP	stdout

d21 1
a21 1
static	int	nextlab = 1;
a124 2
void	SC_link();
void	SC_dump();
d143 34
a180 25
void	SC_link()
{
	int	i;
	INST_T	*ip;

	for( ip = prog, i = 0; i < l_prog; i++, ip++ ){
		if( ip->i_op == OP_FJP || ip->i_op == OP_JMP ){
			ip->i_val.v_value.v_ival =
				labtab[ ip->i_val.v_value.v_ival ];
		}
	}
}

void	SC_dump( fp )
FILE	*fp;
{
	INST_T	*ip;
	int	i;

	fprintf( fp, "SCORE: %4d inst.\n", l_prog );
	for( ip = prog, i = 0; i < l_prog; i++, ip++ ){
		dumpinst( fp, i, ip );
	}
}

a191 2

	fprintf( CFP, "  fjp L%d\n", actlab );
a197 2

	fprintf( CFP, "L%d:\n", actlab );
a211 2

	fprintf( CFP, "  fjp L%d\n", ifstk[ ifstkp - 1 ] );
a218 3

	fprintf( CFP, "  jmp L%d\n", ifstk[ ifstkp - 1 ] + 1 );
	fprintf( CFP, "L%d:\n", ifstk[ ifstkp - 1 ] );
a224 3

	fprintf( CFP, "L%d:\n", ifstk[ ifstkp - 1 ] + 1 );

a231 3

	fprintf( CFP, "L%d:\n", ifstk[ ifstkp - 1 ] );

a251 3

	fprintf( CFP, "L%d:\n", loopstk[ loopstkp - 1 ] );

a256 2

	fprintf( CFP, "  fjp L%d\n", loopstk[ loopstkp - 1 ] + 2 );
a269 3

	fprintf( CFP, "L%d:\n", loopstk[ loopstkp - 1 ] + 1 );

a276 4

	fprintf( CFP, "  jmp L%d\n", loopstk[ loopstkp - 1 ] );
	fprintf( CFP, "L%d:\n", loopstk[ loopstkp - 1 ] + 2 );

a287 3

	fprintf( CFP, "L%d:\n", loopstk[ loopstkp - 1 ] );

a292 1
	fprintf( CFP, "  fjp L%d\n", loopstk[ loopstkp - 1 ] + 2 );
a301 4

	fprintf( CFP, "  jmp L%d\n", loopstk[ loopstkp - 1 ] );
	fprintf( CFP, "L%d:\n", loopstk[ loopstkp - 1 ] + 2 );

a310 1
	fprintf( CFP, "  jmp L%d\n", loopstk[ loopstkp - 1 ] + 1 );
a318 1
	fprintf( CFP, "  jmp L%d\n", loopstk[ loopstkp - 1 ] );
a324 1
	fprintf( CFP, "  acpt\n" );
a330 1
	fprintf( CFP, "  rjct\n" );
a336 1
	fprintf( CFP, "  mrk\n" );
a342 1
	fprintf( CFP, "  clr\n" );
a355 1
			fprintf( CFP, "  mrk\n" );
a360 1
			fprintf( CFP, "  strf %s\n", name );
a362 1
			fprintf( CFP, "  mrk\n" );
a375 3

			fprintf( CFP, "L%d:\n", l_andor );

a382 1
			fprintf( CFP, "  strf cls\n" );
a384 1
			fprintf( CFP, "  prst\n" );
a400 1
		fprintf( CFP, "  fcl %s\n", np->n_val.v_value.v_pval );
a439 1
			fprintf( CFP, "  lda %s\n", np->n_val.v_value.v_pval );
a441 1
			fprintf( CFP, "  lod %s\n", np->n_val.v_value.v_pval );
a445 1
		fprintf( CFP, "  ldc %d\n", np->n_val.v_value.v_ival );
a448 1
		fprintf( CFP, "  ldcR\n" );
a451 1
		fprintf( CFP, "  ldc \"%s\"\n", np->n_val.v_value.v_pval );
d454 3
a456 2
		addinst( OP_LDC, NULL );
		fprintf( CFP, "  lod $\n" );
a460 1
		fprintf( CFP, "  sto\n" );
a465 2
		fprintf( CFP, "  add\n" );
		fprintf( CFP, "  sto\n" );
a469 2
		fprintf( CFP, "  sub\n" );
		fprintf( CFP, "  sto\n" );
a473 2
		fprintf( CFP, "  mod\n" );
		fprintf( CFP, "  sto\n" );
a477 2
		fprintf( CFP, "  mul\n" );
		fprintf( CFP, "  sto\n" );
a481 2
		fprintf( CFP, "  div\n" );
		fprintf( CFP, "  sto\n" );
a487 1
		fprintf( CFP, "  and L%d\n", l_andor );
a492 1
		fprintf( CFP, "  ior L%d\n", l_andor );
a495 1
		fprintf( CFP, "  not\n" );
a499 1
		fprintf( CFP, "  equ\n" );
a502 1
		fprintf( CFP, "  neq\n" );
a505 1
		fprintf( CFP, "  gtr\n" );
a508 1
		fprintf( CFP, "  geq\n" );
a511 1
		fprintf( CFP, "  les\n" );
a514 1
		fprintf( CFP, "  leq\n" );
a518 1
		fprintf( CFP, "  mat\n" );
a522 2
		fprintf( CFP, "  mat\n" );
		fprintf( CFP, "  not\n" );
a525 1
		fprintf( CFP, "  ins\n" );
a529 1
		fprintf( CFP, "  add\n" );
a532 1
		fprintf( CFP, "  sub\n" );
a535 1
		fprintf( CFP, "  mod\n" );
a538 1
		fprintf( CFP, "  mul\n" );
a541 1
		fprintf( CFP, "  div\n" );
a544 1
		fprintf( CFP, "  neg\n" );
a548 1
		fprintf( CFP, "  bpr\n" );
a553 1
			fprintf( CFP, "  decp\n" );
a555 1
			fprintf( CFP, "  pdec\n" );
a560 1
			fprintf( CFP, "  incp\n" );
a562 1
			fprintf( CFP, "  pinc\n" );
d579 1
a579 1
		fprintf( CFP, "SYM_ERROR\n" );
d584 7
d592 5
d600 454
d1140 1
a1140 1
void	dumpinst( fp, i, ip )
d1152 2
a1153 1
	fprintf( fp, "prog[%5d]:  %s", i, opnames[ ip->i_op ] );
d1228 3
a1230 1
	else if( vp->v_type == T_STRING || vp->v_type == T_IDENT )
@


1.2
log
@added break/continue code.  Allocate 3 labels for while/for.
@
text
@d2 2
d21 2
a23 1

d25 1
d34 95
d148 7
d156 20
d184 4
d194 2
d208 4
d218 3
d228 2
d231 1
d238 2
d241 1
d261 2
d264 1
d267 4
d284 2
d287 1
d291 5
d298 1
d309 2
d312 1
d315 3
d324 5
d331 1
d338 3
d347 3
d356 2
a357 1
	fprintf( CFP, "  ACCEPT\n" );
d363 2
a364 1
	fprintf( CFP, "  REJECT\n" );
d370 1
d377 1
d386 2
d390 2
a391 1
		if( np->n_sym == SYM_CALL )
d393 4
a396 1
		else if( np->n_sym == SYM_STREF ){
d399 2
a400 1
		}else if( np->n_sym == SYM_LCURLY )
d402 2
d405 1
d408 15
a422 2
		SC_expr( 0, np->n_right );
		SC_node( lval, np );
d424 1
d426 2
a427 1
		}else if( np->n_sym == SYM_LCURLY )
d429 1
d433 1
a433 1
void	SC_node( lval, np )
d436 1
d439 1
d444 1
a451 4
	case SYM_FLOAT :
		fprintf( CFP, "  ldcR\n" );
		break;

a478 3
	case SYM_IN :
		fprintf( CFP, "  ins\n" );
		break;
d481 1
d483 2
a484 1
		if( lval )
d486 2
a487 1
		else
d489 1
d492 1
d495 4
d500 1
d503 3
a505 2
	case SYM_AND :
		fprintf( CFP, "  and\n" );
d507 1
d509 1
d512 1
d514 2
d520 2
d525 17
a541 2
	case SYM_PLUS :
		fprintf( CFP, "  add\n" );
d543 6
a548 2
	case SYM_MINUS :
		fprintf( CFP, "  sub\n" );
d550 5
a554 2
	case SYM_DOLLAR :
		fprintf( CFP, "  lod $\n" );
d556 3
a558 1
	case SYM_DONT_MATCH :
d560 1
d562 1
d565 4
d570 1
d574 1
d578 1
d582 1
d585 1
d587 1
d590 5
a594 5
	case SYM_MINUS_MINUS :
		if( np->n_left )
			fprintf( CFP, "  dcp\n" );
		else
			fprintf( CFP, "  pdc\n" );
d596 3
a598 2
	case SYM_NEGATE :
		fprintf( CFP, "  neg\n" );
d600 4
a603 2
	case SYM_NOT :
		fprintf( CFP, "  not\n" );
d605 3
a607 5
	case SYM_NOT_EQUAL :
		fprintf( CFP, "  neq\n" );
		break;
	case SYM_OR :
		fprintf( CFP, "  ior\n" );
d610 1
a612 10
	case SYM_PERCENT_ASSIGN :
		fprintf( CFP, "  mod\n" );
		fprintf( CFP, "  sto\n" );
		break;
	case SYM_PLUS_PLUS :
		if( np->n_left )
			fprintf( CFP, "  icp\n" );
		else
			fprintf( CFP, "  pic\n" );
		break;
d614 1
a616 4
	case SYM_STAR_ASSIGN :
		fprintf( CFP, "  mul\n" );
		fprintf( CFP, "  sto\n" );
		break;
d618 1
d621 27
a647 3
	case SYM_SLASH_ASSIGN :
		fprintf( CFP, "  div\n" );
		fprintf( CFP, "  sto\n" );
d649 1
a657 3
	case SYM_COLON :
		fprintf( CFP, "  bpr\n" );
		break;
d719 129
@


1.1
log
@Initial revision
@
text
@d26 3
a28 6
static	int	forstk[ 100 ];
static	NODE_T	*forincrstk[ 100 ];
static	int	forstkp = 0;

static	int	whilestk[ 100 ];
static	int	whilestkp = 0;
d40 2
d104 3
a106 3
	forstk[ forstkp ] = nextlab;
	forstkp++;
	nextlab += 2;
d116 1
a116 1
	fprintf( CFP, "L%d:\n", forstk[ forstkp - 1 ] );
d119 1
a119 1
	fprintf( CFP, "  fjp L%d\n", forstk[ forstkp - 1 ] + 1 );
d126 1
a126 1
	forincrstk[ forstkp - 1 ] = np;
d132 1
d134 1
a134 1
	SC_expr( 0, forincrstk[ forstkp - 1 ] );
d136 3
a138 3
	fprintf( CFP, "  jmp L%d\n", forstk[ forstkp - 1 ] );
	fprintf( CFP, "L%d:\n", forstk[ forstkp - 1 ] + 1 );
	forstkp--;
d145 4
a148 4
	whilestk[ whilestkp ] = nextlab;
	whilestkp++;
	nextlab += 2;
	fprintf( CFP, "L%d:\n", whilestk[ whilestkp - 1 ] );
d151 1
a151 1
	fprintf( CFP, "  fjp L%d\n", whilestk[ whilestkp - 1 ] + 1 );
d157 15
a171 3
	fprintf( CFP, "  jmp L%d\n", whilestk[ whilestkp - 1 ] );
	fprintf( CFP, "L%d:\n", whilestk[ whilestkp - 1 ] + 1 );
	whilestkp--;
@
