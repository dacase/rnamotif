head	1.10;
access;
symbols;
locks; strict;
comment	@ * @;


1.10
date	2003.07.27.22.42.52;	author macke;	state Exp;
branches;
next	1.9;

1.9
date	2003.02.24.04.04.02;	author macke;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.12.19.01.33;	author macke;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.23.02.16.26;	author macke;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.14.18.42.08;	author macke;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.12.19.47.48;	author macke;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.11.17.51.10;	author macke;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.11.17.46.12;	author macke;	state Exp;
branches;
next	1.2;

1.2
date	2001.11.14.17.31.26;	author macke;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.24.17.11.40;	author macke;	state Exp;
branches;
next	;


desc
@replaces fastn.c with new set of routines that cover fastn and pir
format with genbank ff on the way.
@


1.10
log
@added code to insure that extrememly large files that cause the 32
bit signed ints to overflow and then because they're negative will no
longer cause buffer overflows
@
text
@#include <stdio.h>
#include <ctype.h>
#include <string.h>

#include "rmdefs.h"
#include "dbutil.h"

#define	MAXCNT	0x7fffffff

static	int	skipbl2nl( FILE * );

FILE	*DB_fnext( FILE *fp, int *c_fname, int n_fname, char *fname[] )
{

	/* Initial state is NULL; called w/stdin means we're done.	*/
	if( fp == stdin )
		return( NULL );
	else if( fp != NULL )
		fclose( fp );

	if( n_fname == 0 )
		return( stdin );
	else if( *c_fname == UNDEF ){
		*c_fname = 0;
		if( ( fp = fopen( fname[ *c_fname ], "r" ) ) == NULL ){
			fprintf( stderr,
				"DB_fnext: can't read seq file '%s'.\n",
				fname[ *c_fname ] );
		}
	}else if( *c_fname < n_fname - 1 ){
		( *c_fname )++;
		if( ( fp = fopen( fname[ *c_fname ], "r" ) ) == NULL ){
			fprintf( stderr,
				"DB_fnext: can't read seq file '%s'.\n",
				fname[ *c_fname ] );
		}
	}else
		fp = NULL;
	return( fp );
}

int	FN_fgetseq( FILE *fp, char sid[], int s_sdef, char sdef[],
	int	s_sbuf, char sbuf[] )
{
	int	c;
	unsigned int	cnt;
	int	ovfl;
	char	*dp, *sp;

	*sid = '\0';
	*sdef = '\0';
	*sbuf = '\0';

	if( ( c = getc( fp ) ) == EOF )
		return( EOF );
	else if( c != '>' ){
		fprintf( stderr,
			"FN_fgetseq: fastn file does not begin with '>'.\n" );
		return( EOF );
	}

	if( ( c = skipbl2nl( fp ) ) == EOF || c == '\n' ){
		fprintf( stderr,
			"FN_fgetseq: fastn file has an unnamed entry.\n" );
		return( EOF );
	}

	dp = sid;
	for( *dp++ = c; ( c = getc( fp ) ) != EOF; ){
		if( !isspace( c ) )
			*dp++ = c;
		else
			break;
	}
	*dp = '\0';
	if( c == EOF )
		return( 0 );
	if( c != '\n' ){
		if( ( c = skipbl2nl( fp ) ) == EOF )
			return( 0 );
	}
	if( c != '\n' ){
		dp = sdef;
		for( cnt = 1, *dp++ = c; c = getc( fp ); ){
			if( c == '\n' || c == EOF )
				break;
			cnt++;
			if( cnt < s_sdef )
				*dp++ = c;
		}
		*dp = '\0';
		if( cnt >= s_sdef ){
			fprintf( stderr,
		"FN_fgetseq: entry: '%s': def len: %d, truncated to %d.\n",
				sid, cnt, s_sdef - 1 );
		}
	}
	if( c == EOF )
		return( 0 );

	for( ovfl = 0, cnt = 0, sp = sbuf; ( c = getc( fp ) ) != EOF; ){
		if( c == '>' ){
			ungetc( c, fp );
			break;
		}else if( isalpha( c ) ){
			if( cnt < MAXCNT ){
				cnt++;
				if( cnt < s_sbuf ){
					c = tolower( c );
					*sp++ = c == 'u' ? 't' : c;
				}
			}else
				ovfl = 1;
		}
	}
	*sp = '\0';
	if( ovfl ){
		fprintf( stderr,
	"FN_fgetseq: entry: '%s': seq len > 2^31-1 (%d), truncated to %d.\n",
			sid, MAXCNT, s_sbuf - 1 );
	}else if( cnt > s_sbuf ){
		fprintf( stderr,
		"FN_fgetseq: entry: '%s': seq len: %d, truncated to %d.\n",
			sid, cnt, s_sbuf - 1 );
	}

	return( sp - sbuf );
}

int	PIR_fgetseq( FILE *fp, char sid[], int s_sdef, char sdef[],
	int	s_sbuf, char sbuf[] )
{
	int	c;
	unsigned int	cnt;
	int	ovfl;
	char	*dp, *sp;

	*sid = '\0';
	*sdef = '\0';
	*sbuf = '\0';

	if( ( c = getc( fp ) ) == EOF )
		return( EOF );
	else if( c != '>' ){
		fprintf( stderr,
			"PIR_fgetseq: pir file does not begin with '>'.\n" );
		return( EOF );
	}

	if( ( c = skipbl2nl( fp ) ) == EOF || c == '\n' ){
		fprintf( stderr,
			"PIR_fgetseq: pir file has an unnamed entry.\n" );
		return( EOF );
	}

	dp = sid;
	for( *dp++ = c; ( c = getc( fp ) ) != EOF; ){
		if( !isspace( c ) )
			*dp++ = c;
		else
			break;
	}
	*dp = '\0';
	if( c == EOF ){
		fprintf( stderr,
			"PIR_fgetseq: entry: '%s': no title line.\n", sid );
		return( EOF );
	}else if( c != '\n' ){
		fprintf( stderr,
		"PIR_fgetseq: entry: '%s': extra chars on ID line ignored.\n",
			sid );
		while( ( c = getc( fp ) ) != EOF ){
			if( c == '\n' )
				break;
		}
	}
	if( c != '\n' ){
		fprintf( stderr,
			"PIR_fgetseq: entry: '%s': no title line.\n", sid );
		return( EOF );
	}else
		c = getc( fp );
	dp = sdef;
	for( cnt = 1, *dp++ = c; c = getc( fp ); ){
		if( c == '\n' || c == EOF )
			break;
		cnt++;
		if( cnt < s_sdef )
			*dp++ = c;
	}
	*dp = '\0';
	if( cnt >= s_sdef ){
		fprintf( stderr,
	"PIR_fgetseq: entry: '%s': title len: %d, truncated to %d.\n",
			sid, cnt, s_sdef - 1 );
	}

	for( ovfl = 0, cnt = 0, sp = sbuf; ( c = getc( fp ) ) != EOF; ){
		if( c == '>' ){
			ungetc( c, fp );
			break;
		}else if( isalpha( c ) ){
			if( cnt < MAXCNT ){
				cnt++;
				if( cnt < s_sbuf ){
					c = tolower( c );
					*sp++ = c == 'u' ? 't' : c;
				}
			}else
				ovfl = 1;
		}
	}
	*sp = '\0';
	if( ovfl ){
		fprintf( stderr,
	"PIR_fgetseq: entry: '%s': seq len > 2^31-1 (%d), truncated to %d.\n",
			sid, MAXCNT, s_sbuf - 1 );
	}else if( cnt > s_sbuf ){
		fprintf( stderr,
		"PIR_fgetseq: entry: '%s': seq len: %d, truncated to %d.\n",
			sid, cnt, s_sbuf - 1 );
	}

	return( sp - sbuf );
}
int	GB_fgetseq( FILE *fp, char sid[], int s_sdef, char sdef[],
	int	s_sbuf, char sbuf[] )
{
	unsigned int	cnt;
	int	ovfl;
	char	line[ 256 ], locus[ 20 ], acc[ 20 ], gid[ 20 ];
	char	*lp, *dp, *sp;

	*sid = '\0';
	*sdef = '\0';
	*sbuf = '\0';

	for( *locus = '\0'; fgets( line, sizeof( line ), fp ); ){
		if( !strncmp( line, "LOCUS", 5 ) ){
			sscanf( line, "LOCUS %s", locus );
			break;
		}
	}
	if( *locus == '\0' )
		return( EOF );

	while( fgets( line, sizeof( line ), fp ) ){
		if( !strncmp( line, "DEFINITION", 10 ) ){
			for( dp = sdef, cnt = 0, lp = line; *lp; lp++ ){
				cnt++;
				if( cnt < s_sdef )
					*dp++ = *lp == '\n' ? ' ' : *lp;
			}
			*dp = '\0';
		}else if( !strncmp( line, "ACCESSION", 9 ) ){
			dp[ -1 ] = '\0';
			break;
		}else{
			for( lp = line; *lp; lp++ ){
				cnt++;
				if( cnt < s_sdef )
					*dp++ = *lp == '\n' ? ' ' : *lp;
			}
			*dp = '\0';
		}
	}
	if( *sdef == '\0' ){
		fprintf( stderr, "GB_fgetseq: missing DEFINITION line.\n" );
		return( EOF );
	}
	if( cnt >= s_sdef ){
		fprintf( stderr,
		"GB_fgetseq: entry: '%s': def len: %d, truncated to %d.\n",
			sid, cnt, s_sdef - 1 );
	}

	for( *acc = *gid = '\0'; fgets( line, sizeof( line ), fp ); ){
		if( !strncmp( line, "VERSION", 7 ) ){
			sscanf( line, "VERSION %s GI:%s", acc, gid );
			break;
		}
	}
	if( *acc == '\0' ){
		fprintf( stderr, "GB_fgetseq: missing VERSION line.\n" );
		return( EOF );
	}
	if( dp = strchr( acc, '.' ) )
		*dp = '\0';
	sprintf( sid, "gi|%s|gb|%s|%s", gid, acc, locus );

	while( fgets( line, sizeof( line ), fp ) ){
		if( !strncmp( line, "ORIGIN", 6 ) ){
			break;
		}
	}
	if( strncmp( line, "ORIGIN", 6 ) ){
		fprintf( stderr, "GB_fgetseq: missing ORIGIN line.\n" );
		return( EOF );
	}

	for( sp = sbuf, ovfl = 0, cnt = 0; fgets( line, sizeof( line ), fp ); ){
		if( !strncmp( line, "//", 2 ) )
			break;
		for( lp = line; *lp; lp++ ){
			if( isalpha( *lp ) ){
				if( cnt < MAXCNT ){
					cnt++;
					if( cnt < s_sbuf ){
						*sp++ = isupper( *lp ) ?
							tolower( *lp ) : *lp;
					}
				}else
					ovfl = 1;
			}
		}
		*sp = '\0';
	}
	if( strncmp( line, "//", 2 ) ){
		fprintf( stderr, "GB_fgetseq: missing // line.\n" );
		return( EOF );
	}
	if( ovfl ){
		fprintf( stderr,
	"GB_fgetseq: entry: '%s': seq len > 2^31-1 (%d), truncated to %d.\n",
			sid, MAXCNT, s_sbuf - 1 );
	}else if( cnt > s_sbuf ){
		fprintf( stderr,
		"GB_fgetseq: entry: '%s': seq len: %d, truncated to %d.\n",
			sid, cnt, s_sbuf - 1 );
	}

	return( sp - sbuf );
}

static	int	skipbl2nl( FILE *fp )
{
	int	c;

	while( isspace( c = getc( fp ) ) )
		if( c == '\n' )
			break;
	return( c );
}
@


1.9
log
@moved decls to dbutil.h
@
text
@d8 2
a14 4
/*
	if( fp != NULL && fp != stdin )
		fclose( fp );
*/
d45 3
a47 1
	int	c, cnt;
d101 1
a101 1
	for( cnt = 0, sp = sbuf; ( c = getc( fp ) ) != EOF; ){
d106 8
a113 5
			cnt++;
			if( cnt < s_sbuf ){
				c = tolower( c );
				*sp++ = c == 'u' ? 't' : c;
			}
d117 5
a121 1
	if( cnt > s_sbuf ){
d133 3
a135 1
	int	c, cnt;
d198 1
a198 1
	for( cnt = 0, sp = sbuf; ( c = getc( fp ) ) != EOF; ){
d203 8
a210 5
			cnt++;
			if( cnt < s_sbuf ){
				c = tolower( c );
				*sp++ = c == 'u' ? 't' : c;
			}
d214 5
a218 1
	if( cnt > s_sbuf ){
d229 2
a230 1
	int	cnt;
d301 1
a301 1
	for( sp = sbuf, cnt = 0; fgets( line, sizeof( line ), fp ); ){
d306 8
a313 5
				cnt++;
				if( cnt < s_sbuf ){
					*sp++ = isupper( *lp ) ?
						tolower( *lp ) : *lp;
				}
d321 9
@


1.8
log
@fixed bug that inadvertantly ate the next (seq) line if a fastn
def line was > id (space) -- ie no def, but trailing spaces after the id.
@
text
@d6 1
@


1.7
log
@removed include of rnamot.h as it was no longer needed as the file type
defs are in rmdefs.h
@
text
@d80 2
@


1.6
log
@moved UNDEF from rnamot.h to rmdefs.h
@
text
@a5 1
#include "rnamot.h"
@


1.5
log
@removed message that announce no LOCUS line as it was being called for
normal EOF.
@
text
@d5 1
@


1.4
log
@removed unused var from GB_fgetseq()
@
text
@d224 1
a224 2
	if( *locus == '\0' ){
		fprintf( stderr, "GB_fgetseq: missing LOCUS line.\n" );
a225 1
	}
@


1.3
log
@added GB_fgetseq() which can read GB flat files.
@
text
@d210 1
a210 1
	int	c, cnt;
@


1.2
log
@fixed flaw in DB_fnext() that cause infinite loop if the DB file was
stdin.
@
text
@d207 97
@


1.1
log
@Initial revision
@
text
@d12 1
d14 6
@
