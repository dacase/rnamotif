head	1.2;
access;
symbols;
locks; strict;
comment	@// @;


1.2
date	2000.09.15.19.56.55;	author macke;	state Exp;
branches;
next	1.1;

1.1
date	2000.09.14.21.55.02;	author macke;	state Exp;
branches;
next	;


desc
@@


1.2
log
@at least readably indented.
@
text
@#if !defined(STRUCTURE_CPP)
#define STRUCTURE_CPP

#include "structure.h"

//	code for Structures:


datatable::datatable()
{
	int a,b,c,d,e,f,g,h;

	for (a=0;a<=5;a++) {
	    for (b=0;b<=5;b++) {
		for (c=0;c<=5;c++) {
		    for (d=0;d<=5;d++) {
			for (e=0;e<=5;e++) {
			    for (f=0;f<=5;f++) {
				iloop11[a][b][c][d][e][f] = 0;
				for (g=0;g<=5;g++) {
				    iloop21[a][b][c][d][e][f][g] = infinity;
		 		    for (h=0;h<=5;h++) {
				    	iloop22[a][b][c][d][e][f][g][h] =
					    infinity;
		 		    }
				}
			    }
			}
		    }
		}
	    }
	}
};

structure::structure()
{
	int i;
	for (i=1;i<=maxstructures;i++) {
		energy[i]=0;
		allocated = false;
	}
	nnopair=0;
	npair=0;
	ndbl=0;
	intermolecular = false;
	ngu = 0;
	templated = false;
}

structure::~structure()
{
	int i;

	if (allocated) {
		delete[] numseq;
   		for (i=0;i<=maxstructures;i++) {
    			delete[] basepr[i];
   		}

   		delete[] basepr;
		delete[] hnumber;
		delete[] nucs;
	}
	if (templated) {
		for (i=0;i<=numofbases;i++) {
    			delete[] tem[i];
   		}

		delete[] tem;
	}
}

void structure::allocate(int size)
{
	int i;
	// Size = size;
	// save the size of the array so that the destructor can
	// deallocate the space
	numseq = new int [2*size+1];
	hnumber = new int [size+1];
	nucs = new char [size+2];
	basepr = new int *[maxstructures+1];
	for (i=0;i<=maxstructures;i++) {
    		basepr[i] = new int [size+1];
	}
	allocated = true;
}

// allocate space in an array that is used for folding with phylogenetic data
void structure::allocatetem()
{
	int i;
	// Size = size;
	// save the size of the array so that the destructor can
	// deallocate the space

	tem = new bool *[numofbases+1];
	for (i=0;i<=numofbases;i++) {
    		tem[i] = new bool [i+1];
	}
	templated = true;
}

#endif
@


1.1
log
@Initial revision
@
text
@d6 1
a8 3
//***********************************code for Structures:


d11 1
a11 3
int a,b,c,d,e,f,g,h;


d13 2
a14 5



for (a=0;a<=5;a++) {
	for (b=0;b<=5;b++) {
d16 10
a25 11
			for (d=0;d<=5;d++) {
				for (e=0;e<=5;e++) {
					for (f=0;f<=5;f++) {
               	iloop11[a][b][c][d][e][f] = 0;
						for (g=0;g<=5;g++) {
			iloop21[a][b][c][d][e][f][g] = infinity;
         for (h=0;h<=5;h++) {
          	iloop22[a][b][c][d][e][f][g][h] = infinity;
         }
						}
					}
d27 1
d29 1
d31 1
a32 9
}








a34 2


d40 1
a40 1
   allocated = false;
d45 3
a47 3
   intermolecular = false;
   ngu = 0;
   templated = false;
d54 1
a54 1
   if (allocated) {
d56 9
a64 9
   	for (i=0;i<=maxstructures;i++) {
    		delete[] basepr[i];
   	}

   	delete[] basepr;
      delete[] hnumber;
      delete[] nucs;
   }
   if (templated) {
d66 2
a67 2
    		delete[] tem[i];
   	}
d69 2
a70 3
   	delete[] tem;
   }

a72 2


a73 1

d76 11
a86 11
	//Size = size;//save the size of the array so that the destructor can
   				//deallocate the space
   numseq = new int [2*size+1];
   hnumber = new int [size+1];
   nucs = new char [size+2];
   basepr = new int *[maxstructures+1];
   for (i=0;i<=maxstructures;i++) {
    	basepr[i] = new int [size+1];
   }
   allocated = true;

d89 1
a89 2

//this allocates space in an array that is used for folding with phylogenetic data
a90 1

d93 9
a101 9
	//Size = size;//save the size of the array so that the destructor can
   				//deallocate the space

   tem = new bool *[numofbases+1];
   for (i=0;i<=numofbases;i++) {
    	tem[i] = new bool [i+1];
   }
   templated = true;

@
