head	1.2;
access;
symbols;
locks; strict;
comment	@ * @;


1.2
date	2000.09.14.22.46.36;	author macke;	state Exp;
branches;
next	1.1;

1.1
date	2000.09.14.21.55.02;	author macke;	state Exp;
branches;
next	;


desc
@@


1.2
log
@comments should be readable.  Unreadable comments should be deleted.
@
text
@#if !defined(ALGORITHM_H)
#define ALGORITHM_H

#include "structure.h"
#include "defines.h"
#include "interface.h"


//	Structures:

struct stackstruct
{
	int stk[51][4],sp;
};

struct arraystruct
{
	char array[7][amax][2];
};

void de_allocate (int **v, int i);
void de_allocate (bool **v, int i);

//	dotarray: dot plot information

class dotarray
{
	int **array;
	int store;

	public:

	dotarray(int size);
	int &dot(int i, int j)
	{

      		return array[j][i];
	}
   	~dotarray();
};

//	arrayclass; 2-d arrays of w and v, used by the dynamic algorithm
class arrayclass {
	int Size;

	public:
   	//int **dg;
	int k;
	int **dg;
	int infinite;
	//ofstream out;

	//the constructor allocates the space needed by the arrays
   	arrayclass(int size)
	{

		// out.open("temp.out");
		// k = infinity;
		infinite = infinity;

		Size = size;
		register int i,j;
		dg = new int *[size+1];

   		for (i=0;i<=(size);i++) {
			dg[i] = new int [size+1];
   		}
		for (i=0;i<=size;i++) {
         		for (j=0;j<size+1;j++) {
            			dg[i][j] = infinity;
			}
		}
	}

	//the destructor deallocates the space used
	~arrayclass()
	{

		// out.close();
		int i;
		// de_allocate (dg,Size+2);
		for (i=0;i<=Size;i++) {
			delete[] dg[i];
		}
		delete[] dg;
	}

	// f is an integer function that references the correct element of
	// the array
   	int &f(int i, int j)
	{

		// out << i<<"\t"<<j<<"\n";
		if (i>j) {
			return infinite;
		} else if (i>Size)
			return f(i-Size,j-Size);	// dg[i-Size][j-Size];
		else
			return dg[i][j-i];		// dg[i][j];
	}
};

//	output used by the dynamic algorithm to produce a save file and
//	used by the opensav() to recall the data in a save file
union output
{
	int i;
	unsigned char ch[4];
	float f;
};

//	prototypes:

//	gets thermodynamic data from data files
int opendat (char *loop2,char *stackf,char *tstackh,char *tstacki,
	char *tloop,char *miscloop, char *danglef, char *int22, char *int21,
	char *coax,char *tstackcoax,char *coaxstack,
	char *tstack,char *tstackm, char *triloop, char *int11,
	datatable* data);

//	converts base to a numeric
void tonum(char *base,structure *ct,int count);

//	get name of file to output
void getout (char *energyfile);
										//	energy info
//	reads ct file
void openct(structure *ct,char *ctfile);
//	energy calculator
void efn2(datatable *data,structure *ct, int structnum = 0);
//	push info onto the stack
void push(stackstruct *stack,int a,int b,int c,int d);
//	pull info from the stack
void pull(stackstruct *stack,int *i,int *j,int *open,int *null,int *stz);
//	calculates energy of stacked base pairs
int erg1(int i,int j,int ip,int jp,structure *ct,datatable *data);
//	calculates energy of a bulge/internal loop
int erg2(int i,int j,int ip,int jp,structure *ct,datatable *data,int a,
	int b);
//	calculates energy of a hairpin loop
int erg3(int i,int j,structure *ct,datatable *data,int dbl);
//	calculates energy of a dangling base
int erg4(int i,int j,int ip,int jp,structure *ct,datatable *data,
	bool lfce);
//	calculates end of helix penalty
int penalty(int i,int j,structure *ct,datatable *data);
int penalty2(int i, int j, datatable *data);
void energyout(structure *ct,char *enrgyfile);

//	inputs a sequence from file seqfile
int openseq (structure *ct,char *seqfile);
//	outputs a ct file
void ctout (structure *ct,char *ctoutfile);

//	the dynamic folding algorithm of Zuker
//	cntrl6 = #tracebacks
//	cntrl8 = percent sort
//	cntrl9 = window
void dynamic (structure *ct,datatable *data,int cntrl6,int cntrl8,int cntrl9,
	TProgressDialog* update=0,char* savfile = 0);

//	Swap two variables
inline void swap(int *a,int *b);

//	converts base to a numeric
int tonumi(char *base);

//	line printer output of structure
void linout(structure *ct,char *file);
//	used by linout to write a digit into the line printer output file
void digit (int row,int column,int pos,arraystruct* table);

//	convert a numeric value for a base to the familiar character
char *tobase (int i);

//	this routine resorts the structures
//	predicted by dynamic according to energies calculated by efn2
void sortstructures (structure *ct);

//	function for outputting info in case of an error
void errmsg(int err,int err1);

//	function informs user of progress of fill algorithm
void update (int i);

//	the force functions are used to initialize the arrays used to apply
//	constraints during the folding process
void forcepair(int x,int y,structure *ct,arrayclass *v);
void forcesingle(int x,structure* ct,arrayclass *v);
void forcedbl(int dbl,structure* ct,int **w,bool *v);
void forceinter(int dbl,structure* ct,int **w);
void forceinterefn(int dbl,structure* ct,int **w);

//	filter is used to choose structures to output after efn2
//	this can make the number of structures more reasonable for inspection
//	it takes a structure, ct, which also contains the final output,
//	percent sort, maximum number of structures, and window size
void filter(structure* ct, int percent, int max, int window);

//	force is used to prepare arrays for the function dynamic, used during
//	the fill routines - it coordinates the force...() functions above
void force(structure *ct,arrayclass *v, int **fce, bool *lfce);

//	opens a save file with information filled by fill algorithm
void opensav(char* filename, structure* ct, arrayclass* w, arrayclass* v,
	int *w3, int *w5,int *vmin,datatable *data);

//	uses fill information to make a suboptimal structures
void traceback(structure *ct, datatable *data,
	arrayclass *v, arrayclass *w, int *w3, int *w5, int **fce,
	bool *lfce,int vmin, int cntrl6, int cntrl8, int cntrl9);

//	calculate the values of all the dots in a dot plot
void dotefn2(structure *ct, datatable *data, arrayclass *v, arrayclass *w,
	int *w3, int *w5, int **fce, bool *lfce,int vmin,dotarray *dots,
	TProgressDialog* PD = 0);
void calcpnum(dotarray *dots, int *pnum, int increment, int numofbases,
	TProgressDialog *PD = 0);

//	this function is used to make a save file after the fill algorithm
void savefile(int i, ofstream* sav);

//	read save files
int readfile(ifstream *read);
//	save dot plot info
void savedot(dotarray *dots,structure *ct, char *filename);
//	read a dot plot file
void readdot(dotarray *dots, structure *ct, char *filename);
//	dpalign will align two dot plots and store the info in the array align
void dpalign(dotarray *dots1,dotarray *dots2,
	structure* ct1,structure *ct2,int *align);
//	return the best dot for base i in dots1 and j in dots2
int getbestdot(dotarray *dots1,dotarray *dots2, structure* ct1,
	structure *ct2, int i, int j);
//	energydump will spit out the composite free energies for a traceback
void energydump (structure *ct, arrayclass *v, int n,char *filename);
//	energydump2 will spit out the composite free energies for a traceback
//	-- with the au penalty associated with the correct entity
void energydump2 (structure *ct, datatable *data,
	arrayclass *v, int n,char *filename);
#endif
@


1.1
log
@Initial revision
@
text
@a0 1

d9 1
a9 3
//***********************************Structures:

/////////////////////////////////////////////////////////////////////
d11 1
a11 2
struct stackstruct //this structure contains a stack of data, used by
						//	functions that analyze a structure piecewise
d13 1
a13 1
int stk[51][4],sp;
d16 1
a16 3
////////////////////////////////////////////////////////////////////

struct arraystruct //array used during the creation of a line out file (linout)
d18 1
a18 1
char array[7][amax][2];
a19 1
//////////////////////////////////////////////////////////////////
d21 2
a22 3
void de_allocate (int **v,int i);//deallocates memory for a 2d array
void de_allocate (bool **v,int i);//alternative form of de_allocate
void de_allocate (int **v,int i);//alternative form of de_allocate
d24 1
a24 2
/////////////////////////////////////////////////////////////////////////
////dotarray encapsulates the array needed to store dot plot information
d26 4
a29 1
class dotarray{
d31 1
a31 2
		int **array;
      int store;
d33 3
a35 1
   public:
d37 2
a38 6
   	dotarray(int size);
      int &dot(int i, int j) {

      	return array[j][i];

      }
a39 2


d42 1
a42 4

////////////////////////////////////////////////////////////////////////
//arrayclass encapsulates the large 2-d arrays of w and v, used by the dynamic
//	algorithm
d44 1
a44 1
   int Size;
d46 1
a46 1
   public:
d48 16
a63 12
      int k;
      int **dg;
      int infinite;
      //ofstream out;

      //the constructor allocates the space needed by the arrays
   	arrayclass(int size) {

      	//out.open("temp.out");

      	///k = infinity;
         infinite = infinity;
d65 2
a66 6
      	Size = size;
      	register int i,j;
      	dg = new int *[size+1];

   		for (i=0;i<=(size);i++)  {
   			dg[i] = new int [size+1];
d68 33
a100 30
         for (i=0;i<=size;i++) {
         	for (j=0;j<size+1;j++) {
            	dg[i][j] = infinity;
            }
         }

      }

      //the destructor deallocates the space used
      ~arrayclass() {

      	//out.close();
      	int i;
       	//de_allocate (dg,Size+2);
         for (i=0;i<=Size;i++) {
         	delete[] dg[i];
         }
         delete[] dg;
      }

      //f is an integer function that references the correct element of the array
   	int &f(int i, int j) {
      	//out << i<<"\t"<<j<<"\n";
      	if (i>j) {
         	return infinite;
         }
         else if (i>Size) return f(i-Size,j-Size);//dg[i-Size][j-Size];
         else return dg[i][j-i];
         //else return dg[i][j];
      }
d103 4
a106 4

//output is a union that is used by the dynamic algorithm to produce a save file
//	and used by the function opensav() to recall the data in a save file
union output {
d108 2
a109 3
   unsigned char ch[4];
   float f;

d112 1
d114 6
a119 3



d121 2
a122 1
//**********************************prototypes:
d124 2
a125 7
int opendat (char *loop2,char *stackf,char *tstackh,char *tstacki,
		char *tloop,char *miscloop, char *danglef, char *int22, char *int21,
      char *coax,char *tstackcoax,char *coaxstack,
      char *tstack,char *tstackm, char *triloop, char *int11, datatable* data);
		//gets thermodynamic data from data files
void tonum(char *base,structure *ct,int count); //converts base to a numeric
void getout (char *energyfile);//get name of file to output
d127 7
a133 3
void openct(structure *ct,char *ctfile);//reads ct file
void efn2(datatable *data,structure *ct, int structnum = 0);//energy calculator
void push(stackstruct *stack,int a,int b,int c,int d);//push info onto the stack
d135 1
a135 1
														//pull info from the stack
d137 1
a137 1
		//calculates energy of stacked base pairs
d140 1
a140 1
		//calculates energy of a bulge/internal loop
d142 1
a142 1
		//calculates energy of a hairpin loop
d145 1
a145 1
		//calculates energy of a dangling base
a146 1
	//calculates end of helix penalty
d149 10
a158 3
int openseq (structure *ct,char *seqfile);//inputs a sequence from file
															// seqfile
void ctout (structure *ct,char *ctoutfile);//outputs a ct file
d161 6
a166 15
			//this is the dynamic folding algorithm of Zuker
         //cntrl6 = #tracebacks
         //cntrl8 = percent sort
         //cntrl9 = window
inline void swap(int *a,int *b);//Swap two variables
inline void swap(int *a,int *b);//swap two variables
int tonumi(char *base); //converts base to a numeric
void linout(structure *ct,char *file);//line printer output of structure
void digit (int row,int column,int pos,arraystruct* table);//used by linout
													//to write a digit into the line
                                       //printer output file
char *tobase (int i);//convert a numeric value for a base to the familiar
								//character
void sortstructures (structure *ct);//this routine resorts the structures
					//predicted by dynamic according to energies calculated by efn2
d168 4
a171 2
void errmsg(int err,int err1);//function for outputting info in case of an error
void update (int i);//function informs user of progress of fill algorithm
d173 15
a187 2
//the force... functions are used to initialize the arrays used to apply
//constraints during the folding process
d194 1
a194 1
//filter is used to choose structures to output after efn2
d200 2
a201 2
//force is used to prepare arrays for the function dynamic, used during the
//	fill routines - it coordinates the force...() functions above
d203 2
d206 6
a211 5
	int *w3, int *w5,int *vmin,datatable *data);//opens a save file with information filled by
   									//fill algorithm
void traceback(structure *ct, datatable *data, arrayclass *v, arrayclass *w, int *w3, int *w5, int **fce,
	bool *lfce,int vmin, int cntrl6, int cntrl8, int cntrl9);//uses fill information to
   																			// make a suboptimal structures
d213 1
a213 1
//this function is used to calculate the values of all the dots in a dot plot
d216 1
a216 1
   TProgressDialog* PD = 0);
d219 14
a232 6
void savefile(int i, ofstream* sav);//this function is used to make a save file
											//after the fill algorithm
int readfile(ifstream *read);//this function is used to read save files
void savedot(dotarray *dots,structure *ct, char *filename); //save dot plot info
void readdot(dotarray *dots, structure *ct, char *filename);//read a dot plot file
void dpalign(dotarray *dots1,dotarray *dots2,structure* ct1,structure *ct2,int *align);
d234 2
a235 3
	structure *ct2, int i, int j);//return the best dot for base i
   //in dots1 and j in dots2
//dpalign will align two dot plots and store the info in the array align
d237 4
a240 4
//energydump will spit out the composite free energies for a traceback
void energydump (structure *ct, datatable *data,arrayclass *v, int n,char *filename);
//energydump2 will spit out the composite free energies for a traceback -- with
//the au penalty associated with the correct entity
@
