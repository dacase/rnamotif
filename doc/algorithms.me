.he '\fR\n(mo/\n(dy/\n(y2'Algorithms'%'
.bp
.sh 1 "Algorithm."
.pp
\fCrnamotif\fR is a program that searches nucleic acid sequence databases for
entries that can adopt a particular secondary structure.  This secondary
structure is defined via a pattern language whose symbols represent helices
and single stranded stretches.  These elements can be parameterized as to
length, sequence, pairing etc, provding a measure of control over the the
sequences the pattern matches.  Where \fCrnamotif\fR differs from its
predecessors (\fCrnamot\fR, \fCpalingol\fR, \fCpatscan\fR) is that it combines
these pattern elements with an \fCawk\fR-like scoring section that is used to
add capabilities that patterns alone can not provide.  In particular, this
score section allows users to enforce arbitrary sequence context relations
between the pattern elements and to perform counts on the bases of the actual
sequences that matched the pattern elements.
.pp
The key to making this work was the realization that the symbols that specify
the structure elements in the search pattern can have a second related meaning.
In the pattern section they describe the motif, but in the score section they
represent (with some qualification) the actual sequences that matched those
pattern elements.  For example, in the pattern section, the symbols
\fCh5(tag='hlx-A')\fR, represent the 5'-end of a Watson/Crick duplex labelled
\fChlx-A\fR, but the same symbols in the score section would represent the
actual sequence that matched that part of the pattern.  Allowing these symbols
to act like readonly string variables with length and substring operations
and combining them with standard programming constructs like assignments,
expressions, testing and looping, makes it easy to implement the arbitrary
context relations that \fCrnamotif\fR's predecessors so sorely needed.
.pp
\fCrnamotif\fR uses a two stage algorithm to perform the search. Stage one
compiles the motif along with any scoring rules into a search list and a set of
instructions for the scoring interpreter.  Stage two executes the search,
testing each entry in the sequence database first, for matches to the pattern,
and then those that match the pattern are tested against any scoring rules.
Matching sequences, along with the sequence name and location information are
written to \fCstdout\fR.
.sh 2 "Compilation."
.pp
The target secondary structure, along with its scoring rules and other
information is called a descriptor.  Descriptors are stored as ASCII text files
and are created via a text editor.  The inputs to an \fCrnamotif\fR run are
a descriptor and the database file to be searched.
.pp
A descriptor consists of four sections called parameters, descriptor, sites
and score.  The sections must be in that order, although only the descriptor
section is required. The parameters section is used to define variables that
are used in the rest of the descriptor.  It is also used to set \fCrnamotif\fR
defaults.  The descriptor section defines the secondary structure or motif to
search for.  The sites section allows users to specify simple relations among
the elements of the descriptor and the score section is a set of
condition/action pairs that provides direct access to the actual sequences that
matched the elements of the descriptor.  The score section is used for two
things.  It tests each sequence that matched the pattern to see that it also
matches those elements of the motif that can not be represented in the pattern,
and it allows users to evaluate each match and assign it a value (or values)
that shows how closely it matched the motif.
.pp
The descriptor language is formally specified via \fClex\fR and \fCyacc\fR.  The
lexical or text level is specified as a \fClex\fR input file, which contains a
set of regular expressions that define the basic symbols of the descriptor
language.  These are things like numbers, strings, reserved words, special
characters etc.  The scanner generator \fClex\fR converts this file into a
function, called a scanner, that converts the stream of characters in the
descriptor file into a stream of symbols in the \fCrnamotif\fR descriptor
language.  The syntax of this language is specified as a context free grammar
for the parser generator \fCyacc\fR which uses it to produce a parser for the
language.  This parser takes the the stream of symbols produced by the scanner
and assembles it into the actual search list and score program that will perform
the search.
.sh 3 "Preprocessor."
.pp
Compilation requires two passes over the descriptor.  The first pass is a
preprocessor that peforms both file inclusion and interpolation of command line
definitions.  Unlike the \fCrnamotif\fR language itself which is free format,
file inclusion is line oriented.  File inclusion is indicated via the
preprocessor directive
.(l
.ft C
# include \fIfile-name\fC
.ft R
.)b
whose action is to replace this line with the contents of the named file.  File
includes may be nested.  Include files whose names are not absolute paths are
assumed to be located in the current directory.  Additional include directories
can be specified on the command line.  Source file name and line number
information is saved in the expanded file in order to properly locate both
compile and run time errors.
.pp
Interpolation of command line definitions is a way to add runtime flexibility
to descriptors.  Every descriptor may include a parameter section.  This
section, if present, contains one or more assignment statements of the form
\fIvar \fC=\fI expr\fC;\fR  Immediately after parsing the semicolon, the
expression, \fIexpr\fR, is evaluated and stored in the variable \fIvar\fR.
These variables, instead of their values, can then be used elsewhere in the
descriptor removing literals and increasing its readability.  This same
assignment mechanism is also used to change the default values of the
\fCrnamotif\fR search algorithm.  These defaults, which include things like
the pairing rules and minimum and maximum lengths for each type of helix are
made available to the user as a set of predefined variables.  When
\fCrnamotif\fR is invoked, the user can place one or more variable definitions
on the command line.  The preprocessor interpolates these definitions into the
expanded source immediately before the reserved word \fCdescr\fR which starts
the mandatory descriptor section.  The result is that these command line
definitions are the last parameter values to be assigned which means that these
new values will replace any previous values, including the default values of
the builtin variables.  For example, running \fCrnamotif\fR with the command
line definition \fC-Dwc+=gu\fR makes GU pairing the default for all
Watson/Crick helices in the current descriptor.
.sh 3 "Parsing."
.pp
The syntax of the descriptor language is specified by a context free grammar.
Such grammars provide a precise convenient way of describing recursive
structures like computer languages.  Because nucleic acid secondary structures
are also recursive \(em helices contain other helices which contain still other
helices \(em we suspect that a context free grammar can be written that
generates nucleic secondary structures and that it will be easy to integrate
this new grammar with the one that describes the traditional computer language
part of an \fCrnamotif\fR descriptor. Unfortunately, this is not the case as
context free grammars are not powerful enough to generate arbitrary pseudoknots,
which are an important class of nucleic acid secondary structures.
Nevertheless, the idea of decomposing complex objects into a well defined
hierarchy of simple building blocks is a powerful one, and the insights gained
from how a context free grammar can generate many important nucleic acid
secondary structure are used throughout \fCrnamotif\fR.
.pp
Consider the following grammar.  This grammar is extremely simple, yet it can
generate a large number of nucleic acid secondary structures.  It consists of
one rule with three parts.
.(l
.ft C
\fIS\fC		:  \fIS\fC h5 \fIS\fC h3 \fIS\fC
		|  ss
		| 
.ft R
.)b
This is a rewriting rule and when used it replaces the generic secondary
structure \fIS\fR, on the left side of the rule with one of the more detailed
secondary structures on the right side. The process continues until all of
the unspecified secondary structure has been replaced by either Watson/Crick
helices, single stranded stretches or nothing.  The rule and the process it
defines are a recursive definition of nucleic acid secondary structure:  A
secondary structure is either a Watson/Crick helix (shown as \fCh5\fR ...
\fCh3\fR) both surrounded by and containing additional secondary structure, or
a single stranded stretch (shown as \fCss\fR), or nothing at all.  In the
example below, the rule is used four times to create a simple hairpin.  In the
first and third applications, the third part of the rule (\fIS\fC ->\fR ) is
used so that this structure begins and ends with a helix. 
.(l
.ft C
\fIS\fC		-> \c
\kx\l'\w"\fIS\fC"u\(ul'\h'|\nx'\fIS\fC \c
h5 \fIS\fC h3 \fIS\fC
		-> h5 \c
\kx\l'\w"\fIS\fC"u\(ul'\h'|\nx'\fIS\fC \c
h3 \fIS\fC
		-> h5 ss h3 \c
\kx\l'\w"\fIS\fC"u\(ul'\h'|\nx'\fIS\fC
		-> h3 ss h3
.ft R
.)b
.pp
There are two ways to apply this rule to create more complex structures.  If
the second application is to the trailing (or leading) \fIS\fR, the result is
two consecutive hairpins:
.(l
.ft C
\fIS\fC		-> \fIS\fC h5 \fIS\fC h3 \c
\kx\l'\w"\fIS\fC"u\(ul'\h'|\nx'\fIS\fC
		-> \fIS\fC h5 \fIS\fC h3 \fIS\fC h5 \fIS\fC h3 \fIS\fC
.ft R
.)b
The more interesting case is when the rule is applied to the interior \fIS\fR:
.(l
.ft C
\fIS\fC		-> \fIS\fC h5 \c
\kx\l'\w"\fIS\fC"u\(ul'\h'|\nx'\fIS\fC          \|\|\c
h3 \fIS\fC
		-> \fIS\fC h5 \fIS\fC h5 \fIS\fC h3 \fIS\fC h3 \fIS\fC
.ft R
.)b
which creates an \fIinterior\fR loop, (the outer \fCh5\fR ... \fCh3\fR)
containing a hairpin.  Repeated application of this rule easily creates more
complicated structures.  In the next example, the rule is used four times to
create a tRNA cloverleaf.
.(l
.ft C
\fIS\fC		-> \fIS\fC h5 \c
\kx\l'\w"\fIS\fC"u\(ul'\h'|\nx'\fIS\fC                              \c
h3 \fIS\fC
		-> \fIS\fC h5 \fIS\fC h5 \fIS\fC h3 \c
\kx\l'\w"\fIS\fC"u\(ul'\h'|\nx'\fIS\fC                    \|\^\c
h3 \fIS\fC
		-> \fIS\fC h5 \fIS\fC h5 \fIS\fC h3 \fIS\fC h5 \fIS\fC h3 \c
\kx\l'\w"\fIS\fC"u\(ul'\h'|\nx'\fIS\fC          \|\|\c
h3 \fIS\fC
		-> \fIS\fC h5 \fIS\fC h5 \fIS\fC h3 \fIS\fC h5 \fIS\fC h3 \fIS\fC h5 \fIS\fC h3 \fIS\fC h3 \fIS\fC
		     ^    ^    ^    ^    ^   ^    ^    ^
		     |    |    |    |    |   |    |    |
		     |    +----+    +----+   +----+    |
		     +---------------------------------+
.ft R
.)b
Finally, this basic rule can be extended to create other types of helices. Here
is an extension to create  parallel duplexes, triplexes and quadruplexes,
although in the case of the 3- and 4- strand helices, the rule does not define
the strand order.
.(l
.ft C
\fIS\fC		:  \fIS\fC h5 \fIS\fC h3 \fIS\fC
		|  \fIS\fC p5 \fIS\fC p3 \fIS\fC
		|  \fIS\fC t1 \fIS\fC t2 \fIS\fC t3 \fIS\fC
		|  \fIS\fC q1 \fIS\fC q2 \fIS\fC q3 \fIS\fC q4 \fIS\fC
		|  ss  
		|
.ft R
.)b
.pp
As powerful as the basic rule is, there is an important class of structures,
the pseudoknots, that it can not generate.  The basic rule can only generate
properly nested structures, ie, structures in which every helix is either
completely nested inside of another helix or not nested inside any helix at
all.  Pseudoknots, however, are composed of improperly nested helices, helices
in which no helix is completely contained in any other helix of the pseudoknot.
The canonical pseudoknot consists of two helices, whose nesting is shown below.
The two helices are clearly connected, but neither is contained inside the
other.
.(l
.ft C
		h5 \fIS\fC h5 \fIS\fC h3 \fIS\fC h3
		^    ^    ^    ^
		|    |    |    |
		+---------+    | 
		     |         |
		     +---------+
.ft R
.)b
.pp
That the rule can not generate such improperly nested structures follows 
immediately from the fact that its application replaces \fIone\fR
piece of unspecified secondary structure (an \fIS\fR) with a \fIsingle\fR,
\fIcomplete\fR helix, which is by definition properly nested.  Since the
original structure was properly nested, the single secondary structure the
rule was applied to was either completely within some helix or not nested at
all.  And because the action of the rule is located solely in this single
secondary structure, the new helix is either completely contained in the
original containing helix or also not nested, which results in a new properly
nested structure.
.pp
Pseudoknots, by their very nature are made of helices that have one end inside
of another helix of the pseudoknot and the other end either outside of it
entirely, or inside yet another helix of the pseudoknot.  A rule generating
these types of structures would require action at two \fIS\fR regions, one for
the 5'-part and one for the 3'-part.  Of course, we could extend the basic
rule to generate canonical pseudoknots directly, and one such extension is
shown below.
.(l
.ft C
\fIS\fC		:  \fIS\fC h5 \fIS\fC h3 \fIS\fC
		|  \fIS\fC pk5 \fIS\fC pj5 \fIS\fC pk3 \fIS\fC pj3 \fIS\fC
		|  ss
		|
.ft R
.)b
This rule generates two helix pseudoknots (\fCpk5\fR/\fCpk3\fR,
\fCpj5\fR/\fCpj3\fR) but it can't generate ones with three (or more) helices.
We could add more rules for each class of pseudoknots that \fCrnamotif\fR is to
support, but this would add complexity, lack elegance and worst of all, would
limit the \fCrnamotif\fR's descriptive and search abilities to pseudoknots of
some fixed complexity, which is unacceptable.
.pp
Fundamentally, the problem with pseudoknots is not generating the correct
sequence of \fCh5\fR/\fCh3\fR symbols, but in correctly linking them.  This is
because many sequences of these symbols are ambiguous \(em the various
\fCh5\fR/\fCh3\fR elements can be paired up in several different ways.  The
symbols below illustrate this.
.(l
.ft C
		h5 \fIS\fC h5 \fIS\fC h3 \fIS\fC h3
.ft R
.)b
If the outermost \fCh5\fR/\fCh3\fR are paired, the result is an
internal/hairpin loop, but if the first \fCh5\fR is paired with first \fCh3\fR,
the result is a pseudoknot.  In the grammar under discussion, this ambiguity is
resolved by pairing the \fCh5\fR/\fCh3\fR elements so that an unpaired \fCh3\fR
is paired with the closest unpaired \fCh5\fR; all other pairings are not
considered.
.pp
The advantage to using a context free grammar to generate nucleic acid secondary
structures is that it would embody the structure of even very complicated motifs
directly in the sequence of symbols that represent a set of basic motifs or
building blocks. No additional linking information would be required.
Unfortunately, this is not possible.  However, as was mentioned at the beginning
of this section, the idea of representing complex objects as a hierarchy of
basic motifs is a powerful one and well worth keeping, even if their
\fIhierarchy\fR can not be represented as a context free grammar.
.pp
The building blocks that \fCrnamotif\fR uses to describe arbitrary motifs are
the Watson/Crick helix, the single stranded stretch, three other types of
proper helix and arbitrary pseudoknots made from Watson/Crick duplexes.  The
other  proper helices are the parallel duplex, a triplex based on Hoogsteen
pairs and their analogs with strand order \(ua\(da\(ua and a quadruplex where
the strand order is \(ua\(da\(ua\(da.  All of these basic motifs, including
the pseudoknots have two important characteristics.  First, they partition the
sequence into three types of subsequences: the exterior, which precedes and
follows the motif, the sequences involved in the helical strands themselves and
one, two, three or more interior regions, depending if the motif is a duplex,
triplex, quadruplex or pseudoknot.  Their second characteristic is that they
are atomic \(em no helical strand can be removed without destroying the motif.
Pseudoknots differ from the other motifs only in that the helical strands on
the two sides of an interior region are parts of different Watson/Crick
duplexes.
.pp
The grammar that describes the \fCrnamotif\fR descriptor language is basically
that of a simple \fCawk\fR-like language with only those extensions that are
required to demarcate the sections of a descriptor and define the structure
elements that are used to build the target motif.  Both descriptor sections and
structure elements are denoted by new reserved words.  Changes to a structure
element's default values are made by appending a parameter list to the reserved
word for that particular element.  Since many of these parameters have values
of the same type, parameters are identified by keyword rather than position.
For example, the motif fragment shown below contains three structure elements,
the first two of which have parameters.
.(b
.ft C
	h5( minlen=4, maxlen=10, mispair=2 ) ss( seq="^gnra$" ) h3
.ft R
.)b
These three elements describe a GNRA-loop with a stem length of 4-10, using
the default pairing rule for Watson/Crick duplexes, but allowing upto 2 
mispairs.  The grouping of these structure elements into a Watson/Crick
duplex, one of \fCrnamotif\fR's building blocks is done after the entire
source has been parsed.  This process is discussed in the next section.
.sh 3 "Motif Discovery and Analysis."
.pp
If no errors are encountered during the parsing stage, the structure elements
and associated data are translated into a search program.  This process
involves several steps.  First, the structure elements are linked into helices.
Then the parameters for each helix, which may be distributed among the
parameter lists of the helix's individual strands must be collected and
checked for consistancy.  Next, improper helices are dectected and grouped
into pseudoknots.  At this point, all of the structure elements have been
assembled into \fCrnamotif\fR's fundamental motifs and their hierarchical
nesting is determined.  This hierarchy is used to propagate length limits
upward allowing for a more efficient search.  The motif hierarchy is
linearized to form a search list that is use to drive the actual search.  
.pp
As was shown above, the context free grammar that defines \fCrnamotif\fR's
input language, is not powerful enough to directly generate linking information
for arbitrarily complex improperly nested structures.  Instead, the sequence of
structure symbols is saved in the order they were encountered and then linked
after the parsing is complete.  Improperly nested helices (ie parts of
pseudoknots) and all triplexes and quadruplexes must have each helical strand
labelled.  Structure elements with the same label are grouped and checked that
they form a single helix with the correct number elements and that these
elements are in the proper order.  Then the unlabelled elements are grouped,
using the rule that an unpaired \fCh3\fR element is paired with the closest
(upstream) \fCh5\fR element.  If any ungrouped helical elements remain after
this process, the descriptor is incorrect and the search is aborted.
.pp
Next the parameters (if any) for the structure elements are collected and
checked for consistancy.  In the case of helices these parameters may be
distributed among parameter lists attached to any of the structure elements
that define the strands of the helix.  All structure elements may have length,
sequence and mismatch constraints; helices may also include parameters that
specify the pairing rule, mispair limits (both absolute number of mispairs
and/or fraction that must be paired) and whether or not a helix can begin
and/or end with mispair.  All explicit length constraints (\fCminlen\fR,
\fCmaxlen\fR, \fClen\fR) must agree.  Implicit length constraints derived from
sequence constraints must be consistant with any explicit length constraints.
As sequence constraints are specified as simple regular expressions without
alternation, this means that fully anchored regular expressions with a fixed
length (eg \fC^gnra$\fR) must agree exactly with any explicit length
constraints.  Any regular expression with a variable length must match a
sequence whose minimum length does not exceed the explicit maximum length (if
set) of this helix (or single stranded region).  If two or more helical
strands have regular expressions with variable but differing lengths, the
implied minimum length of this helix is set to the longest minimum length of
these regular expressions.  If any errors have been detected in this phase the
search is aborted.
.pp
After parameter processing any improperly nested helices are grouped into
pseudoknots.  As was discussed above, \fCrnamotif\fR considers pseudoknots
to be a basic motif, albeit one with a variable number of helical strands.
\fCrnamotif\fR flattens the set of helices that compose the pseudoknot into
an  extended structure containing 2\^\fIN\fR \- 1 interior regions where
\fIN\fR is the number of Watson/Crick duplexes in the pseudoknot.  This new
structure is anchored by the 5'-strand (\fCh5\fR) of its leftmost helix.
All \fCrnamotif\fR pseudoknots must be composed of only Watson/Crick duplexes.
.pp
The last step in the motif discovery and analysis phase is to convert the
set of fully linked and parameterized fundamental motifs that define the target
secondary structure into a search list.  The motifs in this set form a tree
and a preorder traversal of this tree is used to form the search list.  A 
postorder traversal of this tree is used to propagate length limits defined
for sub-motifs upward to the motif that contains them in order to improve the
efficiency of the search.  The tree is built recursively.  Every fundamental
motif is a tree.  This tree has one subtree for the substructure(s) contained
in each of its interior regions and one subtree for the substructure that
follows it.  Single stranded regions have at most one subtree, that of their
successor.  The root of the tree that is built from the target secondary
structure is its leftmost motif.  The preorder traversal of this tree is then:
begin with the root and visit it, then visit each of its interior subtrees in
left to right order and then visit the subtree that follows it.  The postorder
traversal also begins as the root, but first visits a node's interior subtrees,
also in left to right order, then its successor subtree and finally visits the
node itself.  The following table shows several secondary structures, their
associated trees and the search lists that are derived from those trees.
.TS
allbox center ;
cf(B) cf(B) cf(B) . 
Motif	Tree	Search List
_
.T&
lf(C)w(2.25i) lf(C)w(1.75i) lf(C)w(1.75i) 
l ^ ^ .
ss	T{
.nf
ss\(-> 
.fi
T}	ss
T{
.ft R
Single Stranded. No interior, at most a successor.
.ft C
T}
.T&
lf(C)w(2.25i) lf(C)w(1.75i) lf(C)w(1.75i) 
l ^ ^ .
h5 ss h3	T{
.nf
h5\(->
\(da
ss\(->
.fi
T}	h5, ss
T{
.ft R
Single Watson/Crick helix forming a hairpin.
T}
.T&
lf(C)w(2.25i) lf(C)w(1.75i) lf(C)w(1.75i) 
l ^ ^ .
h5\*<1\*> ss\*<1\*> h5\*<2\*> ss\*<2\*> h3\*<2\*> ss\*<3\*> h3\*<1\*>	T{
.nf
h5\*<1\*>\(->
\(da
ss\*<1\*>\(->  h5\*<2\*>\(->  ss\*<3\*>\(->
      \^\^\(da
      \^\^ss\*<2\*>\(->
.fi
T}	h5\*<1\*>, ss\*<1\*>, h5\*<2\*>, ss\*<2\*>, ss\*<3\*>
T{
.ft R
Two Watson/Crick helices arranged as an internal loop containing a hairpin.
.ft C
T}
.T&
lf(C)w(2.25i) lf(C)w(1.75i) lf(C)w(1.75i) 
l ^ ^ .
h5\*<1\*> ss\*<1\*> h3\*<1\*> ss\*<2\*> h5\*<2\*> ss\*<3\*> h3\*<2\*>	T{
.nf
h5\*<1\*>\(->  ss\*<2\*>\(->  h5\*<2\*>\(->
\(da           \^\^\^\^\(da
ss\*<1\*>\(->        \^ss\*<3\*>\(->
.fi
T}	h5\*<1\*>, ss\*<1\*>, ss\*<2\*>, h5\*<2\*>, ss\*<3\*>
T{
.ft R
Two consecutive Watson/Crick helices each forming a hairpin. 
.ft C
T}
.T&
lf(C)w(2.25i) lf(C)w(1.75i) lf(C)w(1.75i) 
l ^ ^ .
h5\*<1\*> ss\*<1\*> h5\*<2\*> ss\*<2\*> h3\*<1\*> ss\*<3\*> h3\*<2\*>	T{
.nf
h5\*<1\*>\(->
\(da
h5\*<2\*>\(-> ss\*<1\*>\(-> ss\*<2\*>\(-> ss\*<3\*>\(->
.fi
T}	h5\*<1\*>, h5\*<2\*>, ss\*<1\*>, ss\*<2\*>, ss\*<3\*>
T{
.ft R
Two Watson/Crick helices arranged as a pseudoknot. 
.ft C
T}
.TE
.sh 2 "Searching."
.pp
.pp
The \fCrnamotif\fR pattern finding algorithm takes two inputs:  a search list
describing the pattern and a string which is to be searched for all instances
of that pattern.  The algorithm uses a \*(lqdivide and conquer\*(rq strategy:
Begin with the first position of this string and look for the first motif on
the search list.  If this motif is found, it partitions the string into three
types of substrings.  These are the substrings that make up the motif, zero or
more interior substrings between these motif strings (single stranded regions
have zero interior regions) and a suffix, the part of the search string which
immediately follows the last base of the last motif string.  At this point the
search function recursively calls itself to search for the next motif on the
search list using as its search string either an interior substring or the
suffix substring depending on whether this next motif is nested inside the
motif just found or follows it.
.pp
The algorithm is not complicated but does involve a lot of bookkeeping.  It is
implemented as a hierarchy of functions called by a driver.  The driver takes a
sequence from the database being searched and steps through the bases of this
sequence in left to right order.  At each step it stores the beginning and
ending positions of the substring that is to be searched for instances of the
motif into the first element of the search list.  The beginning position of
the search string is the driver's current position.  The length of this
substring is the smaller of these two values: the length of the longest
possible instance of the motif and the remaining length of the sequence.  The
search terminates when the remaining length of the sequence becomes shorter
than the shortest possible instance of the motif.
.pp
\fCrnamotif\fR does not require the user to specify the maximum length of the
target motif, allowing it in principle to be unbounded.  Thus it could span the
entire sequence, irregardless of the sequence length.  However, as helix
finding is at least
` size 10 O ( N sup 2 ) `,
\fCrnamotif\fR applies a default upper bound to motifs with no explicit maximum
length.  This default value is 6000 and is stored in the builtin variable
\fCwindowsize\fR.  Like any builtin \fCrnamotif\fR variable, \fCwindowsize\fR
can changed either explicitly in the parameter section or by a command line
assignment.
.pp
The top level search routine is called \fCfind_motif()\fR. It takes one
argument, the search list.  The search list is a list of the basic motifs that
the search algorithm can find.  Each element of this list contains the type of
the motif to find and the beginning and ending sequence positions where that
element must be found.  Initially, when \fCfind_motif()\fR is called by the
driver, only the positions for the first element will have been set.  However,
as the search progresses and the various sub-motifs are found, the search
positions for the other list elements will be filled in.  The motif specifed by
the first element of the search list must begin at that element's start
position.  Its end, however, will in general be somewhere between the first
and last positions specified in the element, and \fCfind_motif()\fR manages
the loop that is used to range over this motif's possible ending points. 
.pp
When \fCfind_motif()\fR is called, the start and stop positions in the 
first list element are those of the substring that must hold not only the
motif defined by that first element but also any motifs that follow it.  Using
the analysis performed in the post compilation phase, \fCfind_motif()\fR 
adjusts the stop position of this first element so as to leave sufficient
substring to hold at least the shortest instance of the motif that follows the
first element.  The loop to find the end of the first motif thus runs downward
from this value to the value that is just long enough to hold the shortest
instance of the first motif.  At each iteration of the loop, this loop value
replaces the original stop value in the first search list element and the
loop value plus one becomes the start value of the substring that must contain
the motif that follows the first motif.  The updated search list is passed to
\fCfind_1_motif()\fR which calls the individual search functions that actually
find \fCrnamotif\fR's basic motifs.  These functions and the motifs they find
are listed in the table below.
.TS
center allbox ;
c c .
Function	Motif
_
.T&
lf(C) l .
find_ss()	Single stranded region.
find_wchlx()	Watson/Crick duplex, with strand directions \(ua\(da. 
find_phlx()	Parallel duplex with strand directions \(ua\(ua.
find_triplex()	Hoogsteen base triplex with strand directions \(ua\(da\(ua.
find_4plex()	Quadruplex with strand directions \(ua\(da\(ua\(da.
find_pknot()	Arbitrary pseudoknot formed from Watson/Crick duplexes.
.TE
.pp
These six functions while aimed at different motifs, have a similar structure.
They all take a single argument, a search list.  They all attempt to find the
first motif on this list and by the time they are called, both the start and
stop position of the substring that may contain the motif have been fixed and
the motif must span this substring.  While they obviously differ in how they
find their target motif, they also differ in what happens when that motif is
found.  If the motif is helical, the strands of the helix demarcate one or more
interior substrings.  The sub-motifs nested between these helical strands must
be found in these substrings and in order to do this, a helix finding routine
sets the start and stop positions of the elements of the search list that
correspond to the leftmost motifs of these interior substructures.  The helical
routine then recursively calls \fCfind_motif()\fR with next element of the
search list to find the remainder of the target motif.
.pp
The process is different when a single stranded motif is found.  Single standed
motifs have no interior regions so no start/stop positions in the search list
are updated.  If the single stranded motif has a successor, \fCfind_ss()\fR
recursively calls \fCfind_motif()\fR to find the remainder of the motif.
However, if the motif does not have a successor, this means that a candidate
has been found that matches all the elements in the descriptor.  In this case,
\fCfind_ss()\fR calls routines that check first that the candidate passes any
site restrictions and then passes all scoring rules, at which time it accepted
and is printed along with identifying information and score values to
\fCstdout\fR.
.sh 3 "Imperfect Helices."
.pp
Many nucleic acid secondary structures contain helices that are not perfectly
paired.  These imperfections fall into two classes \(em mispairs and bulges.
\fCrnamotif\fR helices may have mispairs, but not bulges.  Bulges must be
explicitly placed into the descriptor by splitting the helix at each bulge
position and inserting a single stranded stretch into the gap between the
helices.  The minimum and maximum lengths of this single stranded stretch are
the minimum and maximum lengths of the bulge; an optional bulge is created by
a single stranded stretch with a minimum length of zero.  The descriptor
fragment shown below illustrates two helices interrupted by a optional one base
bulge on their 5'-sides.
.(b
.ft C
h5 ss(minlen=0,maxlen=1) h5 ... h3 h3
.ft R
.)b
.pp
The rationale behind the exclusion of bulges from helices is simple:  Helices
with bulges, especially optional bulges are complicated; helices without them
are not.  This complexity appears both in the descriptor and score sections.
In the descriptor section, it is needed to specify the positions and lengths of
the bulges.  In the score section, bulges, especially optional ones, complicate
the addressing of the individual bases in the substrings that matched the
structure elements of those bulged helices.  In helices without bulges, all
strands have the same length.  If a helix has length \fIL\fR, and its strands
are antiparallel the paired bases are numbered 1:\fIL\fR, 2:\fIL\fR\-1, ...,
\fIL\fR:1; if the strands are parallel, the paired bases are numbered 1:1,
2:2, ..., \fIL\fR:\fIL\fR.  In bulged helices, however, the individual strands
have different lengths and the numbering of the paired bases depends on the
locations of the bulges.
.pp
In contrast to bulges, mispairs are simple.  Every type of helix supported by
\fCrnamotif\fR has a default pairing rule which may be overriden for any
individual helix.  A pairing rule is a set of pairs, triples or quads that
when found at corresponding positions in the strands of a helix count as a pair
(or triple, etc.)  Any other combination of bases at these positions is a 
mispair.  Mispair limits other than zero are specified either as a maximum
number of mispairs allowed or as the fraction of the helix that must be paired.
The latter is useful for those helices that can have a highly variable length.
Helices are generally required to begin and end with a pair, but this too is
under user control.  The distribution of mispairs along a helix can not be 
specified at the descriptor level, but is easily handled in the score section.
Mispairs are optional, although the score section can be used to reject any
candidate with less than some number of mispairs.
.sh 3 "Imperfect Sequences."
.pp
Every structure element may include a sequence constraint.  Sequence
constraints are specified as simple regular expressions without alternation.
Mismatches are permitted as long as the regular expression contains no
closure operators.  The closure operator, indicated as a star (\fC*\fR), is
used to specify zero of more instances of the previous regular expression.
For example, in the regular expression \fCA*\fR, the \fC*\fR indicates that
this regular expression matches any number (including zero) of \fCA\fR's.
The effect of this restriction is that only sequence constraints that have a
fixed length can have mismatches.  The mismatch limit is specified as the
maximum number of mismatches allowed with zero as the default.  Like mispairs,
mismatches are optional, but the score section can be used to accept only
those candidates with the required number of mismatches.
.sh 2 "The Sites List."
.pp
Many features of nucleic acid secondary structures can not be represented
as a pattern based descriptor.  \fCrnamotif\fR provides two mechanisms
for incorporation of these features into its descriptors.  The simpler 
and less powerful of these mechanisms is the sites list and is discussed here.
Sites provide a way to specify a limited set of fixed sequence relationships
between specific positions of the motif.  Unlike structure elements, the
elements of a site need not have functional (eg helical) relationship.  Thus
sites provide a way to incorporate longer range \*(lqtertiary\*(rq constraints
into the search.
.pp
A site consists of an ordered list of two to four positions and a set of
\*(lqpairs\*(rq, \*(lqtriples\*(rq or \*(lqquads\*(rq that the represent the
allowed bases as these positions.  The quotes are used here to indicate that
while these bases are specified using \fCrnamotif\fR's syntax for true
hydrogen bonded pairs, etc, no such hydrogen bonding pairing relationship is
implied among the positions specified in the site.  For example, the site shown
below involves a position from one strand each from three different helices
and requires either a \fCg:a:a\fR or \fCg:g:a\fR at these positions.
.sp .5v 
.ce
\fCh5(tag='A',pos=2):h3(tag='B',pos=1):h5(tag='C',pos=$-3) in {"g:a:a","g;g:a"}\fR
.sp .5v
.pp
Each time a candidate sequence matches the pattern based descriptor, the actual
bases corresponding to the site's positions are extracted and checked to insure
that they are among the \*(lqpairs\*(rq, etc allowed at those positions.  If
they are not, the candidate is rejected.  If the site is composed of acceptable
bases, the candidate is provisionally accepted and the next site is checked.
This process continues until a site rejects the candidate or all sites have
been matched in which case the candidate is then scored or in the absense
of a score section, the candidate is accepted.  Because sites are all or
nothing \(em a candidate either matches or fails \(em they lack nuance and
because of this site style constraints along with threshhold values are
generally converted into scoring rules.
.sh 2 "Scoring."
.pp
In many cases it is impossible to completely describe the motif using
patterns only.  The motif may have long range sequence covariation or 
require specific base counts.  Even if the pattern completely specifies the
motif, the various matches may have different values and it is often
necessary to apply some score function to the matches and discard those
below some cutoff.  The score section solves both these problems.
.pp
The score section was modelled after \fCawk\fR.  It consists of one or more
rules, where a rule is composed of an optional condition and an action.  If
the condition is present it is evaluated and if true the action is executed.  
If the condition is absent, the action is always executed.  Like \fCawk\fR
the rules are executed from top to bottom until 1) an \fCACCEPT\fR statement is
executed in which case the candidate is accepted; 2) a \fCREJECT\fR statement
is executed in which case the candidate is rejected, or 3) all scoring rules
have been executed in which case the candidate is accepted.  The scoring
program communicates its results to the output file via the builtin variable
\fCSCORE\fR.  The details of this process are discussed in a separate section
below.
.sh 3 "The Score Interpreter."
.pp
During the parsing phase, the scoring rules are translated into code for a
simple stack machine.  This machine has about 35 instructions, the majority
of which are used to evaluate expressions.  The remainder of the instructions
are used for control flow \(em testing values, branching, looping and accepting
or rejecting the candidate.  The instructions themselves are untyped, with the
actual operation being chosen at runtime based on the types of the operands.
Expressions are evaluated on a stack whose entries contain both the type and
value of the operands.  Variables are stored in the symbol table.  However to
speed up execution, the parser replaces references to variables in the score
program with pointers to those variables' entries in the symbol table, allowing
their values to be fetched or stored without a lookup.
.pp
All variables have one of these types: \fCundefined\fR, \fCinteger\fR,
\fCreal\fR, \fCstring\fR or \fCpairset\fR.  Variables initially have type
\fCundefined\fR until they are assigned a value, at which point they take the
type of that value.  The only type conversions supported are between
\fCinteger\fR and \fCreal\fR.  Variables defined in the parameter section may
not be changed in the score section in order to insure that the descriptor is
not changed during a search.  This applies to the builtin variables as well,
except for the special builtin variable \fCSCORE\fR which is used to
communicate the results of the score program to the output.  Variables defined
in the score section are read/write, but once such a variable has been assigned
a value and a type, it will be reinitialized to the default value of that type
immediately before the score section is executed insuring that each invocation
of the score program is identical.
.pp
All variables are scalars, with one exception.  This is the special readonly
variable \fCse\fR which represents the array of structure elements that define
the target motif.  This array is indexed from 1 to \fCNSE\fR, which is the
builtin variable that holds the number of structure elements in the descriptor.
This array makes it easy to perform things like global counts.  For example,
the score fragment below determines the total number of mispairs in the current
candidate.
.(b
.ft C
.ta .5i
nmp = 0;
for( i = 1; i <= NSE; i++ )
	nmp += mispairs( se[ i ] ); 
.ft R
.)b
.pp
The primary input to every score program is the set of sequences that matched
the structure elements that define the target motif.  The score interpreter
treats these sequences as a set of readonly string variables which are accessed
using the same symbols, with some qualification,  that are used to define the
structure elements of the motif in the descriptor section.  This qualification
is required because structure elements in the descriptor element need not be
named, resulting in an ambiguity that must be resolved in order to get the
correct strings.  The ambiguity is resolved by appending to every such
structure variable information that contains either its name, or its index.
This appendix can contain substring information as well.  The example below
shows the four ways to refer to  substring from the string the matched a
structure element.  This element is the 5'- strand of a Watson/Crick helix,
whose name is \fChlx-A\fR. It is also the fourth element in the descriptor.
Strings begin at position 1, and the substring below is 2 bases long and begins
at position 3.
.(b
.ft C
h5(tag='hlx-a',pos=3,len=2)
h5(index=4',pos=3,len=2)
h5['hlx-a',3,2]
h5[4,3,2]
.ft R
.)b
.pp
In addition to having a sequence, these structure element variables also have
attributes.  These are the total number of mispairs in the current match, the
total number of mismatches to a sequence constraint, and for any element of
type other than single stranded, whether or not, two (or more) bases are paired
(form a triple, etc).  Attributes are accessed by applying a builtin function
to the specified structure variable.  The number of mispairs to a single strand
stretch is defined to be zero as is the number of mismatches if no sequence
constraint was specified.  The builtin function \fCpaired()\fR is a generic
pairing relationship and works on all helical elements.  The elements of
\fCpaired()\fR must all be from the same helical element, but need not be
corresponding bases.  In the example below, the call to \fCpaired()\fR extracts
the bases at positions \fCi\fR, \fCj\fR and \fCk\fR from the triplex named
\fCTr1\fR and tests if they are valid triple using the rule in force for this
triplex.
.(b
.ft C
mismatches( ss['A-Codon'] )
mispairs( h5['D-Loop'] )
paired( t1['Tr1',i,1], t2['Tr1',j,1], t3['Tr1',k,1] )
.ft R
.)b
.sh 3 "Turner Energy."
.pp
One of the more useful capabilities of the score interpreter is its ability to
evaluate the free energy of either the current match or any part of it.
This is done by calling the builtin function \fCefn()\fR, which takes two
arguments, the beginning and ending positions of the structure whose energy
is to be evaluated.  It uses the descriptor to convert the selected seqeunce
into a base pair and connection table and then applies the Turner energy
function to that table.
.pp
The fit between the Turner rules and \fCrnamotif\fR structures is not perfect,
resulting in a number of clashes.  The Turner rules are defined only for those
structures composed of perfectly nested Watson/Crick helices and therefore can
not be applied to any structure containing (even a part of) a parallel duplex,
triplex or quadruplex.  If such a structure is passed to \fCefn()\fR the
function returns an energy value of \fCINFINITY\fR, which following the
convention of Zuker and Turner has the value of 160.  The perfect nesting
restriction also means the Turner rules can not handle pseudoknots, and they
too are assigned the same energy value of \fCININITY\fR.
.pp
A second type of clash involves mispairs.  \fCrnamotif\fR considers
corresponding bases of helical strands paired if they match the pairing rule
in effect for that helical element.  The Turner energy function however,
divides mispairs into two classes.  The two bases involved could form a
non-canonical mispair, or they could form an internal 1\(mu1 loop.  Theses two
cases have different 3-D structures and hence have different energies.
\fCrnamotif\fR allows users to choose how mispairs are treated.  The user can
choose to create a base pairing table limited to the standard Watson/Crick
pairs (possibly including GU pairs), in which case all other types of mispairs
in an \fCrnamotif\fR structure element will be treated as loops.  Alternatively,
the user can tell \fCrnamotif\fR to create a base pair table that asserts that
all corresponding bases in the two strands of helical element that meet that
helix's pairing rule are paired, in which case the thermodynamic values for
those bases as mispairs instead of loops will used.
.sh 3 "Writing the score."
.pp
Every program must have a way to communicate its results to the user and
\fCrnamotif\fR scoring programs are no exception.  Fortunately, \fCrnamotif\fR's
output requirements are simple.  Each time \fCrnamotif\fR finds a sequence that
matches the entire descriptor \(em pattern, sites and score, it must write out
the details of the match (entry name, match location and the substrings that
matched the pattern elements) along with any values computed by the scoring
rules.  \fCrnamotif\fR uses the builtin variable \fCSCORE\fR to hold those
values.  If the result is a single number, then simply assigning it to the
\fCSCORE\fR will work, but if there are two or more results, some additional
mechanism will be required to encode these results in a single variable.  The
solution chosen by \fCrnamotif\fR is based on the traditional \fCC\fR/\fCawk\fR
character formatting function \fCsprintf()\fR.
.pp
The \fCrnamotif\fR builtin function \fCsprintf()\fR takes two or more arguments
and converts them into a character string.  A user wishing to report several
score values simply evaluates them into several local score section variables
then passes these variables, along with the appropriate format string to
\fCsprintf()\fR which converts them into a single character string.  If this
character string is assigned to the special variable \fCSCORE\fR its value will
be printed along with the match details each time a candidate is accepted.
.pp
The first argument to \fCsprintf()\fR is the format string which controls the
conversion of the second and subsequent arguments into printable form.  This
format string is composed of a mixture of ordinary character and format
specifiers and works like this.  When \fCsprintf()\fR is called, the format
string is scanned from left to right.  Each time an ordinary character is
encountered, it is simply copied to the output string.  However, when a format
specifier is encountered it is replaced by the character representation of the
argument it references. Which argument is converted and the details of this
conversion are determined by the format specifier.
.pp
Format descriptors can be quite complex involving not just the value to convert,
but also information describing the width, precision and fill characters of the
conversion.  Complicating matters further, the width and/or precision
information can be supplied at runtime from other arguments of the
\fCsprintf()\fR call.  Nonetheless, decomposing a format descriptor into its
constituent parts, and supplying proper defaults for those parts that are 
missing is a straightforward if detailed process.  Unfortunately, the
conversion of numbers, especially those near the hardware's representation 
limits is not.  For this reason \fCrnamotif\fR uses the following
implementation of \fCsprintf()\fR. 
.pp
When \fCsprintf()\fR is called, the stack is marked and the \fCsprintf()\fR
parameters are evaluated in left to right order and pushed onto the stack.  The
format string is thus at the mark pointer and the number of arguments is the
difference between the stack pointer and the mark pointer.  The \fCsprintf()\fR
code takes the format string and begins scanning it.  Ordinary characters are
copied to the end of an initially empty work buffer.  When a format specifier
is encountered, it is parsed to find its arguments and these arguments are
passed to the appropriate C language (\fCrnamotif\fR is written in C)
\fCsprintf()\fR routine which performs the actual conversion. The converted
characters are concatenated to the end of the work buffer and the process
repeated until the format string is exhausted, at which time, the arguments to
\fCsprint()\fR are removed from the stack and replaced by the contents of the
work buffer. Because, \fCrnamotif\fR has only three fundamental data types:
\fCinteger\fR, (C \fCint\fR), \fCreal\fR (C \fCdouble\fR) and \fCstring\fR (C
\\0-terminated strings), only those conversions that work on those data types
are supported.  Even so, \fCrnamotif\fR's \fCsprintf()\fR can do a lot more
than just print out numbers.
